{
  "$schema": "https://raw.githubusercontent.com/kerwanp/sidekit/refs/heads/main/schemas/kit.json",
  "name": "Hono.js",
  "description": "Rules and guidelines for the Hono.js web framework",
  "rules": [
    {
      "parent": "honojs",
      "id": "authentication",
      "name": "Authentication",
      "description": "Authentication strategies and implementation",
      "type": "rule",
      "content": "## Authentication\n\n### Rules\n\n- Passwords MUST be hashed using bcrypt or similar secure algorithms\n- JWT tokens MUST have appropriate expiration times\n- Refresh tokens MUST be implemented for long-lived sessions\n- Session data MUST be stored securely\n- Authentication middleware MUST be applied to protected routes\n- Rate limiting MUST be implemented for authentication endpoints\n- Multi-factor authentication SHOULD be supported for sensitive applications\n- Authentication state MUST be properly managed across requests\n- Logout functionality MUST invalidate tokens/sessions\n\n### JWT Authentication\n\n```typescript\n// src/lib/auth.ts\nimport { sign, verify } from 'hono/jwt'\nimport bcrypt from 'bcryptjs'\nimport { HTTPException } from 'hono/http-exception'\n\nexport interface JWTPayload {\n  sub: string\n  email: string\n  role: string\n  iat: number\n  exp: number\n}\n\nexport interface RefreshTokenPayload {\n  sub: string\n  tokenType: 'refresh'\n  iat: number\n  exp: number\n}\n\nexport const authConfig = {\n  jwtSecret: process.env.JWT_SECRET!,\n  jwtExpiration: '15m',\n  refreshTokenExpiration: '7d',\n  saltRounds: 12\n}\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, authConfig.saltRounds)\n}\n\nexport async function verifyPassword(\n  password: string, \n  hash: string\n): Promise<boolean> {\n  return bcrypt.compare(password, hash)\n}\n\nexport async function generateTokens(user: { id: string; email: string; role: string }) {\n  const now = Math.floor(Date.now() / 1000)\n  \n  const accessToken = await sign(\n    {\n      sub: user.id,\n      email: user.email,\n      role: user.role,\n      iat: now,\n      exp: now + 15 * 60 // 15 minutes\n    },\n    authConfig.jwtSecret\n  )\n  \n  const refreshToken = await sign(\n    {\n      sub: user.id,\n      tokenType: 'refresh',\n      iat: now,\n      exp: now + 7 * 24 * 60 * 60 // 7 days\n    },\n    authConfig.jwtSecret\n  )\n  \n  return { accessToken, refreshToken }\n}\n\nexport async function verifyAccessToken(token: string): Promise<JWTPayload> {\n  try {\n    const payload = await verify(token, authConfig.jwtSecret) as JWTPayload\n    return payload\n  } catch (error) {\n    throw new HTTPException(401, { message: 'Invalid or expired token' })\n  }\n}\n\nexport async function verifyRefreshToken(token: string): Promise<RefreshTokenPayload> {\n  try {\n    const payload = await verify(token, authConfig.jwtSecret) as RefreshTokenPayload\n    \n    if (payload.tokenType !== 'refresh') {\n      throw new Error('Invalid token type')\n    }\n    \n    return payload\n  } catch (error) {\n    throw new HTTPException(401, { message: 'Invalid refresh token' })\n  }\n}\n```\n\n### Authentication Middleware\n\n```typescript\n// src/middleware/auth.ts\nimport { Context, Next } from 'hono'\nimport { HTTPException } from 'hono/http-exception'\nimport { verifyAccessToken } from '../lib/auth'\nimport { userRepository } from '../lib/db'\n\nexport const authMiddleware = async (c: Context, next: Next) => {\n  const authHeader = c.req.header('Authorization')\n  \n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    throw new HTTPException(401, { message: 'Missing or invalid authorization header' })\n  }\n  \n  const token = authHeader.substring(7)\n  \n  try {\n    const payload = await verifyAccessToken(token)\n    \n    // Optional: Verify user still exists\n    const user = await userRepository.findById(payload.sub)\n    if (!user) {\n      throw new HTTPException(401, { message: 'User not found' })\n    }\n    \n    // Add user data to context\n    c.set('userId', payload.sub)\n    c.set('userEmail', payload.email)\n    c.set('userRole', payload.role)\n    c.set('user', user)\n    \n    await next()\n  } catch (error) {\n    if (error instanceof HTTPException) throw error\n    throw new HTTPException(401, { message: 'Invalid token' })\n  }\n}\n\n// Role-based authorization middleware\nexport const requireRole = (role: string) => {\n  return async (c: Context, next: Next) => {\n    const userRole = c.get('userRole')\n    \n    if (userRole !== role) {\n      throw new HTTPException(403, { \n        message: `Insufficient permissions. Required role: ${role}` \n      })\n    }\n    \n    await next()\n  }\n}\n\n// Multiple roles authorization\nexport const requireAnyRole = (roles: string[]) => {\n  return async (c: Context, next: Next) => {\n    const userRole = c.get('userRole')\n    \n    if (!roles.includes(userRole)) {\n      throw new HTTPException(403, {\n        message: `Insufficient permissions. Required roles: ${roles.join(', ')}`\n      })\n    }\n    \n    await next()\n  }\n}\n\n// Optional authentication (for public endpoints that show different data for authenticated users)\nexport const optionalAuth = async (c: Context, next: Next) => {\n  const authHeader = c.req.header('Authorization')\n  \n  if (authHeader && authHeader.startsWith('Bearer ')) {\n    const token = authHeader.substring(7)\n    \n    try {\n      const payload = await verifyAccessToken(token)\n      const user = await userRepository.findById(payload.sub)\n      \n      if (user) {\n        c.set('userId', payload.sub)\n        c.set('userEmail', payload.email)\n        c.set('userRole', payload.role)\n        c.set('user', user)\n      }\n    } catch (error) {\n      // Ignore authentication errors for optional auth\n    }\n  }\n  \n  await next()\n}\n```\n\n### Authentication Routes\n\n```typescript\n// src/routes/auth.ts\nimport { Hono } from 'hono'\nimport { zValidator } from '@hono/zod-validator'\nimport { z } from 'zod'\nimport { HTTPException } from 'hono/http-exception'\nimport { \n  hashPassword, \n  verifyPassword, \n  generateTokens, \n  verifyRefreshToken \n} from '../lib/auth'\nimport { userRepository } from '../lib/db'\nimport { authMiddleware } from '../middleware/auth'\n\nconst registerSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8).max(100),\n  name: z.string().min(1).max(100)\n})\n\nconst loginSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(1)\n})\n\nconst refreshTokenSchema = z.object({\n  refreshToken: z.string()\n})\n\nconst changePasswordSchema = z.object({\n  currentPassword: z.string(),\n  newPassword: z.string().min(8).max(100)\n})\n\nconst auth = new Hono()\n\n// Register\nauth.post('/register',\n  zValidator('json', registerSchema),\n  async (c) => {\n    const { email, password, name } = c.req.valid('json')\n    \n    // Check if user already exists\n    const existingUser = await userRepository.findByEmail(email)\n    if (existingUser) {\n      throw new HTTPException(400, { message: 'User already exists' })\n    }\n    \n    // Hash password and create user\n    const passwordHash = await hashPassword(password)\n    const user = await userRepository.create({\n      email,\n      name,\n      passwordHash\n    })\n    \n    // Generate tokens\n    const { accessToken, refreshToken } = await generateTokens(user)\n    \n    return c.json({\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        role: user.role\n      },\n      accessToken,\n      refreshToken\n    }, 201)\n  }\n)\n\n// Login\nauth.post('/login',\n  zValidator('json', loginSchema),\n  async (c) => {\n    const { email, password } = c.req.valid('json')\n    \n    // Find user\n    const user = await userRepository.findByEmail(email)\n    if (!user) {\n      throw new HTTPException(401, { message: 'Invalid credentials' })\n    }\n    \n    // Verify password\n    const isValidPassword = await verifyPassword(password, user.passwordHash)\n    if (!isValidPassword) {\n      throw new HTTPException(401, { message: 'Invalid credentials' })\n    }\n    \n    // Generate tokens\n    const { accessToken, refreshToken } = await generateTokens(user)\n    \n    return c.json({\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        role: user.role\n      },\n      accessToken,\n      refreshToken\n    })\n  }\n)\n\n// Refresh token\nauth.post('/refresh',\n  zValidator('json', refreshTokenSchema),\n  async (c) => {\n    const { refreshToken } = c.req.valid('json')\n    \n    try {\n      const payload = await verifyRefreshToken(refreshToken)\n      \n      // Get current user data\n      const user = await userRepository.findById(payload.sub)\n      if (!user) {\n        throw new HTTPException(401, { message: 'User not found' })\n      }\n      \n      // Generate new tokens\n      const tokens = await generateTokens(user)\n      \n      return c.json(tokens)\n    } catch (error) {\n      throw new HTTPException(401, { message: 'Invalid refresh token' })\n    }\n  }\n)\n\n// Get current user\nauth.get('/me', authMiddleware, async (c) => {\n  const user = c.get('user')\n  \n  return c.json({\n    user: {\n      id: user.id,\n      email: user.email,\n      name: user.name,\n      role: user.role,\n      emailVerified: user.emailVerified,\n      createdAt: user.createdAt\n    }\n  })\n})\n\n// Update profile\nauth.put('/me',\n  authMiddleware,\n  zValidator('json', z.object({\n    name: z.string().min(1).max(100).optional(),\n    email: z.string().email().optional()\n  })),\n  async (c) => {\n    const userId = c.get('userId')\n    const updates = c.req.valid('json')\n    \n    // Check if email is already taken\n    if (updates.email) {\n      const existingUser = await userRepository.findByEmail(updates.email)\n      if (existingUser && existingUser.id !== userId) {\n        throw new HTTPException(400, { message: 'Email already taken' })\n      }\n    }\n    \n    const updatedUser = await userRepository.update(userId, updates)\n    if (!updatedUser) {\n      throw new HTTPException(404, { message: 'User not found' })\n    }\n    \n    return c.json({\n      user: {\n        id: updatedUser.id,\n        email: updatedUser.email,\n        name: updatedUser.name,\n        role: updatedUser.role\n      }\n    })\n  }\n)\n\n// Change password\nauth.put('/change-password',\n  authMiddleware,\n  zValidator('json', changePasswordSchema),\n  async (c) => {\n    const userId = c.get('userId')\n    const { currentPassword, newPassword } = c.req.valid('json')\n    \n    const user = await userRepository.findById(userId)\n    if (!user) {\n      throw new HTTPException(404, { message: 'User not found' })\n    }\n    \n    // Verify current password\n    const isValidPassword = await verifyPassword(currentPassword, user.passwordHash)\n    if (!isValidPassword) {\n      throw new HTTPException(400, { message: 'Current password is incorrect' })\n    }\n    \n    // Hash and update new password\n    const passwordHash = await hashPassword(newPassword)\n    await userRepository.update(userId, { passwordHash })\n    \n    return c.json({ message: 'Password updated successfully' })\n  }\n)\n\n// Logout (when using token blacklisting)\nauth.post('/logout', authMiddleware, async (c) => {\n  // In a real implementation, you would blacklist the token\n  // or remove it from a whitelist/session store\n  \n  return c.json({ message: 'Logged out successfully' })\n})\n\nexport default auth\n```\n\n### Session-Based Authentication\n\n```typescript\n// src/lib/session.ts\ninterface Session {\n  id: string\n  userId: string\n  expiresAt: Date\n  createdAt: Date\n}\n\n// In-memory session store (use Redis in production)\nconst sessions = new Map<string, Session>()\n\nexport async function createSession(userId: string): Promise<string> {\n  const sessionId = crypto.randomUUID()\n  const session: Session = {\n    id: sessionId,\n    userId,\n    expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours\n    createdAt: new Date()\n  }\n  \n  sessions.set(sessionId, session)\n  return sessionId\n}\n\nexport async function getSession(sessionId: string): Promise<Session | null> {\n  const session = sessions.get(sessionId)\n  \n  if (!session) return null\n  \n  if (session.expiresAt < new Date()) {\n    sessions.delete(sessionId)\n    return null\n  }\n  \n  return session\n}\n\nexport async function deleteSession(sessionId: string): Promise<void> {\n  sessions.delete(sessionId)\n}\n\n// Session middleware\nexport const sessionMiddleware = async (c: Context, next: Next) => {\n  const sessionId = c.req.header('X-Session-ID') || \n                   c.req.cookie('sessionId')\n  \n  if (!sessionId) {\n    throw new HTTPException(401, { message: 'No session provided' })\n  }\n  \n  const session = await getSession(sessionId)\n  if (!session) {\n    throw new HTTPException(401, { message: 'Invalid or expired session' })\n  }\n  \n  const user = await userRepository.findById(session.userId)\n  if (!user) {\n    throw new HTTPException(401, { message: 'User not found' })\n  }\n  \n  c.set('sessionId', sessionId)\n  c.set('userId', user.id)\n  c.set('user', user)\n  \n  await next()\n}\n```\n\n### OAuth Integration\n\n```typescript\n// src/lib/oauth.ts\nimport { Hono } from 'hono'\n\nconst oauth = new Hono()\n\n// Google OAuth\noauth.get('/google', async (c) => {\n  const clientId = process.env.GOOGLE_CLIENT_ID\n  const redirectUri = process.env.GOOGLE_REDIRECT_URI\n  const scope = 'openid email profile'\n  \n  const authUrl = new URL('https://accounts.google.com/o/oauth2/v2/auth')\n  authUrl.searchParams.set('client_id', clientId)\n  authUrl.searchParams.set('redirect_uri', redirectUri)\n  authUrl.searchParams.set('scope', scope)\n  authUrl.searchParams.set('response_type', 'code')\n  authUrl.searchParams.set('state', crypto.randomUUID())\n  \n  return c.redirect(authUrl.toString())\n})\n\noauth.get('/google/callback', async (c) => {\n  const code = c.req.query('code')\n  const state = c.req.query('state')\n  \n  if (!code) {\n    throw new HTTPException(400, { message: 'Authorization code missing' })\n  }\n  \n  try {\n    // Exchange code for tokens\n    const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n      body: new URLSearchParams({\n        client_id: process.env.GOOGLE_CLIENT_ID!,\n        client_secret: process.env.GOOGLE_CLIENT_SECRET!,\n        code,\n        grant_type: 'authorization_code',\n        redirect_uri: process.env.GOOGLE_REDIRECT_URI!\n      })\n    })\n    \n    const tokens = await tokenResponse.json()\n    \n    // Get user info\n    const userResponse = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {\n      headers: { Authorization: `Bearer ${tokens.access_token}` }\n    })\n    \n    const googleUser = await userResponse.json()\n    \n    // Find or create user\n    let user = await userRepository.findByEmail(googleUser.email)\n    \n    if (!user) {\n      user = await userRepository.create({\n        email: googleUser.email,\n        name: googleUser.name,\n        passwordHash: '', // OAuth users don't have passwords\n        emailVerified: true\n      })\n    }\n    \n    // Generate JWT tokens\n    const { accessToken, refreshToken } = await generateTokens(user)\n    \n    return c.json({\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        role: user.role\n      },\n      accessToken,\n      refreshToken\n    })\n    \n  } catch (error) {\n    throw new HTTPException(500, { message: 'OAuth authentication failed' })\n  }\n})\n\nexport default oauth\n```\n\n### Multi-Factor Authentication\n\n```typescript\n// src/lib/mfa.ts\nimport { authenticator } from 'otplib'\nimport QRCode from 'qrcode'\n\nexport async function generateMFASecret(email: string): Promise<{\n  secret: string\n  qrCodeUrl: string\n}> {\n  const secret = authenticator.generateSecret()\n  const service = 'Your App Name'\n  \n  const otpauth = authenticator.keyuri(email, service, secret)\n  const qrCodeUrl = await QRCode.toDataURL(otpauth)\n  \n  return { secret, qrCodeUrl }\n}\n\nexport function verifyMFAToken(token: string, secret: string): boolean {\n  return authenticator.verify({ token, secret })\n}\n\n// MFA routes\nauth.post('/mfa/setup',\n  authMiddleware,\n  async (c) => {\n    const user = c.get('user')\n    \n    if (user.mfaEnabled) {\n      throw new HTTPException(400, { message: 'MFA already enabled' })\n    }\n    \n    const { secret, qrCodeUrl } = await generateMFASecret(user.email)\n    \n    // Store secret temporarily (should be confirmed before enabling)\n    await userRepository.update(user.id, { mfaSecret: secret })\n    \n    return c.json({ qrCodeUrl, secret })\n  }\n)\n\nauth.post('/mfa/verify',\n  authMiddleware,\n  zValidator('json', z.object({ token: z.string().length(6) })),\n  async (c) => {\n    const { token } = c.req.valid('json')\n    const user = c.get('user')\n    \n    if (!user.mfaSecret) {\n      throw new HTTPException(400, { message: 'MFA not set up' })\n    }\n    \n    const isValid = verifyMFAToken(token, user.mfaSecret)\n    \n    if (!isValid) {\n      throw new HTTPException(400, { message: 'Invalid MFA token' })\n    }\n    \n    // Enable MFA\n    await userRepository.update(user.id, { mfaEnabled: true })\n    \n    return c.json({ message: 'MFA enabled successfully' })\n  }\n)\n```\n\n### Sources\n\n- [JWT Documentation](https://hono.dev/docs/middleware/builtin/jwt)\n- [Basic Auth](https://hono.dev/docs/middleware/builtin/basic-auth)\n- [Bearer Auth](https://hono.dev/docs/middleware/builtin/bearer-auth)\n- [OAuth 2.0 Specification](https://oauth.net/2/)"
    },
    {
      "parent": "honojs",
      "id": "context",
      "name": "Context",
      "description": "Context handling and custom variables",
      "type": "rule",
      "content": "## Context\n\n### Rules\n\n- Context variables MUST be typed using TypeScript generics\n- Context variables SHOULD be set in middleware before being used in handlers\n- Context variable names MUST be descriptive and consistent\n- Context variables MUST NOT contain sensitive information that could leak\n- Context cleanup SHOULD be handled appropriately for long-running requests\n- Context variables SHOULD be documented for team understanding\n- Context inheritance MUST be properly managed in nested applications\n\n### Basic Context Usage\n\n```typescript\n// src/types/context.ts\nexport type Variables = {\n  userId: string\n  user: User\n  requestId: string\n  startTime: number\n  db: Database\n  logger: Logger\n  ipAddress: string\n  userAgent: string\n}\n\nexport type Bindings = {\n  DATABASE_URL: string\n  JWT_SECRET: string\n  REDIS_URL: string\n  API_KEY: string\n}\n\n// src/app.ts\nimport { Hono } from 'hono'\nimport type { Variables, Bindings } from './types/context'\n\nconst app = new Hono<{\n  Variables: Variables\n  Bindings: Bindings\n}>()\n\n// Setting context variables in middleware\napp.use('*', async (c, next) => {\n  // Request tracking\n  c.set('requestId', crypto.randomUUID())\n  c.set('startTime', Date.now())\n  \n  // Extract client info\n  c.set('ipAddress', c.req.header('x-forwarded-for') || 'unknown')\n  c.set('userAgent', c.req.header('user-agent') || 'unknown')\n  \n  await next()\n})\n\n// Using context variables in handlers\napp.get('/profile', (c) => {\n  const userId = c.get('userId') // Fully typed\n  const user = c.get('user')     // Fully typed\n  const requestId = c.get('requestId')\n  \n  return c.json({\n    user,\n    meta: {\n      requestId,\n      timestamp: new Date().toISOString()\n    }\n  })\n})\n```\n\n### Request Lifecycle Context\n\n```typescript\n// src/middleware/request-context.ts\nimport { Context, Next } from 'hono'\nimport { randomUUID } from 'crypto'\n\nexport interface RequestContext {\n  id: string\n  startTime: number\n  endTime?: number\n  duration?: number\n  method: string\n  path: string\n  statusCode?: number\n  userAgent: string\n  ipAddress: string\n  userId?: string\n}\n\nexport const requestContextMiddleware = async (c: Context, next: Next) => {\n  const requestContext: RequestContext = {\n    id: randomUUID(),\n    startTime: Date.now(),\n    method: c.req.method,\n    path: c.req.path,\n    userAgent: c.req.header('user-agent') || 'unknown',\n    ipAddress: c.req.header('x-forwarded-for') || \n               c.req.header('x-real-ip') || \n               'unknown'\n  }\n  \n  c.set('requestContext', requestContext)\n  c.set('requestId', requestContext.id)\n  \n  // Add request ID to response headers\n  c.res.headers.set('X-Request-ID', requestContext.id)\n  \n  try {\n    await next()\n    \n    // Update context after request\n    requestContext.endTime = Date.now()\n    requestContext.duration = requestContext.endTime - requestContext.startTime\n    requestContext.statusCode = c.res.status\n    \n  } catch (error) {\n    requestContext.endTime = Date.now()\n    requestContext.duration = requestContext.endTime - requestContext.startTime\n    requestContext.statusCode = error instanceof HTTPException ? error.status : 500\n    \n    throw error\n  }\n}\n```\n\n### Database Context\n\n```typescript\n// src/middleware/database-context.ts\nimport { Context, Next } from 'hono'\nimport { Pool } from 'pg'\nimport { createDatabase } from '../lib/database'\n\nexport const databaseContextMiddleware = async (c: Context, next: Next) => {\n  const db = createDatabase(c.env.DATABASE_URL)\n  c.set('db', db)\n  \n  try {\n    await next()\n  } finally {\n    // Cleanup database connections\n    await db.close()\n  }\n}\n\n// Usage in handlers\napp.get('/users', async (c) => {\n  const db = c.get('db')\n  const users = await db.query('SELECT * FROM users')\n  return c.json({ users })\n})\n```\n\n### User Context with Caching\n\n```typescript\n// src/middleware/user-context.ts\nimport { Context, Next } from 'hono'\nimport { verifyAccessToken } from '../lib/auth'\nimport { getUserById } from '../lib/user'\n\nconst userCache = new Map<string, { user: User; expires: number }>()\nconst CACHE_TTL = 5 * 60 * 1000 // 5 minutes\n\nexport const userContextMiddleware = async (c: Context, next: Next) => {\n  const authHeader = c.req.header('Authorization')\n  \n  if (authHeader && authHeader.startsWith('Bearer ')) {\n    const token = authHeader.substring(7)\n    \n    try {\n      const payload = await verifyAccessToken(token)\n      const userId = payload.sub\n      \n      // Check cache first\n      const cached = userCache.get(userId)\n      if (cached && cached.expires > Date.now()) {\n        c.set('userId', userId)\n        c.set('user', cached.user)\n        c.set('userRole', cached.user.role)\n      } else {\n        // Fetch from database\n        const user = await getUserById(userId)\n        if (user) {\n          // Cache the user\n          userCache.set(userId, {\n            user,\n            expires: Date.now() + CACHE_TTL\n          })\n          \n          c.set('userId', userId)\n          c.set('user', user)\n          c.set('userRole', user.role)\n        }\n      }\n    } catch (error) {\n      // Invalid token - continue without user context\n    }\n  }\n  \n  await next()\n}\n\n// Clear cache entry when user is updated\nexport function invalidateUserCache(userId: string) {\n  userCache.delete(userId)\n}\n```\n\n### Feature Flags Context\n\n```typescript\n// src/middleware/feature-flags.ts\nimport { Context, Next } from 'hono'\n\ninterface FeatureFlags {\n  newUI: boolean\n  betaFeatures: boolean\n  advancedAnalytics: boolean\n  experimentalAPI: boolean\n}\n\nexport const featureFlagsMiddleware = async (c: Context, next: Next) => {\n  const userId = c.get('userId')\n  const userRole = c.get('userRole')\n  \n  // Determine feature flags based on user\n  const flags: FeatureFlags = {\n    newUI: await isFeatureEnabled('newUI', userId, userRole),\n    betaFeatures: userRole === 'admin' || userRole === 'beta',\n    advancedAnalytics: userRole === 'admin',\n    experimentalAPI: process.env.NODE_ENV === 'development'\n  }\n  \n  c.set('featureFlags', flags)\n  await next()\n}\n\nasync function isFeatureEnabled(\n  feature: string, \n  userId?: string, \n  userRole?: string\n): Promise<boolean> {\n  // Check external feature flag service\n  // For now, return simple logic\n  if (userRole === 'admin') return true\n  if (feature === 'newUI' && Math.random() > 0.5) return true\n  return false\n}\n\n// Usage in handlers\napp.get('/dashboard', (c) => {\n  const flags = c.get('featureFlags')\n  \n  return c.json({\n    dashboard: {\n      useNewUI: flags.newUI,\n      showBetaFeatures: flags.betaFeatures,\n      showAnalytics: flags.advancedAnalytics\n    }\n  })\n})\n```\n\n### Logging Context\n\n```typescript\n// src/middleware/logging-context.ts\nimport { Context, Next } from 'hono'\n\nexport interface Logger {\n  info: (message: string, meta?: any) => void\n  warn: (message: string, meta?: any) => void\n  error: (message: string, meta?: any) => void\n  debug: (message: string, meta?: any) => void\n}\n\nexport const loggingContextMiddleware = async (c: Context, next: Next) => {\n  const requestId = c.get('requestId')\n  const userId = c.get('userId')\n  \n  const logger: Logger = {\n    info: (message, meta = {}) => {\n      console.log(JSON.stringify({\n        level: 'info',\n        message,\n        requestId,\n        userId,\n        timestamp: new Date().toISOString(),\n        ...meta\n      }))\n    },\n    \n    warn: (message, meta = {}) => {\n      console.warn(JSON.stringify({\n        level: 'warn',\n        message,\n        requestId,\n        userId,\n        timestamp: new Date().toISOString(),\n        ...meta\n      }))\n    },\n    \n    error: (message, meta = {}) => {\n      console.error(JSON.stringify({\n        level: 'error',\n        message,\n        requestId,\n        userId,\n        timestamp: new Date().toISOString(),\n        ...meta\n      }))\n    },\n    \n    debug: (message, meta = {}) => {\n      if (process.env.LOG_LEVEL === 'debug') {\n        console.debug(JSON.stringify({\n          level: 'debug',\n          message,\n          requestId,\n          userId,\n          timestamp: new Date().toISOString(),\n          ...meta\n        }))\n      }\n    }\n  }\n  \n  c.set('logger', logger)\n  await next()\n}\n\n// Usage in handlers\napp.post('/users', async (c) => {\n  const logger = c.get('logger')\n  const userData = await c.req.json()\n  \n  logger.info('Creating new user', { email: userData.email })\n  \n  try {\n    const user = await createUser(userData)\n    logger.info('User created successfully', { userId: user.id })\n    return c.json({ user }, 201)\n  } catch (error) {\n    logger.error('Failed to create user', { error: error.message })\n    throw error\n  }\n})\n```\n\n### Multi-Tenant Context\n\n```typescript\n// src/middleware/tenant-context.ts\nimport { Context, Next } from 'hono'\nimport { HTTPException } from 'hono/http-exception'\n\ninterface Tenant {\n  id: string\n  name: string\n  subdomain: string\n  settings: {\n    features: string[]\n    limits: {\n      users: number\n      storage: number\n    }\n  }\n}\n\nexport const tenantContextMiddleware = async (c: Context, next: Next) => {\n  // Extract tenant from subdomain or header\n  const host = c.req.header('host') || ''\n  const tenantHeader = c.req.header('x-tenant-id')\n  \n  let tenantId: string | null = null\n  \n  if (tenantHeader) {\n    tenantId = tenantHeader\n  } else {\n    // Extract from subdomain (e.g., tenant1.myapp.com)\n    const subdomain = host.split('.')[0]\n    if (subdomain && subdomain !== 'www' && subdomain !== 'api') {\n      tenantId = subdomain\n    }\n  }\n  \n  if (!tenantId) {\n    throw new HTTPException(400, { message: 'Tenant not specified' })\n  }\n  \n  // Load tenant configuration\n  const tenant = await getTenantById(tenantId)\n  if (!tenant) {\n    throw new HTTPException(404, { message: 'Tenant not found' })\n  }\n  \n  c.set('tenant', tenant)\n  c.set('tenantId', tenant.id)\n  \n  await next()\n}\n\nasync function getTenantById(id: string): Promise<Tenant | null> {\n  // Implementation to fetch tenant from database\n  // This is a mock implementation\n  return {\n    id,\n    name: `Tenant ${id}`,\n    subdomain: id,\n    settings: {\n      features: ['basic', 'advanced'],\n      limits: {\n        users: 100,\n        storage: 1024 * 1024 * 1024 // 1GB\n      }\n    }\n  }\n}\n\n// Usage with tenant isolation\napp.get('/users', async (c) => {\n  const tenant = c.get('tenant')\n  const db = c.get('db')\n  \n  // Query users for specific tenant\n  const users = await db.query(\n    'SELECT * FROM users WHERE tenant_id = $1',\n    [tenant.id]\n  )\n  \n  return c.json({ users })\n})\n```\n\n### Context Composition\n\n```typescript\n// src/middleware/context-composer.ts\nimport { Context, Next } from 'hono'\nimport { requestContextMiddleware } from './request-context'\nimport { userContextMiddleware } from './user-context'\nimport { loggingContextMiddleware } from './logging-context'\nimport { featureFlagsMiddleware } from './feature-flags'\n\n// Compose multiple context middleware\nexport const contextMiddleware = async (c: Context, next: Next) => {\n  // Chain multiple context middleware\n  await requestContextMiddleware(c, async () => {\n    await userContextMiddleware(c, async () => {\n      await loggingContextMiddleware(c, async () => {\n        await featureFlagsMiddleware(c, next)\n      })\n    })\n  })\n}\n\n// Alternative using a middleware chain helper\nexport function composeMiddleware(...middlewares: Array<(c: Context, next: Next) => Promise<void>>) {\n  return async (c: Context, next: Next) => {\n    let index = 0\n    \n    async function dispatch(i: number): Promise<void> {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      \n      let fn = middlewares[i]\n      if (i === middlewares.length) fn = next as any\n      if (!fn) return\n      \n      try {\n        await fn(c, () => dispatch(i + 1))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n    \n    return dispatch(0)\n  }\n}\n\n// Usage\nconst composedContext = composeMiddleware(\n  requestContextMiddleware,\n  userContextMiddleware,\n  loggingContextMiddleware,\n  featureFlagsMiddleware\n)\n\napp.use('*', composedContext)\n```\n\n### Context Testing\n\n```typescript\n// tests/context.test.ts\nimport { describe, it, expect, beforeEach } from 'vitest'\nimport { Hono } from 'hono'\nimport { testClient } from 'hono/testing'\nimport { requestContextMiddleware } from '../src/middleware/request-context'\n\ndescribe('Request Context', () => {\n  let app: Hono\n  \n  beforeEach(() => {\n    app = new Hono()\n    app.use('*', requestContextMiddleware)\n  })\n  \n  it('should set request context variables', async () => {\n    app.get('/test', (c) => {\n      const requestId = c.get('requestId')\n      const requestContext = c.get('requestContext')\n      \n      return c.json({\n        requestId,\n        method: requestContext.method,\n        path: requestContext.path\n      })\n    })\n    \n    const res = await app.request('/test', {\n      method: 'GET',\n      headers: { 'User-Agent': 'test-agent' }\n    })\n    \n    expect(res.status).toBe(200)\n    \n    const data = await res.json()\n    expect(data.requestId).toBeDefined()\n    expect(data.method).toBe('GET')\n    expect(data.path).toBe('/test')\n  })\n  \n  it('should add request ID to response headers', async () => {\n    app.get('/test', (c) => c.json({ success: true }))\n    \n    const res = await app.request('/test')\n    \n    expect(res.headers.get('X-Request-ID')).toBeDefined()\n  })\n})\n```\n\n### Sources\n\n- [Context Documentation](https://hono.dev/docs/api/context)\n- [Variables](https://hono.dev/docs/api/context#var)\n- [Environment Variables](https://hono.dev/docs/api/context#env)"
    },
    {
      "parent": "honojs",
      "id": "database",
      "name": "Database Integration",
      "description": "Database connection and ORM patterns",
      "type": "rule",
      "content": "## Database Integration\n\n### Rules\n\n- Database connections MUST be properly pooled and managed\n- SQL injection MUST be prevented using parameterized queries\n- Database operations MUST be wrapped in try-catch blocks\n- Transactions MUST be used for multi-step operations\n- Database schemas MUST be versioned with migrations\n- Connection timeouts MUST be configured appropriately\n- Database credentials MUST be stored in environment variables\n- Query performance MUST be monitored in production\n- Database connection health checks MUST be implemented\n\n### PostgreSQL with node-postgres\n\n```typescript\n// src/lib/db.ts\nimport { Pool, PoolClient } from 'pg'\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000,\n  statement_timeout: 30000,\n  query_timeout: 30000,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false\n})\n\n// Health check\nexport async function checkDatabaseHealth(): Promise<boolean> {\n  try {\n    const client = await pool.connect()\n    await client.query('SELECT 1')\n    client.release()\n    return true\n  } catch (error) {\n    console.error('Database health check failed:', error)\n    return false\n  }\n}\n\n// Generic query function\nexport async function query<T = any>(\n  text: string,\n  params?: any[]\n): Promise<T[]> {\n  try {\n    const result = await pool.query(text, params)\n    return result.rows\n  } catch (error) {\n    console.error('Database query error:', error)\n    throw new Error('Database operation failed')\n  }\n}\n\n// Transaction wrapper\nexport async function withTransaction<T>(\n  callback: (client: PoolClient) => Promise<T>\n): Promise<T> {\n  const client = await pool.connect()\n  \n  try {\n    await client.query('BEGIN')\n    const result = await callback(client)\n    await client.query('COMMIT')\n    return result\n  } catch (error) {\n    await client.query('ROLLBACK')\n    throw error\n  } finally {\n    client.release()\n  }\n}\n\n// User repository\nexport const userRepository = {\n  async findAll(): Promise<User[]> {\n    return query<User>('SELECT * FROM users ORDER BY created_at DESC')\n  },\n\n  async findById(id: string): Promise<User | null> {\n    const users = await query<User>('SELECT * FROM users WHERE id = $1', [id])\n    return users[0] || null\n  },\n\n  async findByEmail(email: string): Promise<User | null> {\n    const users = await query<User>(\n      'SELECT * FROM users WHERE email = $1',\n      [email]\n    )\n    return users[0] || null\n  },\n\n  async create(userData: CreateUserData): Promise<User> {\n    const users = await query<User>(\n      `INSERT INTO users (id, email, name, password_hash) \n       VALUES ($1, $2, $3, $4) \n       RETURNING *`,\n      [crypto.randomUUID(), userData.email, userData.name, userData.passwordHash]\n    )\n    return users[0]\n  },\n\n  async update(id: string, updates: Partial<UpdateUserData>): Promise<User | null> {\n    const fields = Object.keys(updates)\n    const values = Object.values(updates)\n    \n    if (fields.length === 0) {\n      return this.findById(id)\n    }\n    \n    const setClause = fields\n      .map((field, index) => `${field} = $${index + 2}`)\n      .join(', ')\n    \n    const users = await query<User>(\n      `UPDATE users SET ${setClause}, updated_at = NOW() \n       WHERE id = $1 \n       RETURNING *`,\n      [id, ...values]\n    )\n    \n    return users[0] || null\n  },\n\n  async delete(id: string): Promise<boolean> {\n    const result = await pool.query('DELETE FROM users WHERE id = $1', [id])\n    return result.rowCount > 0\n  }\n}\n```\n\n### Drizzle ORM Integration\n\n```typescript\n// src/lib/drizzle.ts\nimport { drizzle } from 'drizzle-orm/postgres-js'\nimport { migrate } from 'drizzle-orm/postgres-js/migrator'\nimport postgres from 'postgres'\nimport * as schema from './schema'\n\n// Database connection\nconst connectionString = process.env.DATABASE_URL!\nconst sql = postgres(connectionString, { max: 1 })\nexport const db = drizzle(sql, { schema })\n\n// Run migrations\nexport async function runMigrations() {\n  await migrate(db, { migrationsFolder: './drizzle' })\n  await sql.end()\n}\n\n// src/lib/schema.ts\nimport {\n  pgTable,\n  uuid,\n  varchar,\n  text,\n  boolean,\n  timestamp,\n  index,\n  unique\n} from 'drizzle-orm/pg-core'\nimport { relations } from 'drizzle-orm'\n\nexport const users = pgTable('users', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  email: varchar('email', { length: 255 }).notNull(),\n  name: varchar('name', { length: 255 }).notNull(),\n  passwordHash: text('password_hash').notNull(),\n  emailVerified: boolean('email_verified').default(false),\n  role: varchar('role', { length: 50 }).default('user'),\n  createdAt: timestamp('created_at').defaultNow(),\n  updatedAt: timestamp('updated_at').defaultNow(),\n}, (table) => ({\n  emailIdx: unique().on(table.email),\n  nameIdx: index().on(table.name),\n}))\n\nexport const posts = pgTable('posts', {\n  id: uuid('id').primaryKey().defaultRandom(),\n  title: varchar('title', { length: 255 }).notNull(),\n  content: text('content').notNull(),\n  published: boolean('published').default(false),\n  authorId: uuid('author_id').references(() => users.id),\n  createdAt: timestamp('created_at').defaultNow(),\n  updatedAt: timestamp('updated_at').defaultNow(),\n}, (table) => ({\n  authorIdx: index().on(table.authorId),\n  publishedIdx: index().on(table.published),\n}))\n\n// Relations\nexport const usersRelations = relations(users, ({ many }) => ({\n  posts: many(posts),\n}))\n\nexport const postsRelations = relations(posts, ({ one }) => ({\n  author: one(users, {\n    fields: [posts.authorId],\n    references: [users.id],\n  }),\n}))\n\n// Types\nexport type User = typeof users.$inferSelect\nexport type NewUser = typeof users.$inferInsert\nexport type Post = typeof posts.$inferSelect\nexport type NewPost = typeof posts.$inferInsert\n\n// Repository using Drizzle\nimport { eq, desc, and, ilike } from 'drizzle-orm'\n\nexport const drizzleUserRepository = {\n  async findAll() {\n    return db.select().from(users).orderBy(desc(users.createdAt))\n  },\n\n  async findById(id: string) {\n    const result = await db.select().from(users).where(eq(users.id, id))\n    return result[0] || null\n  },\n\n  async findByEmail(email: string) {\n    const result = await db.select().from(users).where(eq(users.email, email))\n    return result[0] || null\n  },\n\n  async create(userData: NewUser) {\n    const result = await db.insert(users).values(userData).returning()\n    return result[0]\n  },\n\n  async update(id: string, updates: Partial<NewUser>) {\n    const result = await db\n      .update(users)\n      .set({ ...updates, updatedAt: new Date() })\n      .where(eq(users.id, id))\n      .returning()\n    return result[0] || null\n  },\n\n  async delete(id: string) {\n    const result = await db.delete(users).where(eq(users.id, id))\n    return result.rowCount > 0\n  },\n\n  async findUsersWithPosts() {\n    return db.select().from(users).with(\n      db.select().from(posts).where(eq(posts.authorId, users.id))\n    )\n  }\n}\n```\n\n### Prisma Integration\n\n```typescript\n// src/lib/prisma.ts\nimport { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n\n// Graceful shutdown\nprocess.on('beforeExit', async () => {\n  await prisma.$disconnect()\n})\n\n// Repository pattern with Prisma\nexport const prismaUserRepository = {\n  async findAll() {\n    return prisma.user.findMany({\n      orderBy: { createdAt: 'desc' },\n      include: { posts: true }\n    })\n  },\n\n  async findById(id: string) {\n    return prisma.user.findUnique({\n      where: { id },\n      include: { posts: true }\n    })\n  },\n\n  async findByEmail(email: string) {\n    return prisma.user.findUnique({\n      where: { email }\n    })\n  },\n\n  async create(data: { email: string; name: string; passwordHash: string }) {\n    return prisma.user.create({\n      data,\n      include: { posts: true }\n    })\n  },\n\n  async update(id: string, data: { name?: string; email?: string }) {\n    return prisma.user.update({\n      where: { id },\n      data,\n      include: { posts: true }\n    })\n  },\n\n  async delete(id: string) {\n    await prisma.user.delete({\n      where: { id }\n    })\n    return true\n  },\n\n  async createWithPosts(userData: any, postsData: any[]) {\n    return prisma.user.create({\n      data: {\n        ...userData,\n        posts: {\n          create: postsData\n        }\n      },\n      include: { posts: true }\n    })\n  }\n}\n\n// schema.prisma\n/*\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id           String   @id @default(cuid())\n  email        String   @unique\n  name         String\n  passwordHash String   @map(\"password_hash\")\n  emailVerified Boolean @default(false) @map(\"email_verified\")\n  role         String   @default(\"user\")\n  createdAt    DateTime @default(now()) @map(\"created_at\")\n  updatedAt    DateTime @updatedAt @map(\"updated_at\")\n  \n  posts Post[]\n  \n  @@map(\"users\")\n}\n\nmodel Post {\n  id        String   @id @default(cuid())\n  title     String\n  content   String\n  published Boolean  @default(false)\n  authorId  String   @map(\"author_id\")\n  createdAt DateTime @default(now()) @map(\"created_at\")\n  updatedAt DateTime @updatedAt @map(\"updated_at\")\n  \n  author User @relation(fields: [authorId], references: [id])\n  \n  @@map(\"posts\")\n}\n*/\n```\n\n### SQLite with Better-SQLite3\n\n```typescript\n// src/lib/sqlite.ts\nimport Database from 'better-sqlite3'\nimport { join } from 'path'\n\nconst dbPath = process.env.DATABASE_PATH || join(process.cwd(), 'database.sqlite')\nexport const db = new Database(dbPath)\n\n// Enable WAL mode for better performance\ndb.pragma('journal_mode = WAL')\ndb.pragma('synchronous = NORMAL')\ndb.pragma('cache_size = 1000000')\ndb.pragma('temp_store = memory')\n\n// Initialize schema\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS users (\n    id TEXT PRIMARY KEY,\n    email TEXT UNIQUE NOT NULL,\n    name TEXT NOT NULL,\n    password_hash TEXT NOT NULL,\n    email_verified BOOLEAN DEFAULT FALSE,\n    role TEXT DEFAULT 'user',\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n  );\n\n  CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);\n  CREATE INDEX IF NOT EXISTS idx_users_role ON users(role);\n`)\n\n// Prepared statements for better performance\nconst statements = {\n  findAllUsers: db.prepare('SELECT * FROM users ORDER BY created_at DESC'),\n  findUserById: db.prepare('SELECT * FROM users WHERE id = ?'),\n  findUserByEmail: db.prepare('SELECT * FROM users WHERE email = ?'),\n  createUser: db.prepare(`\n    INSERT INTO users (id, email, name, password_hash)\n    VALUES (?, ?, ?, ?)\n  `),\n  updateUser: db.prepare(`\n    UPDATE users \n    SET email = ?, name = ?, updated_at = CURRENT_TIMESTAMP\n    WHERE id = ?\n  `),\n  deleteUser: db.prepare('DELETE FROM users WHERE id = ?'),\n}\n\nexport const sqliteUserRepository = {\n  findAll() {\n    return statements.findAllUsers.all()\n  },\n\n  findById(id: string) {\n    return statements.findUserById.get(id) || null\n  },\n\n  findByEmail(email: string) {\n    return statements.findUserByEmail.get(email) || null\n  },\n\n  create(userData: { email: string; name: string; passwordHash: string }) {\n    const id = crypto.randomUUID()\n    statements.createUser.run(id, userData.email, userData.name, userData.passwordHash)\n    return this.findById(id)\n  },\n\n  update(id: string, updates: { email?: string; name?: string }) {\n    const user = this.findById(id)\n    if (!user) return null\n    \n    statements.updateUser.run(\n      updates.email || user.email,\n      updates.name || user.name,\n      id\n    )\n    return this.findById(id)\n  },\n\n  delete(id: string) {\n    const result = statements.deleteUser.run(id)\n    return result.changes > 0\n  }\n}\n\n// Graceful shutdown\nprocess.on('exit', () => db.close())\nprocess.on('SIGHUP', () => process.exit(128 + 1))\nprocess.on('SIGINT', () => process.exit(128 + 2))\nprocess.on('SIGTERM', () => process.exit(128 + 15))\n```\n\n### Database Middleware\n\n```typescript\n// src/middleware/database.ts\nimport { Context, Next } from 'hono'\nimport { db } from '../lib/db'\n\n// Add database to context\nexport const databaseMiddleware = async (c: Context, next: Next) => {\n  c.set('db', db)\n  await next()\n}\n\n// Transaction middleware\nexport const transactionMiddleware = async (c: Context, next: Next) => {\n  const transaction = await db.transaction()\n  c.set('transaction', transaction)\n  \n  try {\n    await next()\n    await transaction.commit()\n  } catch (error) {\n    await transaction.rollback()\n    throw error\n  }\n}\n\n// Usage in routes\napp.use('*', databaseMiddleware)\n\napp.post('/users', transactionMiddleware, async (c) => {\n  const transaction = c.get('transaction')\n  const userData = await c.req.json()\n  \n  // Create user within transaction\n  const user = await transaction.user.create({ data: userData })\n  \n  return c.json({ user }, 201)\n})\n```\n\n### Connection Pooling for Cloudflare D1\n\n```typescript\n// src/lib/d1.ts\nexport const d1UserRepository = {\n  async findAll(env: { DB: D1Database }) {\n    const { results } = await env.DB.prepare(\n      'SELECT * FROM users ORDER BY created_at DESC'\n    ).all()\n    return results\n  },\n\n  async findById(env: { DB: D1Database }, id: string) {\n    const result = await env.DB.prepare(\n      'SELECT * FROM users WHERE id = ?'\n    ).bind(id).first()\n    return result || null\n  },\n\n  async create(env: { DB: D1Database }, userData: any) {\n    const id = crypto.randomUUID()\n    \n    await env.DB.prepare(`\n      INSERT INTO users (id, email, name, password_hash)\n      VALUES (?, ?, ?, ?)\n    `).bind(id, userData.email, userData.name, userData.passwordHash).run()\n    \n    return this.findById(env, id)\n  },\n\n  async update(env: { DB: D1Database }, id: string, updates: any) {\n    await env.DB.prepare(`\n      UPDATE users \n      SET email = ?, name = ?, updated_at = CURRENT_TIMESTAMP\n      WHERE id = ?\n    `).bind(updates.email, updates.name, id).run()\n    \n    return this.findById(env, id)\n  },\n\n  async delete(env: { DB: D1Database }, id: string) {\n    const result = await env.DB.prepare(\n      'DELETE FROM users WHERE id = ?'\n    ).bind(id).run()\n    \n    return result.changes > 0\n  }\n}\n\n// Usage in Cloudflare Workers\napp.get('/users', async (c) => {\n  const users = await d1UserRepository.findAll(c.env)\n  return c.json({ users })\n})\n```\n\n### Database Testing\n\n```typescript\n// tests/database.test.ts\nimport { describe, it, expect, beforeEach, afterEach } from 'vitest'\nimport { userRepository } from '../src/lib/db'\n\ndescribe('User Repository', () => {\n  beforeEach(async () => {\n    // Setup test database\n    await setupTestDatabase()\n  })\n\n  afterEach(async () => {\n    // Cleanup test database\n    await cleanupTestDatabase()\n  })\n\n  it('should create a user', async () => {\n    const userData = {\n      email: 'test@example.com',\n      name: 'Test User',\n      passwordHash: 'hashed-password'\n    }\n\n    const user = await userRepository.create(userData)\n\n    expect(user).toBeDefined()\n    expect(user.email).toBe(userData.email)\n    expect(user.name).toBe(userData.name)\n    expect(user.id).toBeDefined()\n  })\n\n  it('should find user by email', async () => {\n    const userData = {\n      email: 'test@example.com',\n      name: 'Test User',\n      passwordHash: 'hashed-password'\n    }\n\n    await userRepository.create(userData)\n    const user = await userRepository.findByEmail(userData.email)\n\n    expect(user).toBeDefined()\n    expect(user.email).toBe(userData.email)\n  })\n\n  it('should update user', async () => {\n    const userData = {\n      email: 'test@example.com',\n      name: 'Test User',\n      passwordHash: 'hashed-password'\n    }\n\n    const user = await userRepository.create(userData)\n    const updated = await userRepository.update(user.id, { name: 'Updated Name' })\n\n    expect(updated.name).toBe('Updated Name')\n    expect(updated.email).toBe(userData.email)\n  })\n})\n```\n\n### Sources\n\n- [Drizzle ORM](https://orm.drizzle.team)\n- [Prisma](https://www.prisma.io)\n- [node-postgres](https://node-postgres.com)\n- [Cloudflare D1](https://developers.cloudflare.com/d1/)"
    },
    {
      "parent": "honojs",
      "id": "deployment",
      "name": "Deployment",
      "description": "Multi-runtime deployment strategies",
      "type": "rule",
      "content": "## Deployment\n\n### Rules\n\n- Environment-specific configurations MUST be managed through environment variables\n- Build artifacts MUST be optimized for the target runtime\n- Health check endpoints MUST be implemented\n- Graceful shutdown MUST be handled properly\n- Logging and monitoring MUST be configured for production\n- Secrets MUST NEVER be committed to version control\n- Different runtimes require different entry points\n- Performance optimizations MUST be runtime-specific\n- Cold start times SHOULD be minimized for serverless deployments\n\n### Node.js Deployment\n\n```typescript\n// src/node.ts\nimport { serve } from '@hono/node-server'\nimport { compress } from 'hono/compress'\nimport app from './app'\n\nconst port = parseInt(process.env.PORT || '3000', 10)\n\n// Add Node.js specific middleware\napp.use('*', compress())\n\nconst server = serve({\n  fetch: app.fetch,\n  port\n})\n\nconsole.log(`Server running on http://localhost:${port}`)\n\n// Graceful shutdown\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, closing server...')\n  server.close(() => {\n    console.log('Server closed')\n    process.exit(0)\n  })\n})\n\n// package.json scripts\n{\n  \"scripts\": {\n    \"start\": \"node dist/node.js\",\n    \"build\": \"tsc\",\n    \"dev\": \"tsx watch src/node.ts\"\n  }\n}\n\n// Dockerfile for Node.js\nFROM node:20-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\n\nFROM node:20-alpine\nWORKDIR /app\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY dist ./dist\nEXPOSE 3000\nUSER node\nCMD [\"node\", \"dist/node.js\"]\n```\n\n### Cloudflare Workers\n\n```typescript\n// src/cloudflare.ts\nimport app from './app'\n\nexport default {\n  fetch: app.fetch,\n  \n  // Scheduled handler (Cron Triggers)\n  scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {\n    ctx.waitUntil(handleScheduledEvent(event, env))\n  },\n  \n  // Queue handler\n  queue(batch: MessageBatch, env: Env, ctx: ExecutionContext) {\n    ctx.waitUntil(processQueue(batch, env))\n  }\n}\n\n// wrangler.toml\nname = \"my-hono-app\"\nmain = \"src/cloudflare.ts\"\ncompatibility_date = \"2024-01-01\"\nnode_compat = true\n\n[env.production]\nvars = { ENVIRONMENT = \"production\" }\nkv_namespaces = [\n  { binding = \"KV\", id = \"your-kv-id\" }\n]\ndurable_objects.bindings = [\n  { name = \"COUNTER\", class_name = \"Counter\" }\n]\nr2_buckets = [\n  { binding = \"BUCKET\", bucket_name = \"my-bucket\" }\n]\n\n[[env.production.routes]]\npattern = \"api.example.com/*\"\nzone_id = \"your-zone-id\"\n\n[env.production.limits]\ncpu_ms = 50\n\n// package.json scripts\n{\n  \"scripts\": {\n    \"deploy\": \"wrangler deploy\",\n    \"dev\": \"wrangler dev\",\n    \"tail\": \"wrangler tail\"\n  }\n}\n```\n\n### Vercel\n\n```typescript\n// api/index.ts (Vercel Functions)\nimport { handle } from 'hono/vercel'\nimport app from '../src/app'\n\nexport const config = {\n  runtime: 'edge', // or 'nodejs'\n  regions: ['iad1'], // Specify regions\n  maxDuration: 10 // Maximum execution time in seconds\n}\n\nexport default handle(app)\n\n// vercel.json\n{\n  \"functions\": {\n    \"api/index.ts\": {\n      \"runtime\": \"edge\",\n      \"maxDuration\": 10,\n      \"memory\": 1024,\n      \"regions\": [\"iad1\", \"sfo1\"]\n    }\n  },\n  \"rewrites\": [\n    {\n      \"source\": \"/(.*)\",\n      \"destination\": \"/api\"\n    }\n  ],\n  \"env\": {\n    \"NODE_ENV\": \"production\"\n  },\n  \"buildCommand\": \"npm run build\",\n  \"outputDirectory\": \"dist\"\n}\n\n// package.json scripts\n{\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"vercel\": \"vercel\",\n    \"vercel:prod\": \"vercel --prod\"\n  }\n}\n```\n\n### AWS Lambda\n\n```typescript\n// src/lambda.ts\nimport { handle } from 'hono/aws-lambda'\nimport app from './app'\n\nexport const handler = handle(app)\n\n// serverless.yml (Serverless Framework)\nservice: hono-lambda-app\nframeworkVersion: '3'\n\nprovider:\n  name: aws\n  runtime: nodejs20.x\n  region: us-east-1\n  memorySize: 512\n  timeout: 10\n  environment:\n    NODE_ENV: production\n    DATABASE_URL: ${env:DATABASE_URL}\n  iam:\n    role:\n      statements:\n        - Effect: Allow\n          Action:\n            - dynamodb:*\n          Resource: \"*\"\n\nfunctions:\n  api:\n    handler: dist/lambda.handler\n    events:\n      - httpApi:\n          path: /{proxy+}\n          method: ANY\n      - httpApi:\n          path: /\n          method: ANY\n    reservedConcurrency: 10\n    provisionedConcurrency: 2\n\nplugins:\n  - serverless-plugin-typescript\n  - serverless-offline\n\n// CDK deployment (alternative)\nimport * as cdk from 'aws-cdk-lib'\nimport * as lambda from 'aws-cdk-lib/aws-lambda'\nimport * as apigateway from 'aws-cdk-lib/aws-apigatewayv2'\n\nexport class HonoLambdaStack extends cdk.Stack {\n  constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props)\n    \n    const fn = new lambda.Function(this, 'HonoFunction', {\n      runtime: lambda.Runtime.NODEJS_20_X,\n      code: lambda.Code.fromAsset('dist'),\n      handler: 'lambda.handler',\n      memorySize: 512,\n      timeout: cdk.Duration.seconds(10),\n      environment: {\n        NODE_ENV: 'production'\n      }\n    })\n    \n    const api = new apigateway.HttpApi(this, 'HonoApi', {\n      defaultIntegration: new apigateway.HttpLambdaIntegration(\n        'HonoIntegration',\n        fn\n      )\n    })\n  }\n}\n```\n\n### Deno Deploy\n\n```typescript\n// src/deno.ts\nimport { Hono } from 'https://deno.land/x/hono/mod.ts'\nimport app from './app.ts'\n\nDeno.serve(app.fetch)\n\n// deno.json\n{\n  \"tasks\": {\n    \"dev\": \"deno run --allow-net --allow-env --watch src/deno.ts\",\n    \"start\": \"deno run --allow-net --allow-env src/deno.ts\",\n    \"deploy\": \"deployctl deploy --project=my-project src/deno.ts\"\n  },\n  \"imports\": {\n    \"hono\": \"https://deno.land/x/hono/mod.ts\",\n    \"@/\": \"./src/\"\n  },\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"hono/jsx\"\n  }\n}\n\n// GitHub Actions deployment\nname: Deploy to Deno Deploy\non:\n  push:\n    branches: [main]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: denoland/deployctl@v1\n        with:\n          project: my-project\n          entrypoint: src/deno.ts\n          root: .\n```\n\n### Bun Deployment\n\n```typescript\n// src/bun.ts\nimport app from './app'\n\nconst server = Bun.serve({\n  port: process.env.PORT || 3000,\n  fetch: app.fetch,\n  \n  // Bun-specific optimizations\n  maxRequestBodySize: 10 * 1024 * 1024, // 10MB\n  \n  // WebSocket support\n  websocket: {\n    open(ws) {\n      console.log('WebSocket opened')\n    },\n    message(ws, message) {\n      ws.send(message)\n    },\n    close(ws) {\n      console.log('WebSocket closed')\n    }\n  }\n})\n\nconsole.log(`Server running on ${server.url}`)\n\n// package.json scripts\n{\n  \"scripts\": {\n    \"start\": \"bun run src/bun.ts\",\n    \"dev\": \"bun --watch src/bun.ts\",\n    \"build\": \"bun build src/bun.ts --outdir dist --target bun\"\n  }\n}\n\n// Dockerfile for Bun\nFROM oven/bun:latest AS builder\nWORKDIR /app\nCOPY package.json bun.lockb ./\nRUN bun install --frozen-lockfile --production\n\nFROM oven/bun:latest\nWORKDIR /app\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY src ./src\nEXPOSE 3000\nUSER bun\nCMD [\"bun\", \"run\", \"src/bun.ts\"]\n```\n\n### Docker Deployment\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://user:pass@db:5432/mydb\n      - REDIS_URL=redis://redis:6379\n    depends_on:\n      - db\n      - redis\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n  \n  db:\n    image: postgres:15\n    environment:\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=pass\n      - POSTGRES_DB=mydb\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n  \n  redis:\n    image: redis:7-alpine\n    volumes:\n      - redis_data:/data\n\nvolumes:\n  postgres_data:\n  redis_data:\n\n# Multi-stage Dockerfile\nFROM node:20-alpine AS deps\nWORKDIR /app\nCOPY package.json package-lock.json ./\nRUN npm ci\n\nFROM node:20-alpine AS builder\nWORKDIR /app\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY . .\nRUN npm run build\n\nFROM node:20-alpine AS runner\nWORKDIR /app\nENV NODE_ENV production\nRUN addgroup --system --gid 1001 nodejs\nRUN adduser --system --uid 1001 hono\nCOPY --from=builder --chown=hono:nodejs /app/dist ./dist\nCOPY --from=deps --chown=hono:nodejs /app/node_modules ./node_modules\nUSER hono\nEXPOSE 3000\nCMD [\"node\", \"dist/node.js\"]\n```\n\n### Health Checks & Monitoring\n\n```typescript\n// Health check endpoint\napp.get('/health', (c) => {\n  return c.json({\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime(),\n    memory: process.memoryUsage(),\n    version: process.env.APP_VERSION || 'unknown'\n  })\n})\n\n// Readiness check\napp.get('/ready', async (c) => {\n  try {\n    // Check database connection\n    await checkDatabaseConnection()\n    // Check external services\n    await checkExternalServices()\n    \n    return c.json({ ready: true })\n  } catch (error) {\n    return c.json({ ready: false, error: error.message }, 503)\n  }\n})\n\n// Metrics endpoint\napp.get('/metrics', (c) => {\n  const metrics = collectMetrics()\n  c.header('Content-Type', 'text/plain')\n  return c.text(metrics)\n})\n```\n\n### Environment Configuration\n\n```typescript\n// src/config/index.ts\nimport { z } from 'zod'\n\nconst envSchema = z.object({\n  NODE_ENV: z.enum(['development', 'test', 'production']),\n  PORT: z.string().default('3000'),\n  DATABASE_URL: z.string(),\n  REDIS_URL: z.string().optional(),\n  JWT_SECRET: z.string().min(32),\n  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info'),\n  CORS_ORIGIN: z.string().default('*'),\n  RATE_LIMIT_MAX: z.string().default('100'),\n  RATE_LIMIT_WINDOW_MS: z.string().default('900000')\n})\n\nexport const config = envSchema.parse(process.env)\n\n// Runtime-specific configuration\nexport const getRuntimeConfig = () => {\n  const runtime = detectRuntime()\n  \n  switch (runtime) {\n    case 'cloudflare':\n      return {\n        maxBodySize: 10 * 1024 * 1024, // 10MB\n        maxDuration: 30\n      }\n    case 'vercel':\n      return {\n        maxBodySize: 4.5 * 1024 * 1024, // 4.5MB\n        maxDuration: 10\n      }\n    case 'aws-lambda':\n      return {\n        maxBodySize: 6 * 1024 * 1024, // 6MB\n        maxDuration: 900\n      }\n    default:\n      return {\n        maxBodySize: 50 * 1024 * 1024, // 50MB\n        maxDuration: Infinity\n      }\n  }\n}\n```\n\n### Sources\n\n- [Deployment Guide](https://hono.dev/docs/getting-started/vercel)\n- [Cloudflare Workers](https://hono.dev/docs/getting-started/cloudflare-workers)\n- [AWS Lambda](https://hono.dev/docs/getting-started/aws-lambda)\n- [Deno Deploy](https://hono.dev/docs/getting-started/deno)"
    },
    {
      "parent": "honojs",
      "id": "error-handling",
      "name": "Error Handling",
      "description": "Exception handling and error responses",
      "type": "rule",
      "content": "## Error Handling\n\n### Rules\n\n- ALWAYS use `HTTPException` for HTTP-related errors\n- NEVER throw plain `Error` objects in route handlers\n- Custom error handlers MUST be defined using `app.onError()`\n- Error messages MUST be clear and actionable\n- Sensitive information MUST NEVER be exposed in error messages\n- Different error types MUST return appropriate HTTP status codes\n- Error responses MUST follow a consistent format\n- Validation errors MUST return 400 status code\n- Authentication errors MUST return 401 status code\n- Authorization errors MUST return 403 status code\n- Not found errors MUST return 404 status code\n\n### HTTPException Usage\n\n```typescript\nimport { HTTPException } from 'hono/http-exception'\n\n// Basic HTTPException\napp.get('/users/:id', async (c) => {\n  const id = c.req.param('id')\n  const user = await findUser(id)\n  \n  if (!user) {\n    throw new HTTPException(404, {\n      message: `User with ID ${id} not found`\n    })\n  }\n  \n  return c.json(user)\n})\n\n// Authentication error\napp.post('/admin', async (c) => {\n  const token = c.req.header('Authorization')\n  \n  if (!token) {\n    throw new HTTPException(401, {\n      message: 'Authentication required'\n    })\n  }\n  \n  if (!isValidToken(token)) {\n    throw new HTTPException(401, {\n      message: 'Invalid or expired token'\n    })\n  }\n  \n  return c.json({ success: true })\n})\n\n// Custom response with HTTPException\napp.get('/protected', (c) => {\n  const errorResponse = new Response('Unauthorized', {\n    status: 401,\n    headers: {\n      'WWW-Authenticate': 'Bearer realm=\"api\"'\n    }\n  })\n  \n  throw new HTTPException(401, { res: errorResponse })\n})\n\n// With error cause\napp.post('/process', async (c) => {\n  try {\n    await processData()\n  } catch (error) {\n    throw new HTTPException(500, {\n      message: 'Processing failed',\n      cause: error\n    })\n  }\n})\n```\n\n### Global Error Handler\n\n```typescript\nimport { HTTPException } from 'hono/http-exception'\nimport { ZodError } from 'zod'\n\napp.onError((err, c) => {\n  // Handle HTTPException\n  if (err instanceof HTTPException) {\n    return err.getResponse()\n  }\n  \n  // Handle Zod validation errors\n  if (err instanceof ZodError) {\n    return c.json(\n      {\n        error: 'Validation failed',\n        issues: err.issues.map(issue => ({\n          path: issue.path.join('.'),\n          message: issue.message\n        }))\n      },\n      400\n    )\n  }\n  \n  // Handle database errors\n  if (err.name === 'DatabaseError') {\n    console.error('Database error:', err)\n    return c.json(\n      { error: 'Database operation failed' },\n      503\n    )\n  }\n  \n  // Log unexpected errors\n  console.error('Unexpected error:', err)\n  \n  // Generic error response (don't expose internals)\n  return c.json(\n    {\n      error: 'Internal server error',\n      message: process.env.NODE_ENV === 'development' \n        ? err.message \n        : 'An unexpected error occurred'\n    },\n    500\n  )\n})\n```\n\n### Custom Error Classes\n\n```typescript\n// src/lib/errors.ts\nimport { HTTPException } from 'hono/http-exception'\n\nexport class ValidationError extends HTTPException {\n  constructor(message: string, details?: any) {\n    super(400, { message })\n    this.name = 'ValidationError'\n    this.details = details\n  }\n  details?: any\n}\n\nexport class AuthenticationError extends HTTPException {\n  constructor(message = 'Authentication required') {\n    super(401, { message })\n    this.name = 'AuthenticationError'\n  }\n}\n\nexport class AuthorizationError extends HTTPException {\n  constructor(message = 'Insufficient permissions') {\n    super(403, { message })\n    this.name = 'AuthorizationError'\n  }\n}\n\nexport class NotFoundError extends HTTPException {\n  constructor(resource: string, id?: string) {\n    const message = id \n      ? `${resource} with ID ${id} not found`\n      : `${resource} not found`\n    super(404, { message })\n    this.name = 'NotFoundError'\n  }\n}\n\nexport class ConflictError extends HTTPException {\n  constructor(message: string) {\n    super(409, { message })\n    this.name = 'ConflictError'\n  }\n}\n\nexport class RateLimitError extends HTTPException {\n  constructor(retryAfter?: number) {\n    const headers = retryAfter \n      ? { 'Retry-After': retryAfter.toString() }\n      : undefined\n    \n    super(429, {\n      message: 'Too many requests',\n      res: new Response('Too many requests', {\n        status: 429,\n        headers\n      })\n    })\n    this.name = 'RateLimitError'\n  }\n}\n\n// Usage\napp.get('/users/:id', async (c) => {\n  const id = c.req.param('id')\n  const user = await findUser(id)\n  \n  if (!user) {\n    throw new NotFoundError('User', id)\n  }\n  \n  return c.json(user)\n})\n\napp.post('/users', async (c) => {\n  const data = await c.req.json()\n  \n  if (await userExists(data.email)) {\n    throw new ConflictError('User with this email already exists')\n  }\n  \n  const user = await createUser(data)\n  return c.json(user, 201)\n})\n```\n\n### Error Response Formatting\n\n```typescript\n// Consistent error response format\ninterface ErrorResponse {\n  error: {\n    code: string\n    message: string\n    details?: any\n    timestamp: string\n    path: string\n    requestId?: string\n  }\n}\n\napp.onError((err, c) => {\n  const requestId = c.get('requestId') // From request ID middleware\n  \n  let status = 500\n  let code = 'INTERNAL_ERROR'\n  let message = 'An unexpected error occurred'\n  let details = undefined\n  \n  if (err instanceof HTTPException) {\n    status = err.status\n    code = err.name.toUpperCase().replace('ERROR', '')\n    message = err.message\n    details = (err as any).details\n  } else if (err instanceof ZodError) {\n    status = 400\n    code = 'VALIDATION_ERROR'\n    message = 'Request validation failed'\n    details = err.flatten()\n  }\n  \n  const errorResponse: ErrorResponse = {\n    error: {\n      code,\n      message,\n      details,\n      timestamp: new Date().toISOString(),\n      path: c.req.path,\n      requestId\n    }\n  }\n  \n  return c.json(errorResponse, status)\n})\n```\n\n### Async Error Handling\n\n```typescript\n// Async error handling in middleware\napp.use('*', async (c, next) => {\n  try {\n    await next()\n  } catch (error) {\n    // Log the error\n    console.error('Request failed:', {\n      path: c.req.path,\n      method: c.req.method,\n      error\n    })\n    \n    // Re-throw to be handled by onError\n    throw error\n  }\n})\n\n// Async operation with proper error handling\napp.post('/import', async (c) => {\n  const file = await c.req.formData()\n  \n  try {\n    const result = await importData(file)\n    return c.json({ success: true, result })\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      throw error // Re-throw known errors\n    }\n    \n    // Wrap unknown errors\n    throw new HTTPException(500, {\n      message: 'Import failed',\n      cause: error\n    })\n  }\n})\n```\n\n### Error Recovery Strategies\n\n```typescript\n// Retry with exponential backoff\nasync function withRetry<T>(\n  fn: () => Promise<T>,\n  maxRetries = 3\n): Promise<T> {\n  let lastError: any\n  \n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn()\n    } catch (error) {\n      lastError = error\n      if (i < maxRetries - 1) {\n        await new Promise(resolve => \n          setTimeout(resolve, Math.pow(2, i) * 1000)\n        )\n      }\n    }\n  }\n  \n  throw new HTTPException(503, {\n    message: 'Service temporarily unavailable',\n    cause: lastError\n  })\n}\n\napp.get('/external-data', async (c) => {\n  const data = await withRetry(() => fetchExternalData())\n  return c.json(data)\n})\n\n// Circuit breaker pattern\nclass CircuitBreaker {\n  private failures = 0\n  private lastFailureTime = 0\n  private state: 'closed' | 'open' | 'half-open' = 'closed'\n  \n  constructor(\n    private threshold = 5,\n    private timeout = 60000\n  ) {}\n  \n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    if (this.state === 'open') {\n      if (Date.now() - this.lastFailureTime > this.timeout) {\n        this.state = 'half-open'\n      } else {\n        throw new HTTPException(503, {\n          message: 'Service circuit breaker is open'\n        })\n      }\n    }\n    \n    try {\n      const result = await fn()\n      if (this.state === 'half-open') {\n        this.state = 'closed'\n        this.failures = 0\n      }\n      return result\n    } catch (error) {\n      this.failures++\n      this.lastFailureTime = Date.now()\n      \n      if (this.failures >= this.threshold) {\n        this.state = 'open'\n      }\n      \n      throw error\n    }\n  }\n}\n\nconst breaker = new CircuitBreaker()\n\napp.get('/protected-resource', async (c) => {\n  const data = await breaker.execute(() => fetchProtectedResource())\n  return c.json(data)\n})\n```\n\n### Sources\n\n- [Exception Documentation](https://hono.dev/docs/api/exception)\n- [Error Handling Best Practices](https://hono.dev/docs/guides/best-practices)\n- [HTTPException API](https://hono.dev/docs/api/exception#httpexception)"
    },
    {
      "parent": "honojs",
      "id": "middleware",
      "name": "Middleware",
      "description": "Middleware creation, ordering, and usage",
      "type": "rule",
      "content": "## Middleware\n\n### Rules\n\n- Middleware MUST be functions that accept `(c, next)` parameters\n- Middleware MUST call `await next()` to continue the chain\n- Global middleware MUST be registered using `app.use()`\n- Route-specific middleware MUST be registered before the route handler\n- Middleware execution follows an \"onion\" model (before and after handler)\n- Custom middleware MUST be placed in `src/middleware/` directory\n- Built-in middleware SHOULD be preferred over custom implementations\n- Middleware MUST handle errors appropriately\n- Middleware order matters - register in the correct sequence\n\n### Built-in Middleware\n\n```typescript\nimport { Hono } from 'hono'\nimport { cors } from 'hono/cors'\nimport { logger } from 'hono/logger'\nimport { compress } from 'hono/compress'\nimport { etag } from 'hono/etag'\nimport { secureHeaders } from 'hono/secure-headers'\nimport { csrf } from 'hono/csrf'\nimport { basicAuth } from 'hono/basic-auth'\nimport { bearerAuth } from 'hono/bearer-auth'\nimport { timing } from 'hono/timing'\nimport { cache } from 'hono/cache'\n\nconst app = new Hono()\n\n// Logging\napp.use('*', logger())\n\n// CORS\napp.use('*', cors({\n  origin: ['https://example.com'],\n  allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],\n  allowHeaders: ['Content-Type', 'Authorization'],\n  credentials: true\n}))\n\n// Compression\napp.use('*', compress())\n\n// ETag\napp.use('*', etag())\n\n// Security headers\napp.use('*', secureHeaders())\n\n// CSRF protection\napp.use('*', csrf())\n\n// Basic authentication\napp.use('/admin/*', basicAuth({\n  username: 'admin',\n  password: 'secret'\n}))\n\n// Bearer token authentication\napp.use('/api/*', bearerAuth({\n  token: 'your-secret-token'\n}))\n\n// Timing\napp.use('*', timing())\n\n// Cache\napp.get('/cached', cache({ cacheName: 'my-cache' }), (c) => {\n  return c.json({ cached: true })\n})\n```\n\n### Custom Middleware\n\n#### Response Time Middleware\n\n```typescript\n// src/middleware/responseTime.ts\nimport { Context, Next } from 'hono'\n\nexport const responseTime = async (c: Context, next: Next) => {\n  const start = performance.now()\n  await next()\n  const end = performance.now()\n  c.res.headers.set('X-Response-Time', `${end - start}ms`)\n}\n\n// Usage\napp.use('*', responseTime)\n```\n\n#### Request ID Middleware\n\n```typescript\n// src/middleware/requestId.ts\nimport { Context, Next } from 'hono'\nimport { randomUUID } from 'crypto'\n\nexport const requestId = async (c: Context, next: Next) => {\n  const id = c.req.header('X-Request-ID') || randomUUID()\n  c.set('requestId', id)\n  await next()\n  c.res.headers.set('X-Request-ID', id)\n}\n\n// Usage\napp.use('*', requestId)\napp.get('/test', (c) => {\n  const id = c.get('requestId')\n  return c.json({ requestId: id })\n})\n```\n\n#### Error Handling Middleware\n\n```typescript\n// src/middleware/errorHandler.ts\nimport { Context, Next } from 'hono'\nimport { HTTPException } from 'hono/http-exception'\n\nexport const errorHandler = async (c: Context, next: Next) => {\n  try {\n    await next()\n  } catch (err) {\n    if (err instanceof HTTPException) {\n      return err.getResponse()\n    }\n    \n    console.error('Unhandled error:', err)\n    return c.json(\n      { error: 'Internal Server Error' },\n      500\n    )\n  }\n}\n\n// Usage (register as first middleware)\napp.use('*', errorHandler)\n```\n\n#### Rate Limiting Middleware\n\n```typescript\n// src/middleware/rateLimit.ts\nimport { Context, Next } from 'hono'\n\nconst requests = new Map<string, number[]>()\n\nexport const rateLimit = (max: number, windowMs: number) => {\n  return async (c: Context, next: Next) => {\n    const ip = c.req.header('x-forwarded-for') || 'unknown'\n    const now = Date.now()\n    const windowStart = now - windowMs\n    \n    const userRequests = requests.get(ip) || []\n    const recentRequests = userRequests.filter(time => time > windowStart)\n    \n    if (recentRequests.length >= max) {\n      return c.json({ error: 'Too many requests' }, 429)\n    }\n    \n    recentRequests.push(now)\n    requests.set(ip, recentRequests)\n    \n    await next()\n  }\n}\n\n// Usage\napp.use('/api/*', rateLimit(100, 60 * 1000)) // 100 requests per minute\n```\n\n### Middleware Factory Pattern\n\n```typescript\n// src/middleware/factory.ts\nimport { createFactory } from 'hono/factory'\n\nconst factory = createFactory()\n\n// Create reusable middleware\nexport const authMiddleware = factory.createMiddleware(async (c, next) => {\n  const token = c.req.header('Authorization')\n  if (!token) {\n    throw new HTTPException(401, { message: 'Unauthorized' })\n  }\n  // Validate token\n  c.set('userId', 'user123')\n  await next()\n})\n\n// Create handlers with middleware\nexport const protectedHandler = factory.createHandlers(\n  authMiddleware,\n  (c) => {\n    const userId = c.get('userId')\n    return c.json({ userId })\n  }\n)\n\n// Usage\napp.get('/protected', ...protectedHandler)\n```\n\n### Conditional Middleware\n\n```typescript\n// Apply middleware conditionally\napp.use('*', async (c, next) => {\n  if (c.req.path.startsWith('/public')) {\n    return next() // Skip middleware for public routes\n  }\n  // Apply middleware logic\n  await next()\n})\n\n// Environment-based middleware\nif (process.env.NODE_ENV === 'development') {\n  app.use('*', logger())\n}\n```\n\n### Middleware Composition\n\n```typescript\n// Compose multiple middleware\nconst composed = compose(\n  cors(),\n  logger(),\n  compress()\n)\n\napp.use('*', composed)\n\n// Or chain them\napp.use('*', cors())\n   .use('*', logger())\n   .use('*', compress())\n```\n\n### Sources\n\n- [Middleware Documentation](https://hono.dev/docs/concepts/middleware)\n- [Built-in Middleware](https://hono.dev/docs/middleware/builtin)\n- [Custom Middleware Guide](https://hono.dev/docs/guides/middleware)"
    },
    {
      "parent": "honojs",
      "id": "performance",
      "name": "Performance",
      "description": "Optimization, caching, and compression",
      "type": "rule",
      "content": "## Performance\n\n### Rules\n\n- Response compression MUST be enabled for production\n- Static assets SHOULD be cached with appropriate headers\n- Database queries MUST be optimized and use connection pooling\n- Large payloads SHOULD be paginated\n- ETags SHOULD be used for conditional requests\n- Response time SHOULD be monitored\n- Memory usage MUST be monitored in production\n- Streaming SHOULD be used for large responses\n- Unnecessary middleware MUST NOT be used in production\n- Routes MUST be ordered by specificity for optimal matching\n\n### Compression\n\n```typescript\nimport { compress } from 'hono/compress'\n\n// Enable gzip/deflate compression\napp.use('*', compress())\n\n// Custom compression options\napp.use('*', compress({\n  encoding: 'gzip', // or 'deflate', 'br'\n}))\n\n// Conditional compression\napp.use('*', async (c, next) => {\n  const path = c.req.path\n  \n  // Don't compress images and videos\n  if (path.match(/\\.(jpg|jpeg|png|gif|webp|mp4|webm)$/i)) {\n    return next()\n  }\n  \n  return compress()(c, next)\n})\n```\n\n### Caching Strategies\n\n```typescript\nimport { cache } from 'hono/cache'\nimport { etag } from 'hono/etag'\n\n// Browser caching with Cache-Control headers\napp.use('/static/*', async (c, next) => {\n  await next()\n  \n  // Cache static assets for 1 year\n  c.header('Cache-Control', 'public, max-age=31536000, immutable')\n})\n\napp.use('/api/*', async (c, next) => {\n  await next()\n  \n  // Cache API responses for 5 minutes\n  c.header('Cache-Control', 'public, max-age=300, s-maxage=300')\n})\n\n// ETag support for conditional requests\napp.use('*', etag())\n\n// Edge caching (Cloudflare Workers)\napp.get('/cached-data',\n  cache({\n    cacheName: 'my-app-cache',\n    cacheControl: 'max-age=3600',\n    wait: true,\n    vary: ['Accept-Encoding', 'Accept-Language']\n  }),\n  async (c) => {\n    const data = await fetchExpensiveData()\n    return c.json(data)\n  }\n)\n\n// Custom in-memory cache\nconst memoryCache = new Map<string, { data: any; expires: number }>()\n\nconst withCache = (ttl: number) => {\n  return async (c: Context, next: Next) => {\n    const key = `${c.req.method}:${c.req.url}`\n    const cached = memoryCache.get(key)\n    \n    if (cached && cached.expires > Date.now()) {\n      return c.json(cached.data)\n    }\n    \n    await next()\n    \n    if (c.res.status === 200) {\n      const data = await c.res.json()\n      memoryCache.set(key, {\n        data,\n        expires: Date.now() + ttl * 1000\n      })\n      return c.json(data)\n    }\n  }\n}\n\napp.get('/expensive-operation', \n  withCache(300), // Cache for 5 minutes\n  async (c) => {\n    const result = await performExpensiveOperation()\n    return c.json(result)\n  }\n)\n```\n\n### Response Streaming\n\n```typescript\n// Stream large JSON responses\napp.get('/large-dataset', async (c) => {\n  return c.streamText(async (stream) => {\n    await stream.write('[')\n    \n    for (let i = 0; i < 10000; i++) {\n      if (i > 0) await stream.write(',')\n      \n      const item = await fetchItem(i)\n      await stream.write(JSON.stringify(item))\n      \n      // Yield control periodically\n      if (i % 100 === 0) {\n        await stream.sleep(0)\n      }\n    }\n    \n    await stream.write(']')\n  })\n})\n\n// Server-Sent Events (SSE)\napp.get('/events', async (c) => {\n  return c.streamText(async (stream) => {\n    stream.header('Content-Type', 'text/event-stream')\n    stream.header('Cache-Control', 'no-cache')\n    stream.header('Connection', 'keep-alive')\n    \n    while (true) {\n      const event = await getNextEvent()\n      \n      if (event) {\n        await stream.write(`data: ${JSON.stringify(event)}\\n\\n`)\n      }\n      \n      await stream.sleep(1000)\n    }\n  })\n})\n\n// Stream file downloads\napp.get('/download/:file', async (c) => {\n  const fileName = c.req.param('file')\n  const fileStream = await getFileStream(fileName)\n  \n  c.header('Content-Type', 'application/octet-stream')\n  c.header('Content-Disposition', `attachment; filename=\"${fileName}\"`)\n  \n  return c.body(fileStream)\n})\n```\n\n### Database Optimization\n\n```typescript\n// Connection pooling example\nimport { Pool } from 'pg'\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  max: 20, // Maximum number of clients\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000,\n})\n\n// Use prepared statements\nconst getUserById = async (id: string) => {\n  const query = {\n    text: 'SELECT * FROM users WHERE id = $1',\n    values: [id],\n    name: 'get-user-by-id' // Named query for caching\n  }\n  \n  const result = await pool.query(query)\n  return result.rows[0]\n}\n\n// Batch operations\napp.post('/users/batch', async (c) => {\n  const users = await c.req.json()\n  \n  const client = await pool.connect()\n  try {\n    await client.query('BEGIN')\n    \n    const results = await Promise.all(\n      users.map(user => \n        client.query(\n          'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *',\n          [user.name, user.email]\n        )\n      )\n    )\n    \n    await client.query('COMMIT')\n    return c.json(results.map(r => r.rows[0]), 201)\n  } catch (error) {\n    await client.query('ROLLBACK')\n    throw error\n  } finally {\n    client.release()\n  }\n})\n```\n\n### Pagination\n\n```typescript\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\n\nconst paginationSchema = z.object({\n  page: z.coerce.number().min(1).default(1),\n  limit: z.coerce.number().min(1).max(100).default(20),\n  cursor: z.string().optional()\n})\n\n// Offset-based pagination\napp.get('/users',\n  zValidator('query', paginationSchema),\n  async (c) => {\n    const { page, limit } = c.req.valid('query')\n    const offset = (page - 1) * limit\n    \n    const [users, totalCount] = await Promise.all([\n      getUsersPaginated(offset, limit),\n      getUsersCount()\n    ])\n    \n    const totalPages = Math.ceil(totalCount / limit)\n    \n    return c.json({\n      data: users,\n      pagination: {\n        page,\n        limit,\n        total: totalCount,\n        totalPages,\n        hasNext: page < totalPages,\n        hasPrev: page > 1\n      }\n    })\n  }\n)\n\n// Cursor-based pagination\napp.get('/posts',\n  zValidator('query', paginationSchema),\n  async (c) => {\n    const { limit, cursor } = c.req.valid('query')\n    \n    const posts = await getPostsAfterCursor(cursor, limit + 1)\n    const hasMore = posts.length > limit\n    \n    if (hasMore) {\n      posts.pop() // Remove the extra item\n    }\n    \n    const nextCursor = hasMore ? posts[posts.length - 1].id : null\n    \n    return c.json({\n      data: posts,\n      pagination: {\n        limit,\n        nextCursor,\n        hasMore\n      }\n    })\n  }\n)\n```\n\n### Performance Monitoring\n\n```typescript\nimport { timing } from 'hono/timing'\n\n// Add Server-Timing header\napp.use('*', timing())\n\n// Custom performance monitoring\nconst performanceMonitor = async (c: Context, next: Next) => {\n  const start = performance.now()\n  const startMemory = process.memoryUsage()\n  \n  await next()\n  \n  const duration = performance.now() - start\n  const endMemory = process.memoryUsage()\n  \n  // Add performance headers\n  c.header('X-Response-Time', `${duration.toFixed(2)}ms`)\n  c.header('X-Memory-Used', `${(\n    (endMemory.heapUsed - startMemory.heapUsed) / 1024 / 1024\n  ).toFixed(2)}MB`)\n  \n  // Log slow requests\n  if (duration > 1000) {\n    console.warn('Slow request detected:', {\n      path: c.req.path,\n      method: c.req.method,\n      duration: `${duration.toFixed(2)}ms`,\n      memoryDelta: `${(\n        (endMemory.heapUsed - startMemory.heapUsed) / 1024 / 1024\n      ).toFixed(2)}MB`\n    })\n  }\n}\n\napp.use('*', performanceMonitor)\n\n// Request coalescing for identical requests\nconst requestCache = new Map<string, Promise<any>>()\n\nconst coalesceRequests = (key: string, fn: () => Promise<any>) => {\n  const existing = requestCache.get(key)\n  if (existing) return existing\n  \n  const promise = fn().finally(() => {\n    requestCache.delete(key)\n  })\n  \n  requestCache.set(key, promise)\n  return promise\n}\n\napp.get('/expensive/:id', async (c) => {\n  const id = c.req.param('id')\n  \n  const data = await coalesceRequests(\n    `expensive:${id}`,\n    () => fetchExpensiveData(id)\n  )\n  \n  return c.json(data)\n})\n```\n\n### Lazy Loading & Code Splitting\n\n```typescript\n// Lazy load heavy dependencies\nlet heavyLibrary: any\n\nconst getHeavyLibrary = async () => {\n  if (!heavyLibrary) {\n    heavyLibrary = await import('heavy-library')\n  }\n  return heavyLibrary\n}\n\napp.post('/process-image', async (c) => {\n  const lib = await getHeavyLibrary()\n  const image = await c.req.blob()\n  const processed = await lib.processImage(image)\n  return c.body(processed)\n})\n\n// Conditional middleware loading\nif (process.env.NODE_ENV === 'production') {\n  const { monitor } = await import('./middleware/monitor')\n  app.use('*', monitor())\n}\n```\n\n### Resource Optimization\n\n```typescript\n// Optimize JSON serialization\napp.get('/data', async (c) => {\n  const data = await getData()\n  \n  // Use streaming for large arrays\n  if (Array.isArray(data) && data.length > 1000) {\n    return c.streamText(async (stream) => {\n      stream.header('Content-Type', 'application/json')\n      await stream.write('[')\n      \n      for (let i = 0; i < data.length; i++) {\n        if (i > 0) await stream.write(',')\n        await stream.write(JSON.stringify(data[i]))\n      }\n      \n      await stream.write(']')\n    })\n  }\n  \n  return c.json(data)\n})\n\n// Debounce/throttle expensive operations\nconst throttle = (fn: Function, delay: number) => {\n  let lastCall = 0\n  return (...args: any[]) => {\n    const now = Date.now()\n    if (now - lastCall < delay) {\n      return Promise.resolve({ throttled: true })\n    }\n    lastCall = now\n    return fn(...args)\n  }\n}\n\nconst expensiveOperation = throttle(\n  async (data: any) => {\n    // Expensive computation\n    return processData(data)\n  },\n  1000 // Max once per second\n)\n\napp.post('/process', async (c) => {\n  const data = await c.req.json()\n  const result = await expensiveOperation(data)\n  return c.json(result)\n})\n```\n\n### Sources\n\n- [Performance Best Practices](https://hono.dev/docs/guides/best-practices)\n- [Compression Middleware](https://hono.dev/docs/middleware/builtin/compress)\n- [Cache Middleware](https://hono.dev/docs/middleware/builtin/cache)\n- [Timing Middleware](https://hono.dev/docs/middleware/builtin/timing)"
    },
    {
      "parent": "honojs",
      "id": "routing",
      "name": "Routing",
      "description": "Routing patterns and best practices",
      "type": "rule",
      "content": "## Routing\n\n### Rules\n\n- Routes MUST be defined using Hono's built-in methods (`get`, `post`, `put`, `delete`, etc.)\n- Route handlers MUST be defined inline or imported from route modules\n- Path parameters MUST use the `:param` syntax\n- Optional parameters MUST use the `:param?` syntax\n- Wildcard routes MUST use the `*` syntax\n- Route grouping MUST use the `app.route()` method\n- Middleware MUST be registered before route handlers\n- Routes MUST be registered in order of specificity (most specific first)\n- AVOID using Ruby on Rails-style controller patterns\n- PREFER inline handlers for better type inference\n\n### Examples\n\n#### Basic Routing\n\n```typescript\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\n// Basic routes\napp.get('/', (c) => c.text('Hello Hono!'))\napp.post('/users', (c) => c.json({ message: 'User created' }, 201))\napp.put('/users/:id', (c) => c.json({ message: 'User updated' }))\napp.delete('/users/:id', (c) => c.json({ message: 'User deleted' }))\n\n// Multiple methods\napp.on(['GET', 'POST'], '/endpoint', (c) => {\n  return c.text(`${c.req.method} request`)\n})\n```\n\n#### Path Parameters\n\n```typescript\n// Required parameter\napp.get('/users/:id', (c) => {\n  const id = c.req.param('id')\n  return c.json({ userId: id })\n})\n\n// Optional parameter\napp.get('/posts/:id?', (c) => {\n  const id = c.req.param('id')\n  if (id) {\n    return c.json({ postId: id })\n  }\n  return c.json({ message: 'All posts' })\n})\n\n// Multiple parameters\napp.get('/users/:userId/posts/:postId', (c) => {\n  const { userId, postId } = c.req.param()\n  return c.json({ userId, postId })\n})\n\n// Wildcard\napp.get('/files/*', (c) => {\n  const path = c.req.param('*')\n  return c.text(`File path: ${path}`)\n})\n```\n\n#### Route Grouping\n\n```typescript\n// routes/users.ts\nimport { Hono } from 'hono'\nimport { zValidator } from '@hono/zod-validator'\nimport { createUserSchema, updateUserSchema } from '../validators/user'\n\nconst users = new Hono()\n\nusers\n  .get('/', (c) => c.json({ users: [] }))\n  .get('/:id', (c) => {\n    const id = c.req.param('id')\n    return c.json({ id })\n  })\n  .post('/', zValidator('json', createUserSchema), (c) => {\n    const data = c.req.valid('json')\n    return c.json(data, 201)\n  })\n  .put('/:id', zValidator('json', updateUserSchema), (c) => {\n    const id = c.req.param('id')\n    const data = c.req.valid('json')\n    return c.json({ id, ...data })\n  })\n  .delete('/:id', (c) => {\n    const id = c.req.param('id')\n    return c.json({ deleted: id })\n  })\n\nexport default users\n\n// app.ts\nimport users from './routes/users'\n\napp.route('/api/users', users)\n```\n\n#### Chained Routes\n\n```typescript\nconst app = new Hono()\n  .get('/posts', (c) => c.json({ posts: [] }))\n  .post('/posts', (c) => c.json({ created: true }, 201))\n  .get('/posts/:id', (c) => {\n    const id = c.req.param('id')\n    return c.json({ id })\n  })\n```\n\n#### Route Precedence\n\n```typescript\n// Specific routes first\napp.get('/users/me', (c) => c.json({ user: 'current' }))\napp.get('/users/:id', (c) => c.json({ id: c.req.param('id') }))\n\n// Middleware before handlers\napp.use('/admin/*', authMiddleware)\napp.get('/admin/dashboard', (c) => c.text('Admin Dashboard'))\n\n// Fallback routes last\napp.get('*', (c) => c.text('Not Found', 404))\n```\n\n### Route Response Methods\n\n```typescript\n// Text response\napp.get('/text', (c) => c.text('Plain text'))\n\n// JSON response\napp.get('/json', (c) => c.json({ key: 'value' }))\n\n// HTML response\napp.get('/html', (c) => c.html('<h1>Hello</h1>'))\n\n// Redirect\napp.get('/redirect', (c) => c.redirect('/destination'))\n\n// Custom status\napp.get('/created', (c) => c.json({ created: true }, 201))\n\n// Stream response\napp.get('/stream', (c) => {\n  return c.streamText(async (stream) => {\n    await stream.write('Hello')\n    await stream.write(' World')\n  })\n})\n```\n\n### Sources\n\n- [Routing Documentation](https://hono.dev/docs/api/routing)\n- [Best Practices](https://hono.dev/docs/guides/best-practices)"
    },
    {
      "parent": "honojs",
      "id": "rpc",
      "name": "RPC",
      "description": "Type-safe client-server communication",
      "type": "rule",
      "content": "## RPC (Remote Procedure Call)\n\n### Rules\n\n- RPC routes MUST be chained to maintain type information\n- Client types MUST be generated from server route definitions\n- Type safety MUST be maintained across client-server boundary\n- Route definitions MUST be exported for client generation\n- RPC endpoints SHOULD use consistent naming conventions\n- Error handling MUST be type-safe on both ends\n- Request/response validation MUST be implemented\n- RPC client MUST handle network errors gracefully\n\n### Basic RPC Setup\n\n```typescript\n// server/routes/api.ts\nimport { Hono } from 'hono'\nimport { zValidator } from '@hono/zod-validator'\nimport { z } from 'zod'\n\nconst userSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  email: z.string().email()\n})\n\nconst createUserSchema = z.object({\n  name: z.string().min(1),\n  email: z.string().email()\n})\n\n// Define API routes with chaining for type inference\nconst api = new Hono()\n  .get('/users', (c) => {\n    const users = getUsers()\n    return c.json({ users })\n  })\n  .get('/users/:id', (c) => {\n    const id = c.req.param('id')\n    const user = getUserById(id)\n    if (!user) {\n      return c.json({ error: 'User not found' }, 404)\n    }\n    return c.json({ user })\n  })\n  .post('/users',\n    zValidator('json', createUserSchema),\n    (c) => {\n      const data = c.req.valid('json')\n      const user = createUser(data)\n      return c.json({ user }, 201)\n    }\n  )\n  .put('/users/:id',\n    zValidator('json', createUserSchema.partial()),\n    (c) => {\n      const id = c.req.param('id')\n      const data = c.req.valid('json')\n      const user = updateUser(id, data)\n      return c.json({ user })\n    }\n  )\n  .delete('/users/:id', (c) => {\n    const id = c.req.param('id')\n    deleteUser(id)\n    return c.json({ success: true })\n  })\n\n// Export the type for client generation\nexport type ApiType = typeof api\nexport default api\n\n// server/index.ts\nimport { Hono } from 'hono'\nimport { cors } from 'hono/cors'\nimport api from './routes/api'\n\nconst app = new Hono()\n  .use('*', cors())\n  .route('/api', api)\n\nexport default app\nexport type AppType = typeof app\n```\n\n### Type-Safe Client\n\n```typescript\n// client/api.ts\nimport { hc } from 'hono/client'\nimport type { ApiType } from '../server/routes/api'\n\n// Create typed client\nconst client = hc<ApiType>('http://localhost:3000/api')\n\n// Usage with full type safety\nexport const userApi = {\n  // GET /api/users\n  getUsers: async () => {\n    const res = await client.users.$get()\n    if (!res.ok) {\n      throw new Error('Failed to fetch users')\n    }\n    return await res.json() // Typed as { users: User[] }\n  },\n\n  // GET /api/users/:id\n  getUser: async (id: string) => {\n    const res = await client.users[':id'].$get({\n      param: { id }\n    })\n    if (res.status === 404) {\n      return null\n    }\n    if (!res.ok) {\n      throw new Error('Failed to fetch user')\n    }\n    return await res.json() // Typed as { user: User }\n  },\n\n  // POST /api/users\n  createUser: async (user: { name: string; email: string }) => {\n    const res = await client.users.$post({\n      json: user\n    })\n    if (!res.ok) {\n      const error = await res.json()\n      throw new Error(error.error || 'Failed to create user')\n    }\n    return await res.json() // Typed as { user: User }\n  },\n\n  // PUT /api/users/:id\n  updateUser: async (id: string, updates: Partial<{ name: string; email: string }>) => {\n    const res = await client.users[':id'].$put({\n      param: { id },\n      json: updates\n    })\n    if (!res.ok) {\n      throw new Error('Failed to update user')\n    }\n    return await res.json() // Typed as { user: User }\n  },\n\n  // DELETE /api/users/:id\n  deleteUser: async (id: string) => {\n    const res = await client.users[':id'].$delete({\n      param: { id }\n    })\n    if (!res.ok) {\n      throw new Error('Failed to delete user')\n    }\n    return await res.json() // Typed as { success: boolean }\n  }\n}\n```\n\n### Advanced RPC Patterns\n\n```typescript\n// server/routes/posts.ts\nimport { Hono } from 'hono'\nimport { zValidator } from '@hono/zod-validator'\nimport { z } from 'zod'\n\nconst postQuerySchema = z.object({\n  page: z.coerce.number().min(1).default(1),\n  limit: z.coerce.number().min(1).max(100).default(10),\n  author: z.string().optional(),\n  tag: z.string().optional()\n})\n\nconst createPostSchema = z.object({\n  title: z.string().min(1),\n  content: z.string().min(1),\n  tags: z.array(z.string()).default([]),\n  published: z.boolean().default(false)\n})\n\n// Complex RPC with nested resources\nconst posts = new Hono()\n  // List posts with query parameters\n  .get('/',\n    zValidator('query', postQuerySchema),\n    async (c) => {\n      const query = c.req.valid('query')\n      const { posts, pagination } = await getPosts(query)\n      return c.json({ posts, pagination })\n    }\n  )\n  \n  // Get post by ID\n  .get('/:id', async (c) => {\n    const id = c.req.param('id')\n    const post = await getPostById(id)\n    if (!post) {\n      return c.json({ error: 'Post not found' }, 404)\n    }\n    return c.json({ post })\n  })\n  \n  // Create new post\n  .post('/',\n    zValidator('json', createPostSchema),\n    async (c) => {\n      const data = c.req.valid('json')\n      const post = await createPost(data)\n      return c.json({ post }, 201)\n    }\n  )\n  \n  // Get post comments\n  .get('/:id/comments', async (c) => {\n    const postId = c.req.param('id')\n    const comments = await getPostComments(postId)\n    return c.json({ comments })\n  })\n  \n  // Add comment to post\n  .post('/:id/comments',\n    zValidator('json', z.object({\n      content: z.string().min(1),\n      author: z.string().min(1)\n    })),\n    async (c) => {\n      const postId = c.req.param('id')\n      const data = c.req.valid('json')\n      const comment = await addComment(postId, data)\n      return c.json({ comment }, 201)\n    }\n  )\n\nexport type PostsType = typeof posts\nexport default posts\n```\n\n### Client with Error Handling\n\n```typescript\n// client/posts.ts\nimport { hc } from 'hono/client'\nimport type { PostsType } from '../server/routes/posts'\n\nconst client = hc<PostsType>('http://localhost:3000/api/posts')\n\nexport class PostsApiError extends Error {\n  constructor(\n    message: string,\n    public status: number,\n    public details?: any\n  ) {\n    super(message)\n    this.name = 'PostsApiError'\n  }\n}\n\nexport const postsApi = {\n  getPosts: async (query?: {\n    page?: number\n    limit?: number\n    author?: string\n    tag?: string\n  }) => {\n    try {\n      const res = await client.$get({\n        query: query ? {\n          page: query.page?.toString(),\n          limit: query.limit?.toString(),\n          author: query.author,\n          tag: query.tag\n        } : undefined\n      })\n      \n      if (!res.ok) {\n        const error = await res.json().catch(() => ({ error: 'Unknown error' }))\n        throw new PostsApiError(\n          error.error || 'Failed to fetch posts',\n          res.status,\n          error\n        )\n      }\n      \n      return await res.json()\n    } catch (error) {\n      if (error instanceof PostsApiError) throw error\n      throw new PostsApiError('Network error', 0, error)\n    }\n  },\n\n  getPost: async (id: string) => {\n    try {\n      const res = await client[':id'].$get({ param: { id } })\n      \n      if (res.status === 404) {\n        return null\n      }\n      \n      if (!res.ok) {\n        const error = await res.json().catch(() => ({ error: 'Unknown error' }))\n        throw new PostsApiError(\n          error.error || 'Failed to fetch post',\n          res.status\n        )\n      }\n      \n      return await res.json()\n    } catch (error) {\n      if (error instanceof PostsApiError) throw error\n      throw new PostsApiError('Network error', 0, error)\n    }\n  },\n\n  createPost: async (post: {\n    title: string\n    content: string\n    tags?: string[]\n    published?: boolean\n  }) => {\n    try {\n      const res = await client.$post({ json: post })\n      \n      if (!res.ok) {\n        const error = await res.json().catch(() => ({ error: 'Unknown error' }))\n        throw new PostsApiError(\n          error.error || 'Failed to create post',\n          res.status,\n          error\n        )\n      }\n      \n      return await res.json()\n    } catch (error) {\n      if (error instanceof PostsApiError) throw error\n      throw new PostsApiError('Network error', 0, error)\n    }\n  }\n}\n```\n\n### RPC with Authentication\n\n```typescript\n// client/authenticated-client.ts\nimport { hc } from 'hono/client'\nimport type { AppType } from '../server'\n\nexport class AuthenticatedClient {\n  private client: ReturnType<typeof hc<AppType>>\n  private token: string | null = null\n\n  constructor(baseUrl: string) {\n    this.client = hc<AppType>(baseUrl)\n  }\n\n  setToken(token: string) {\n    this.token = token\n  }\n\n  private getHeaders() {\n    return this.token ? { Authorization: `Bearer ${this.token}` } : {}\n  }\n\n  async getProfile() {\n    const res = await this.client.auth.me.$get({}, {\n      headers: this.getHeaders()\n    })\n    \n    if (!res.ok) {\n      throw new Error('Failed to get profile')\n    }\n    \n    return await res.json()\n  }\n\n  async updateProfile(data: { name?: string; email?: string }) {\n    const res = await this.client.auth.me.$put({\n      json: data\n    }, {\n      headers: this.getHeaders()\n    })\n    \n    if (!res.ok) {\n      throw new Error('Failed to update profile')\n    }\n    \n    return await res.json()\n  }\n}\n\n// Usage\nconst api = new AuthenticatedClient('http://localhost:3000')\napi.setToken('your-jwt-token')\n\nconst profile = await api.getProfile()\nawait api.updateProfile({ name: 'New Name' })\n```\n\n### RPC Testing\n\n```typescript\n// tests/rpc.test.ts\nimport { describe, it, expect, beforeEach } from 'vitest'\nimport { testClient } from 'hono/testing'\nimport type { AppType } from '../src/app'\nimport app from '../src/app'\n\ndescribe('RPC API', () => {\n  let client: ReturnType<typeof testClient<AppType>>\n  \n  beforeEach(() => {\n    client = testClient(app)\n  })\n  \n  it('should get users with type safety', async () => {\n    const res = await client.api.users.$get()\n    \n    expect(res.status).toBe(200)\n    \n    const data = await res.json()\n    // data is typed as { users: User[] }\n    expect(data).toHaveProperty('users')\n    expect(Array.isArray(data.users)).toBe(true)\n  })\n  \n  it('should create user with validation', async () => {\n    const res = await client.api.users.$post({\n      json: {\n        name: 'Test User',\n        email: 'test@example.com'\n      }\n    })\n    \n    expect(res.status).toBe(201)\n    \n    const data = await res.json()\n    // data is typed as { user: User }\n    expect(data.user).toHaveProperty('id')\n    expect(data.user.name).toBe('Test User')\n  })\n  \n  it('should handle validation errors', async () => {\n    const res = await client.api.users.$post({\n      json: {\n        name: '',\n        email: 'invalid-email'\n      }\n    })\n    \n    expect(res.status).toBe(400)\n    \n    const error = await res.json()\n    expect(error).toHaveProperty('error')\n  })\n})\n```\n\n### React Hook Integration\n\n```typescript\n// hooks/useApi.ts\nimport { useState, useEffect } from 'react'\nimport { userApi, PostsApiError } from '../client/api'\n\nexport function useUsers() {\n  const [users, setUsers] = useState<User[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n\n  useEffect(() => {\n    userApi.getUsers()\n      .then(data => {\n        setUsers(data.users)\n        setError(null)\n      })\n      .catch(err => {\n        setError(err.message)\n      })\n      .finally(() => {\n        setLoading(false)\n      })\n  }, [])\n\n  return { users, loading, error }\n}\n\nexport function useCreateUser() {\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  const createUser = async (userData: { name: string; email: string }) => {\n    setLoading(true)\n    setError(null)\n    \n    try {\n      const result = await userApi.createUser(userData)\n      return result\n    } catch (err) {\n      const message = err instanceof PostsApiError \n        ? err.message \n        : 'Failed to create user'\n      setError(message)\n      throw err\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  return { createUser, loading, error }\n}\n```\n\n### Sources\n\n- [RPC Guide](https://hono.dev/docs/guides/rpc)\n- [Client Documentation](https://hono.dev/docs/guides/rpc#client)\n- [Type Safety](https://hono.dev/docs/guides/rpc#type-safety)"
    },
    {
      "parent": "honojs",
      "id": "security",
      "name": "Security",
      "description": "Security middleware and best practices",
      "type": "rule",
      "content": "## Security\n\n### Rules\n\n- Security headers MUST be implemented using secure-headers middleware\n- CORS MUST be properly configured for production environments\n- CSRF protection MUST be enabled for state-changing operations\n- Authentication MUST be implemented for protected routes\n- Input validation MUST be performed on all user inputs\n- Sensitive data MUST NEVER be logged or exposed in responses\n- Rate limiting SHOULD be implemented for public APIs\n- Content Security Policy (CSP) SHOULD be configured\n- HTTPS MUST be enforced in production\n- JWT secrets and API keys MUST be stored in environment variables\n\n### Security Headers\n\n```typescript\nimport { secureHeaders } from 'hono/secure-headers'\n\n// Basic security headers\napp.use('*', secureHeaders())\n\n// Custom security headers configuration\napp.use('*', secureHeaders({\n  contentSecurityPolicy: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\", \"'unsafe-inline'\", 'https://cdn.example.com'],\n    styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n    imgSrc: [\"'self'\", 'data:', 'https:'],\n    connectSrc: [\"'self'\"],\n    fontSrc: [\"'self'\"],\n    objectSrc: [\"'none'\"],\n    mediaSrc: [\"'self'\"],\n    frameSrc: [\"'none'\"],\n  },\n  crossOriginEmbedderPolicy: 'require-corp',\n  crossOriginOpenerPolicy: 'same-origin',\n  crossOriginResourcePolicy: 'same-origin',\n  originAgentCluster: '?1',\n  referrerPolicy: 'no-referrer',\n  strictTransportSecurity: 'max-age=15552000; includeSubDomains',\n  xContentTypeOptions: 'nosniff',\n  xDnsPrefetchControl: 'off',\n  xDownloadOptions: 'noopen',\n  xFrameOptions: 'SAMEORIGIN',\n  xPermittedCrossDomainPolicies: 'none',\n  xXssProtection: '0',\n  permissionsPolicy: {\n    camera: ['none'],\n    microphone: ['none'],\n    geolocation: ['none']\n  }\n}))\n```\n\n### CORS Configuration\n\n```typescript\nimport { cors } from 'hono/cors'\n\n// Development CORS (permissive)\nif (process.env.NODE_ENV === 'development') {\n  app.use('*', cors())\n}\n\n// Production CORS (restrictive)\napp.use('*', cors({\n  origin: (origin) => {\n    const allowedOrigins = [\n      'https://app.example.com',\n      'https://www.example.com'\n    ]\n    return allowedOrigins.includes(origin) ? origin : null\n  },\n  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n  allowHeaders: ['Content-Type', 'Authorization', 'X-Request-ID'],\n  exposeHeaders: ['X-Response-Time', 'X-Request-ID'],\n  maxAge: 86400,\n  credentials: true\n}))\n\n// API-specific CORS\napp.use('/api/*', cors({\n  origin: 'https://app.example.com',\n  credentials: true\n}))\n```\n\n### CSRF Protection\n\n```typescript\nimport { csrf } from 'hono/csrf'\n\n// CSRF protection for state-changing operations\napp.use('*', csrf({\n  origin: ['https://example.com', 'https://app.example.com']\n}))\n\n// Custom CSRF configuration\napp.use('*', csrf({\n  origin: (origin) => {\n    return origin.endsWith('.example.com')\n  }\n}))\n\n// Exclude certain routes from CSRF\napp.use('*', async (c, next) => {\n  // Skip CSRF for webhooks\n  if (c.req.path.startsWith('/webhooks/')) {\n    return next()\n  }\n  \n  return csrf({\n    origin: 'https://example.com'\n  })(c, next)\n})\n```\n\n### Authentication & Authorization\n\n```typescript\nimport { sign, verify } from 'hono/jwt'\nimport { bearerAuth } from 'hono/bearer-auth'\nimport { basicAuth } from 'hono/basic-auth'\n\n// JWT Authentication\nconst jwtMiddleware = async (c: Context, next: Next) => {\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n  \n  if (!token) {\n    throw new HTTPException(401, { message: 'Token required' })\n  }\n  \n  try {\n    const payload = await verify(token, c.env.JWT_SECRET)\n    c.set('userId', payload.sub)\n    c.set('user', payload)\n    await next()\n  } catch (error) {\n    throw new HTTPException(401, { message: 'Invalid token' })\n  }\n}\n\n// Bearer Token Authentication\napp.use('/api/*', bearerAuth({\n  verifyToken: async (token, c) => {\n    // Verify token against database or cache\n    const valid = await verifyApiToken(token)\n    return valid\n  }\n}))\n\n// Basic Authentication for admin routes\napp.use('/admin/*', basicAuth({\n  username: process.env.ADMIN_USERNAME,\n  password: process.env.ADMIN_PASSWORD,\n  realm: 'Admin Area',\n  invalidUserMessage: 'Invalid credentials'\n}))\n\n// Role-based authorization\nconst requireRole = (role: string) => {\n  return async (c: Context, next: Next) => {\n    const user = c.get('user')\n    \n    if (!user || user.role !== role) {\n      throw new HTTPException(403, { \n        message: 'Insufficient permissions' \n      })\n    }\n    \n    await next()\n  }\n}\n\napp.get('/admin/users', \n  jwtMiddleware,\n  requireRole('admin'),\n  (c) => c.json({ users: [] })\n)\n```\n\n### Rate Limiting\n\n```typescript\n// Simple in-memory rate limiter\nconst rateLimits = new Map<string, number[]>()\n\nconst rateLimit = (options: {\n  windowMs: number\n  max: number\n  keyGenerator?: (c: Context) => string\n}) => {\n  return async (c: Context, next: Next) => {\n    const key = options.keyGenerator?.(c) || \n      c.req.header('x-forwarded-for') || \n      'global'\n    \n    const now = Date.now()\n    const windowStart = now - options.windowMs\n    \n    const requests = rateLimits.get(key) || []\n    const recentRequests = requests.filter(time => time > windowStart)\n    \n    if (recentRequests.length >= options.max) {\n      const retryAfter = Math.ceil(\n        (recentRequests[0] + options.windowMs - now) / 1000\n      )\n      \n      c.header('X-RateLimit-Limit', options.max.toString())\n      c.header('X-RateLimit-Remaining', '0')\n      c.header('X-RateLimit-Reset', new Date(\n        recentRequests[0] + options.windowMs\n      ).toISOString())\n      c.header('Retry-After', retryAfter.toString())\n      \n      return c.json(\n        { error: 'Too many requests' },\n        429\n      )\n    }\n    \n    recentRequests.push(now)\n    rateLimits.set(key, recentRequests)\n    \n    c.header('X-RateLimit-Limit', options.max.toString())\n    c.header('X-RateLimit-Remaining', \n      (options.max - recentRequests.length).toString()\n    )\n    \n    await next()\n  }\n}\n\n// Apply rate limiting\napp.use('/api/*', rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // 100 requests per window\n  keyGenerator: (c) => {\n    // Rate limit by API key or IP\n    return c.req.header('X-API-Key') || \n           c.req.header('x-forwarded-for') || \n           'anonymous'\n  }\n}))\n\n// Stricter rate limit for auth endpoints\napp.use('/auth/*', rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5 // Only 5 attempts per 15 minutes\n}))\n```\n\n### Input Sanitization\n\n```typescript\nimport DOMPurify from 'isomorphic-dompurify'\n\n// HTML sanitization middleware\nconst sanitizeHtml = async (c: Context, next: Next) => {\n  if (c.req.method === 'POST' || c.req.method === 'PUT') {\n    const contentType = c.req.header('content-type')\n    \n    if (contentType?.includes('application/json')) {\n      const body = await c.req.json()\n      \n      // Recursively sanitize all string values\n      const sanitize = (obj: any): any => {\n        if (typeof obj === 'string') {\n          return DOMPurify.sanitize(obj)\n        }\n        if (Array.isArray(obj)) {\n          return obj.map(sanitize)\n        }\n        if (obj && typeof obj === 'object') {\n          return Object.keys(obj).reduce((acc, key) => {\n            acc[key] = sanitize(obj[key])\n            return acc\n          }, {} as any)\n        }\n        return obj\n      }\n      \n      c.req.json = async () => sanitize(body)\n    }\n  }\n  \n  await next()\n}\n\napp.use('*', sanitizeHtml)\n\n// SQL injection prevention (use parameterized queries)\napp.get('/users', async (c) => {\n  const name = c.req.query('name')\n  \n  // NEVER do this:\n  // const users = await db.query(`SELECT * FROM users WHERE name = '${name}'`)\n  \n  // DO this instead:\n  const users = await db.query(\n    'SELECT * FROM users WHERE name = ?',\n    [name]\n  )\n  \n  return c.json(users)\n})\n```\n\n### Secret Management\n\n```typescript\n// Environment variable validation\nconst validateEnv = () => {\n  const required = [\n    'JWT_SECRET',\n    'DATABASE_URL',\n    'API_KEY',\n    'ENCRYPTION_KEY'\n  ]\n  \n  const missing = required.filter(key => !process.env[key])\n  \n  if (missing.length > 0) {\n    throw new Error(\n      `Missing required environment variables: ${missing.join(', ')}`\n    )\n  }\n  \n  // Validate secret strength\n  if (process.env.JWT_SECRET.length < 32) {\n    throw new Error('JWT_SECRET must be at least 32 characters')\n  }\n}\n\n// Call during app initialization\nvalidateEnv()\n\n// Secure cookie configuration\nimport { setCookie } from 'hono/cookie'\n\napp.post('/auth/login', async (c) => {\n  const token = await generateToken()\n  \n  setCookie(c, 'token', token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'Strict',\n    maxAge: 60 * 60 * 24 * 7, // 1 week\n    path: '/'\n  })\n  \n  return c.json({ success: true })\n})\n```\n\n### Security Monitoring\n\n```typescript\n// Security event logging\nconst securityLogger = async (c: Context, next: Next) => {\n  const start = Date.now()\n  \n  try {\n    await next()\n  } catch (error) {\n    if (error instanceof HTTPException) {\n      if (error.status === 401 || error.status === 403) {\n        // Log security events\n        console.warn('Security event:', {\n          type: error.status === 401 ? 'authentication' : 'authorization',\n          path: c.req.path,\n          method: c.req.method,\n          ip: c.req.header('x-forwarded-for'),\n          userAgent: c.req.header('user-agent'),\n          timestamp: new Date().toISOString()\n        })\n      }\n    }\n    throw error\n  }\n  \n  // Log suspicious activity\n  const duration = Date.now() - start\n  if (duration > 5000) {\n    console.warn('Slow request detected:', {\n      path: c.req.path,\n      duration,\n      ip: c.req.header('x-forwarded-for')\n    })\n  }\n}\n\napp.use('*', securityLogger)\n```\n\n### Sources\n\n- [Security Headers](https://hono.dev/docs/middleware/builtin/secure-headers)\n- [CORS Middleware](https://hono.dev/docs/middleware/builtin/cors)\n- [CSRF Protection](https://hono.dev/docs/middleware/builtin/csrf)\n- [JWT Authentication](https://hono.dev/docs/middleware/builtin/jwt)\n- [OWASP Security Guidelines](https://owasp.org/www-project-top-ten/)"
    },
    {
      "parent": "honojs",
      "id": "structure",
      "name": "Project Structure",
      "description": "Guidelines for organizing Hono.js applications",
      "type": "rule",
      "content": "## Project Structure\n\n### Recommended Structure\n\n```\nroot/\n├── src/\n│   ├── index.ts          # Main application entry point\n│   ├── app.ts            # Hono app instance and configuration\n│   ├── routes/           # Route modules\n│   │   ├── users.ts      # User routes\n│   │   ├── posts.ts      # Post routes\n│   │   └── auth.ts       # Authentication routes\n│   ├── middleware/       # Custom middleware\n│   │   ├── auth.ts       # Authentication middleware\n│   │   ├── logger.ts     # Logging middleware\n│   │   └── cors.ts       # CORS configuration\n│   ├── validators/       # Validation schemas\n│   │   ├── user.ts       # User validation schemas\n│   │   └── post.ts       # Post validation schemas\n│   ├── lib/              # Shared utilities and helpers\n│   │   ├── db.ts         # Database connection\n│   │   └── utils.ts      # Utility functions\n│   └── types/            # TypeScript type definitions\n│       └── index.ts      # Shared types\n├── tests/                # Test files\n│   ├── unit/             # Unit tests\n│   └── integration/      # Integration tests\n├── dist/                 # Compiled output (generated)\n├── .env                  # Environment variables\n├── .env.example          # Environment variables example\n├── package.json          # Dependencies and scripts\n├── tsconfig.json         # TypeScript configuration\n└── wrangler.toml         # Cloudflare Workers config (if applicable)\n```\n\n### Rules\n\n- The main application instance MUST be created in `src/app.ts` and exported\n- Routes MUST be organized in separate files within `src/routes/`\n- Custom middleware MUST be placed in `src/middleware/`\n- Validation schemas MUST be placed in `src/validators/`\n- Shared utilities and helpers MUST be placed in `src/lib/`\n- TypeScript type definitions MUST be placed in `src/types/`\n- Environment-specific configuration MUST use `.env` files\n- NEVER commit `.env` files to version control\n- ALWAYS provide `.env.example` with dummy values\n\n### Examples\n\n#### Main Entry Point (src/index.ts)\n\n```typescript\nimport { serve } from '@hono/node-server'\nimport app from './app'\n\nconst port = process.env.PORT || 3000\n\nserve({\n  fetch: app.fetch,\n  port: Number(port)\n})\n\nconsole.log(`Server running on port ${port}`)\n```\n\n#### App Configuration (src/app.ts)\n\n```typescript\nimport { Hono } from 'hono'\nimport { cors } from 'hono/cors'\nimport { logger } from 'hono/logger'\nimport users from './routes/users'\nimport posts from './routes/posts'\n\nconst app = new Hono()\n\n// Global middleware\napp.use('*', logger())\napp.use('*', cors())\n\n// Route mounting\napp.route('/api/users', users)\napp.route('/api/posts', posts)\n\n// Health check\napp.get('/health', (c) => c.json({ status: 'ok' }))\n\nexport default app\n```\n\n### Sources\n\n- [Hono.js Documentation](https://hono.dev/docs)\n- [Best Practices Guide](https://hono.dev/docs/guides/best-practices)"
    },
    {
      "parent": "honojs",
      "id": "testing",
      "name": "Testing",
      "description": "Testing strategies and best practices",
      "type": "rule",
      "content": "## Testing\n\n### Rules\n\n- Unit tests MUST be written for all business logic\n- Integration tests MUST be written for API endpoints\n- Test files MUST be colocated with source files or in a `tests/` directory\n- Test coverage SHOULD be maintained above 80%\n- Mocking SHOULD be used for external dependencies\n- Test data MUST NOT contain real user information\n- Tests MUST be isolated and not depend on execution order\n- E2E tests SHOULD cover critical user flows\n- Performance tests SHOULD be included for critical endpoints\n\n### Test Setup\n\n```typescript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n      exclude: [\n        'node_modules/',\n        'tests/',\n        '*.config.ts'\n      ]\n    },\n    setupFiles: ['./tests/setup.ts']\n  },\n  resolve: {\n    alias: {\n      '@': '/src'\n    }\n  }\n})\n\n// tests/setup.ts\nimport { beforeAll, afterAll, beforeEach } from 'vitest'\n\nbeforeAll(() => {\n  // Global setup\n  process.env.NODE_ENV = 'test'\n  process.env.JWT_SECRET = 'test-secret'\n})\n\nbeforeEach(() => {\n  // Reset mocks before each test\n  vi.clearAllMocks()\n})\n\nafterAll(() => {\n  // Cleanup\n})\n```\n\n### Unit Testing\n\n```typescript\n// src/lib/utils.test.ts\nimport { describe, it, expect } from 'vitest'\nimport { formatDate, calculatePrice, validateEmail } from './utils'\n\ndescribe('Utils', () => {\n  describe('formatDate', () => {\n    it('should format date correctly', () => {\n      const date = new Date('2024-01-15T10:30:00Z')\n      expect(formatDate(date)).toBe('2024-01-15')\n    })\n    \n    it('should handle invalid dates', () => {\n      expect(formatDate(null)).toBe('')\n      expect(formatDate(undefined)).toBe('')\n    })\n  })\n  \n  describe('calculatePrice', () => {\n    it('should calculate price with tax', () => {\n      expect(calculatePrice(100, 0.1)).toBe(110)\n    })\n    \n    it('should handle negative values', () => {\n      expect(() => calculatePrice(-100, 0.1)).toThrow('Invalid price')\n    })\n  })\n  \n  describe('validateEmail', () => {\n    it.each([\n      ['user@example.com', true],\n      ['user+tag@example.co.uk', true],\n      ['invalid.email', false],\n      ['@example.com', false],\n      ['user@', false]\n    ])('validates %s as %s', (email, expected) => {\n      expect(validateEmail(email)).toBe(expected)\n    })\n  })\n})\n```\n\n### API Testing\n\n```typescript\n// src/routes/users.test.ts\nimport { describe, it, expect, beforeEach, vi } from 'vitest'\nimport { Hono } from 'hono'\nimport { testClient } from 'hono/testing'\nimport users from './users'\nimport * as db from '@/lib/db'\n\n// Mock database\nvi.mock('@/lib/db')\n\ndescribe('Users API', () => {\n  let app: Hono\n  \n  beforeEach(() => {\n    app = new Hono()\n    app.route('/users', users)\n  })\n  \n  describe('GET /users', () => {\n    it('should return all users', async () => {\n      const mockUsers = [\n        { id: '1', name: 'Alice', email: 'alice@example.com' },\n        { id: '2', name: 'Bob', email: 'bob@example.com' }\n      ]\n      \n      vi.mocked(db.getUsers).mockResolvedValue(mockUsers)\n      \n      const res = await app.request('/users')\n      \n      expect(res.status).toBe(200)\n      const data = await res.json()\n      expect(data).toEqual(mockUsers)\n      expect(db.getUsers).toHaveBeenCalledOnce()\n    })\n    \n    it('should handle pagination', async () => {\n      const res = await app.request('/users?page=2&limit=10')\n      \n      expect(res.status).toBe(200)\n      expect(db.getUsers).toHaveBeenCalledWith({ \n        offset: 10, \n        limit: 10 \n      })\n    })\n  })\n  \n  describe('POST /users', () => {\n    it('should create a new user', async () => {\n      const newUser = { \n        name: 'Charlie', \n        email: 'charlie@example.com' \n      }\n      \n      const createdUser = { id: '3', ...newUser }\n      vi.mocked(db.createUser).mockResolvedValue(createdUser)\n      \n      const res = await app.request('/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(newUser)\n      })\n      \n      expect(res.status).toBe(201)\n      const data = await res.json()\n      expect(data).toEqual(createdUser)\n    })\n    \n    it('should validate input', async () => {\n      const invalidUser = { name: '', email: 'invalid' }\n      \n      const res = await app.request('/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(invalidUser)\n      })\n      \n      expect(res.status).toBe(400)\n      const error = await res.json()\n      expect(error).toHaveProperty('error')\n    })\n  })\n  \n  describe('PUT /users/:id', () => {\n    it('should update an existing user', async () => {\n      const update = { name: 'Alice Updated' }\n      const updated = { id: '1', name: 'Alice Updated', email: 'alice@example.com' }\n      \n      vi.mocked(db.updateUser).mockResolvedValue(updated)\n      \n      const res = await app.request('/users/1', {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(update)\n      })\n      \n      expect(res.status).toBe(200)\n      const data = await res.json()\n      expect(data).toEqual(updated)\n    })\n    \n    it('should return 404 for non-existent user', async () => {\n      vi.mocked(db.updateUser).mockResolvedValue(null)\n      \n      const res = await app.request('/users/999', {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: 'Test' })\n      })\n      \n      expect(res.status).toBe(404)\n    })\n  })\n  \n  describe('DELETE /users/:id', () => {\n    it('should delete a user', async () => {\n      vi.mocked(db.deleteUser).mockResolvedValue(true)\n      \n      const res = await app.request('/users/1', {\n        method: 'DELETE'\n      })\n      \n      expect(res.status).toBe(204)\n      expect(db.deleteUser).toHaveBeenCalledWith('1')\n    })\n  })\n})\n```\n\n### Authentication Testing\n\n```typescript\n// src/middleware/auth.test.ts\nimport { describe, it, expect, beforeEach, vi } from 'vitest'\nimport { Hono } from 'hono'\nimport { sign } from 'hono/jwt'\nimport { authMiddleware } from './auth'\n\ndescribe('Auth Middleware', () => {\n  let app: Hono\n  \n  beforeEach(() => {\n    app = new Hono()\n    app.use('*', authMiddleware)\n    app.get('/protected', (c) => c.json({ success: true }))\n  })\n  \n  it('should allow access with valid token', async () => {\n    const token = await sign(\n      { sub: 'user123', role: 'user' },\n      'test-secret'\n    )\n    \n    const res = await app.request('/protected', {\n      headers: { Authorization: `Bearer ${token}` }\n    })\n    \n    expect(res.status).toBe(200)\n    const data = await res.json()\n    expect(data).toEqual({ success: true })\n  })\n  \n  it('should deny access without token', async () => {\n    const res = await app.request('/protected')\n    \n    expect(res.status).toBe(401)\n    const error = await res.json()\n    expect(error).toHaveProperty('error')\n  })\n  \n  it('should deny access with invalid token', async () => {\n    const res = await app.request('/protected', {\n      headers: { Authorization: 'Bearer invalid-token' }\n    })\n    \n    expect(res.status).toBe(401)\n  })\n  \n  it('should deny access with expired token', async () => {\n    const token = await sign(\n      { sub: 'user123', exp: Math.floor(Date.now() / 1000) - 3600 },\n      'test-secret'\n    )\n    \n    const res = await app.request('/protected', {\n      headers: { Authorization: `Bearer ${token}` }\n    })\n    \n    expect(res.status).toBe(401)\n  })\n})\n```\n\n### Integration Testing\n\n```typescript\n// tests/integration/workflow.test.ts\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest'\nimport { Hono } from 'hono'\nimport app from '@/app'\nimport { setupTestDatabase, teardownTestDatabase } from '../helpers'\n\ndescribe('User Workflow Integration', () => {\n  let testUserId: string\n  let authToken: string\n  \n  beforeAll(async () => {\n    await setupTestDatabase()\n  })\n  \n  afterAll(async () => {\n    await teardownTestDatabase()\n  })\n  \n  it('should complete full user workflow', async () => {\n    // 1. Register user\n    const registerRes = await app.request('/auth/register', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        email: 'test@example.com',\n        password: 'Test123!',\n        name: 'Test User'\n      })\n    })\n    \n    expect(registerRes.status).toBe(201)\n    const { user, token } = await registerRes.json()\n    testUserId = user.id\n    authToken = token\n    \n    // 2. Login\n    const loginRes = await app.request('/auth/login', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        email: 'test@example.com',\n        password: 'Test123!'\n      })\n    })\n    \n    expect(loginRes.status).toBe(200)\n    \n    // 3. Get profile\n    const profileRes = await app.request('/users/me', {\n      headers: { Authorization: `Bearer ${authToken}` }\n    })\n    \n    expect(profileRes.status).toBe(200)\n    const profile = await profileRes.json()\n    expect(profile.email).toBe('test@example.com')\n    \n    // 4. Update profile\n    const updateRes = await app.request('/users/me', {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${authToken}`\n      },\n      body: JSON.stringify({ name: 'Updated Name' })\n    })\n    \n    expect(updateRes.status).toBe(200)\n    \n    // 5. Delete account\n    const deleteRes = await app.request('/users/me', {\n      method: 'DELETE',\n      headers: { Authorization: `Bearer ${authToken}` }\n    })\n    \n    expect(deleteRes.status).toBe(204)\n    \n    // 6. Verify deletion\n    const verifyRes = await app.request('/users/me', {\n      headers: { Authorization: `Bearer ${authToken}` }\n    })\n    \n    expect(verifyRes.status).toBe(401)\n  })\n})\n```\n\n### Performance Testing\n\n```typescript\n// tests/performance/load.test.ts\nimport { describe, it, expect } from 'vitest'\nimport app from '@/app'\n\ndescribe('Performance Tests', () => {\n  it('should handle concurrent requests', async () => {\n    const requests = Array.from({ length: 100 }, () =>\n      app.request('/health')\n    )\n    \n    const start = performance.now()\n    const responses = await Promise.all(requests)\n    const duration = performance.now() - start\n    \n    expect(responses.every(r => r.status === 200)).toBe(true)\n    expect(duration).toBeLessThan(1000) // Should complete within 1 second\n  })\n  \n  it('should maintain response time under load', async () => {\n    const times: number[] = []\n    \n    for (let i = 0; i < 50; i++) {\n      const start = performance.now()\n      await app.request('/api/data')\n      times.push(performance.now() - start)\n    }\n    \n    const avgTime = times.reduce((a, b) => a + b, 0) / times.length\n    const maxTime = Math.max(...times)\n    \n    expect(avgTime).toBeLessThan(100) // Average under 100ms\n    expect(maxTime).toBeLessThan(500) // Max under 500ms\n  })\n})\n```\n\n### Test Utilities\n\n```typescript\n// tests/helpers/index.ts\nimport { Hono } from 'hono'\nimport { sign } from 'hono/jwt'\n\nexport const createTestApp = () => {\n  const app = new Hono()\n  // Add common test middleware\n  return app\n}\n\nexport const createAuthToken = async (payload: any) => {\n  return sign(\n    { ...payload, exp: Math.floor(Date.now() / 1000) + 3600 },\n    process.env.JWT_SECRET || 'test-secret'\n  )\n}\n\nexport const createMockUser = (overrides = {}) => ({\n  id: 'test-id',\n  email: 'test@example.com',\n  name: 'Test User',\n  role: 'user',\n  createdAt: new Date(),\n  ...overrides\n})\n\nexport const waitFor = (ms: number) => \n  new Promise(resolve => setTimeout(resolve, ms))\n\nexport class TestDatabase {\n  private data = new Map()\n  \n  async get(key: string) {\n    return this.data.get(key)\n  }\n  \n  async set(key: string, value: any) {\n    this.data.set(key, value)\n  }\n  \n  async clear() {\n    this.data.clear()\n  }\n}\n```\n\n### Sources\n\n- [Testing with Hono](https://hono.dev/docs/guides/testing)\n- [Vitest Documentation](https://vitest.dev)\n- [Jest Documentation](https://jestjs.io)"
    },
    {
      "parent": "honojs",
      "id": "typescript",
      "name": "TypeScript",
      "description": "TypeScript configuration and type safety",
      "type": "rule",
      "content": "## TypeScript\n\n### Rules\n\n- TypeScript MUST be used for all Hono.js applications\n- Strict mode MUST be enabled in tsconfig.json\n- Type inference SHOULD be leveraged wherever possible\n- Explicit type annotations SHOULD be used for function parameters and return types\n- Generic types MUST be used for better type safety with Context\n- Custom types MUST be defined in `src/types/` directory\n- Environment variables MUST be typed\n- NEVER use `any` type unless absolutely necessary\n- ALWAYS use type-safe validator outputs\n\n### TypeScript Configuration\n\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2022\"],\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"hono/jsx\",\n    \"moduleResolution\": \"bundler\",\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"resolveJsonModule\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"types\": [\"@cloudflare/workers-types\", \"node\"],\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n### Type-Safe Context Variables\n\n```typescript\n// src/types/index.ts\nexport type Bindings = {\n  DATABASE_URL: string\n  JWT_SECRET: string\n  API_KEY: string\n}\n\nexport type Variables = {\n  userId: string\n  user: {\n    id: string\n    email: string\n    role: 'admin' | 'user'\n  }\n  requestId: string\n}\n\n// src/app.ts\nimport { Hono } from 'hono'\nimport type { Bindings, Variables } from './types'\n\nconst app = new Hono<{ Bindings: Bindings; Variables: Variables }>()\n\n// Now context is fully typed\napp.use('*', async (c, next) => {\n  // c.env.DATABASE_URL is typed as string\n  const dbUrl = c.env.DATABASE_URL\n  \n  // Setting variables with type safety\n  c.set('requestId', crypto.randomUUID())\n  \n  await next()\n})\n\napp.get('/profile', (c) => {\n  // Getting variables with type safety\n  const user = c.get('user') // Typed as { id: string, email: string, role: 'admin' | 'user' }\n  return c.json(user)\n})\n```\n\n### Type-Safe Route Handlers\n\n```typescript\n// Define response types\ntype UserResponse = {\n  id: string\n  name: string\n  email: string\n  createdAt: string\n}\n\ntype ErrorResponse = {\n  error: string\n  code: number\n}\n\n// Type-safe handler with explicit return type\nconst getUser = async (c: Context): Promise<Response> => {\n  const id = c.req.param('id')\n  const user = await findUser(id)\n  \n  if (!user) {\n    return c.json<ErrorResponse>(\n      { error: 'User not found', code: 404 },\n      404\n    )\n  }\n  \n  return c.json<UserResponse>(user)\n}\n\napp.get('/users/:id', getUser)\n```\n\n### Generic Type Patterns\n\n```typescript\n// Generic middleware factory\nfunction createAuthMiddleware<T extends { role: string }>() {\n  return async (c: Context, next: Next) => {\n    const user = await authenticate(c.req.header('Authorization'))\n    if (!user) {\n      throw new HTTPException(401)\n    }\n    c.set('user', user as T)\n    await next()\n  }\n}\n\n// Generic response wrapper\ntype ApiResponse<T> = {\n  success: boolean\n  data?: T\n  error?: string\n  timestamp: string\n}\n\nfunction createResponse<T>(data?: T, error?: string): ApiResponse<T> {\n  return {\n    success: !error,\n    data,\n    error,\n    timestamp: new Date().toISOString()\n  }\n}\n\napp.get('/users', async (c) => {\n  const users = await getUsers()\n  return c.json(createResponse(users))\n})\n```\n\n### Type-Safe Validation\n\n```typescript\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\n\n// Define schema and infer types\nconst userSchema = z.object({\n  name: z.string(),\n  email: z.string().email(),\n  age: z.number().min(18)\n})\n\ntype User = z.infer<typeof userSchema>\n\n// Type-safe route with validation\napp.post('/users',\n  zValidator('json', userSchema),\n  async (c) => {\n    // data is fully typed as User\n    const data = c.req.valid('json')\n    \n    const user = await createUser(data)\n    return c.json<User>(user, 201)\n  }\n)\n```\n\n### Factory Pattern with Types\n\n```typescript\nimport { createFactory } from 'hono/factory'\nimport type { Bindings, Variables } from './types'\n\nconst factory = createFactory<{\n  Bindings: Bindings\n  Variables: Variables\n}>()\n\n// Create typed middleware\nexport const authMiddleware = factory.createMiddleware(async (c, next) => {\n  const token = c.req.header('Authorization')\n  if (!token) {\n    throw new HTTPException(401)\n  }\n  \n  const user = await verifyToken(token, c.env.JWT_SECRET)\n  c.set('user', user)\n  await next()\n})\n\n// Create typed handlers\nexport const getUserHandler = factory.createHandlers(async (c) => {\n  const user = c.get('user') // Fully typed\n  return c.json(user)\n})\n```\n\n### Type-Safe RPC\n\n```typescript\n// server.ts\nimport { Hono } from 'hono'\nimport { zValidator } from '@hono/zod-validator'\nimport { z } from 'zod'\n\nconst app = new Hono()\n\nconst routes = app\n  .get('/users', (c) => c.json({ users: [] }))\n  .get('/users/:id', (c) => c.json({ id: c.req.param('id') }))\n  .post('/users',\n    zValidator('json', z.object({\n      name: z.string(),\n      email: z.string().email()\n    })),\n    (c) => {\n      const user = c.req.valid('json')\n      return c.json(user, 201)\n    }\n  )\n\nexport type AppType = typeof routes\n\n// client.ts\nimport { hc } from 'hono/client'\nimport type { AppType } from './server'\n\nconst client = hc<AppType>('http://localhost:3000')\n\n// Fully typed client calls\nconst response = await client.users.$get()\nconst data = await response.json() // data.users is typed\n\nconst createResponse = await client.users.$post({\n  json: { name: 'John', email: 'john@example.com' }\n})\n```\n\n### Environment Variables Typing\n\n```typescript\n// src/types/env.ts\ndeclare global {\n  namespace NodeJS {\n    interface ProcessEnv {\n      NODE_ENV: 'development' | 'production' | 'test'\n      PORT: string\n      DATABASE_URL: string\n      JWT_SECRET: string\n      API_KEY: string\n    }\n  }\n}\n\n// For Cloudflare Workers\ninterface Env {\n  DATABASE: D1Database\n  KV: KVNamespace\n  R2: R2Bucket\n  JWT_SECRET: string\n}\n\nconst app = new Hono<{ Bindings: Env }>()\n\napp.get('/data', async (c) => {\n  // All bindings are typed\n  const db = c.env.DATABASE\n  const kv = c.env.KV\n  const secret = c.env.JWT_SECRET\n  \n  return c.json({ success: true })\n})\n```\n\n### Utility Types\n\n```typescript\n// Common utility types\ntype Nullable<T> = T | null\ntype Optional<T> = T | undefined\ntype AsyncResponse<T> = Promise<Response | T>\n\n// API types\ntype PaginatedResponse<T> = {\n  data: T[]\n  page: number\n  limit: number\n  total: number\n  hasNext: boolean\n  hasPrev: boolean\n}\n\ntype SortOrder = 'asc' | 'desc'\n\ntype QueryParams = {\n  page?: number\n  limit?: number\n  sort?: string\n  order?: SortOrder\n}\n\n// Database types\ntype Timestamps = {\n  createdAt: Date\n  updatedAt: Date\n}\n\ntype SoftDelete = {\n  deletedAt: Date | null\n}\n\ntype BaseEntity = Timestamps & SoftDelete & {\n  id: string\n}\n\n// User entity example\ninterface User extends BaseEntity {\n  email: string\n  name: string\n  role: 'admin' | 'user'\n}\n```\n\n### Type Guards\n\n```typescript\n// Custom type guards\nfunction isUser(value: unknown): value is User {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'id' in value &&\n    'email' in value &&\n    'role' in value\n  )\n}\n\nfunction isError(value: unknown): value is Error {\n  return value instanceof Error\n}\n\n// Usage in handlers\napp.get('/current-user', async (c) => {\n  const data = c.get('user')\n  \n  if (!isUser(data)) {\n    throw new HTTPException(401, { message: 'Invalid user data' })\n  }\n  \n  // data is now typed as User\n  return c.json(data)\n})\n```\n\n### Sources\n\n- [TypeScript Support](https://hono.dev/docs/getting-started/basic#typescript)\n- [Type Safety Guide](https://hono.dev/docs/guides/typescript)\n- [RPC Mode](https://hono.dev/docs/guides/rpc)"
    },
    {
      "parent": "honojs",
      "id": "validation",
      "name": "Validation",
      "description": "Input validation with Zod and custom validators",
      "type": "rule",
      "content": "## Validation\n\n### Rules\n\n- Input validation MUST be performed using validators\n- Zod SHOULD be used as the primary validation library\n- Validators MUST be applied as middleware before handlers\n- Validation targets include: `json`, `query`, `header`, `param`, `cookie`, and `form`\n- Validation errors MUST return appropriate error messages\n- JSON validation REQUIRES `Content-Type: application/json` header\n- Header names MUST be lowercase when validating\n- Validation schemas MUST be stored in `src/validators/` directory\n- Custom validators MUST return validated and typed data\n\n### Zod Validation\n\n#### Installation\n\n```bash\nnpm install zod @hono/zod-validator\n```\n\n#### Basic Zod Validation\n\n```typescript\n// src/validators/user.ts\nimport { z } from 'zod'\n\nexport const createUserSchema = z.object({\n  name: z.string().min(1).max(100),\n  email: z.string().email(),\n  age: z.number().min(18).max(120),\n  role: z.enum(['user', 'admin']).default('user')\n})\n\nexport const updateUserSchema = createUserSchema.partial()\n\nexport const userQuerySchema = z.object({\n  page: z.coerce.number().min(1).default(1),\n  limit: z.coerce.number().min(1).max(100).default(10),\n  sort: z.enum(['name', 'email', 'createdAt']).optional()\n})\n\nexport type CreateUser = z.infer<typeof createUserSchema>\nexport type UpdateUser = z.infer<typeof updateUserSchema>\n```\n\n#### Using Zod Validator\n\n```typescript\nimport { Hono } from 'hono'\nimport { zValidator } from '@hono/zod-validator'\nimport { createUserSchema, updateUserSchema, userQuerySchema } from './validators/user'\n\nconst app = new Hono()\n\n// JSON body validation\napp.post('/users',\n  zValidator('json', createUserSchema),\n  (c) => {\n    const user = c.req.valid('json')\n    // user is fully typed as CreateUser\n    return c.json({ user }, 201)\n  }\n)\n\n// Query parameter validation\napp.get('/users',\n  zValidator('query', userQuerySchema),\n  (c) => {\n    const { page, limit, sort } = c.req.valid('query')\n    return c.json({ page, limit, sort })\n  }\n)\n\n// Multiple validations\napp.put('/users/:id',\n  zValidator('param', z.object({ id: z.string().uuid() })),\n  zValidator('json', updateUserSchema),\n  (c) => {\n    const { id } = c.req.valid('param')\n    const data = c.req.valid('json')\n    return c.json({ id, ...data })\n  }\n)\n```\n\n### Custom Validators\n\n```typescript\nimport { validator } from 'hono/validator'\n\n// Custom form validation\napp.post('/upload',\n  validator('form', (value, c) => {\n    const { file, description } = value\n    \n    if (!file || typeof file !== 'object') {\n      return c.text('File is required', 400)\n    }\n    \n    if (file.size > 5 * 1024 * 1024) {\n      return c.text('File too large (max 5MB)', 400)\n    }\n    \n    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp']\n    if (!allowedTypes.includes(file.type)) {\n      return c.text('Invalid file type', 400)\n    }\n    \n    return {\n      file,\n      description: description || 'No description'\n    }\n  }),\n  async (c) => {\n    const { file, description } = c.req.valid('form')\n    // Process the validated file\n    return c.json({ uploaded: true })\n  }\n)\n\n// Custom header validation\napp.get('/api/data',\n  validator('header', (value, c) => {\n    const apiKey = value['x-api-key']\n    \n    if (!apiKey) {\n      return c.json({ error: 'API key required' }, 401)\n    }\n    \n    if (!apiKey.startsWith('sk_')) {\n      return c.json({ error: 'Invalid API key format' }, 401)\n    }\n    \n    return { apiKey }\n  }),\n  (c) => {\n    const { apiKey } = c.req.valid('header')\n    return c.json({ authenticated: true })\n  }\n)\n```\n\n### Validation Error Handling\n\n```typescript\nimport { z } from 'zod'\nimport { zValidator } from '@hono/zod-validator'\n\n// Custom error formatting\nconst validationHook = (result: any, c: any) => {\n  if (!result.success) {\n    return c.json(\n      {\n        error: 'Validation failed',\n        details: result.error.flatten()\n      },\n      400\n    )\n  }\n}\n\napp.post('/users',\n  zValidator('json', createUserSchema, validationHook),\n  (c) => {\n    const user = c.req.valid('json')\n    return c.json({ user }, 201)\n  }\n)\n\n// Global error handler for validation\napp.onError((err, c) => {\n  if (err instanceof z.ZodError) {\n    return c.json(\n      {\n        error: 'Validation error',\n        issues: err.issues\n      },\n      400\n    )\n  }\n  return c.json({ error: 'Internal server error' }, 500)\n})\n```\n\n### Complex Validation Scenarios\n\n```typescript\n// Conditional validation\nconst registrationSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n  accountType: z.enum(['personal', 'business']),\n  companyName: z.string().optional()\n}).refine(\n  (data) => {\n    if (data.accountType === 'business' && !data.companyName) {\n      return false\n    }\n    return true\n  },\n  {\n    message: 'Company name is required for business accounts',\n    path: ['companyName']\n  }\n)\n\n// Date validation with transformation\nconst eventSchema = z.object({\n  title: z.string(),\n  startDate: z.string().transform((str) => new Date(str)),\n  endDate: z.string().transform((str) => new Date(str))\n}).refine(\n  (data) => data.endDate > data.startDate,\n  {\n    message: 'End date must be after start date',\n    path: ['endDate']\n  }\n)\n\n// Array validation\nconst bulkCreateSchema = z.object({\n  users: z.array(createUserSchema).min(1).max(100)\n})\n\napp.post('/users/bulk',\n  zValidator('json', bulkCreateSchema),\n  (c) => {\n    const { users } = c.req.valid('json')\n    return c.json({ created: users.length }, 201)\n  }\n)\n```\n\n### Validation Composition\n\n```typescript\n// Reusable validation middleware\nconst paginationValidator = zValidator('query', z.object({\n  page: z.coerce.number().min(1).default(1),\n  limit: z.coerce.number().min(1).max(100).default(10)\n}))\n\nconst authValidator = validator('header', (value, c) => {\n  const token = value['authorization']\n  if (!token?.startsWith('Bearer ')) {\n    return c.json({ error: 'Invalid token' }, 401)\n  }\n  return { token: token.replace('Bearer ', '') }\n})\n\n// Use composed validators\napp.get('/protected/users',\n  authValidator,\n  paginationValidator,\n  (c) => {\n    const { token } = c.req.valid('header')\n    const { page, limit } = c.req.valid('query')\n    return c.json({ page, limit, authenticated: true })\n  }\n)\n```\n\n### Sources\n\n- [Validation Documentation](https://hono.dev/docs/guides/validation)\n- [Zod Validator](https://github.com/honojs/middleware/tree/main/packages/zod-validator)\n- [Zod Documentation](https://zod.dev)"
    },
    {
      "parent": "honojs",
      "id": "websockets",
      "name": "WebSockets",
      "description": "WebSocket handling and real-time features",
      "type": "rule",
      "content": "## WebSockets\n\n### Rules\n\n- WebSocket connections MUST be properly authenticated when required\n- Connection lifecycle events MUST be handled (open, message, close, error)\n- Message validation MUST be implemented for incoming WebSocket messages\n- Connection state MUST be managed efficiently\n- Broadcast mechanisms SHOULD be implemented for multi-client scenarios\n- Rate limiting SHOULD be applied to WebSocket messages\n- Graceful disconnection MUST be handled\n- WebSocket endpoints SHOULD be separate from HTTP routes\n- Memory usage MUST be monitored for long-lived connections\n\n### Basic WebSocket Setup\n\n```typescript\n// src/websocket.ts\nimport { Hono } from 'hono'\nimport { upgradeWebSocket } from 'hono/cloudflare-workers'\n\nconst app = new Hono()\n\n// WebSocket upgrade endpoint\napp.get('/ws',\n  upgradeWebSocket((c) => {\n    return {\n      onOpen(event, ws) {\n        console.log('Connection opened')\n        ws.send('Welcome to the WebSocket server!')\n      },\n      \n      onMessage(event, ws) {\n        const message = event.data.toString()\n        console.log(`Received: ${message}`)\n        \n        // Echo the message back\n        ws.send(`Echo: ${message}`)\n      },\n      \n      onClose(event, ws) {\n        console.log('Connection closed')\n      },\n      \n      onError(event, ws) {\n        console.error('WebSocket error:', event)\n      }\n    }\n  })\n)\n\nexport default app\n```\n\n### Authenticated WebSocket\n\n```typescript\n// src/websocket/auth.ts\nimport { upgradeWebSocket } from 'hono/cloudflare-workers'\nimport { verify } from 'hono/jwt'\n\ninterface ConnectionInfo {\n  userId: string\n  connectedAt: Date\n}\n\nconst connections = new Map<WebSocket, ConnectionInfo>()\n\nexport const authenticatedWebSocket = upgradeWebSocket((c) => {\n  return {\n    async onOpen(event, ws) {\n      try {\n        // Extract token from query parameter or header\n        const url = new URL(c.req.url)\n        const token = url.searchParams.get('token') || \n                     c.req.header('Authorization')?.replace('Bearer ', '')\n        \n        if (!token) {\n          ws.close(1008, 'Authentication required')\n          return\n        }\n        \n        // Verify JWT token\n        const payload = await verify(token, c.env.JWT_SECRET)\n        const userId = payload.sub as string\n        \n        // Store connection info\n        connections.set(ws, {\n          userId,\n          connectedAt: new Date()\n        })\n        \n        console.log(`User ${userId} connected`)\n        ws.send(JSON.stringify({\n          type: 'connected',\n          userId,\n          timestamp: new Date().toISOString()\n        }))\n        \n      } catch (error) {\n        console.error('Authentication failed:', error)\n        ws.close(1008, 'Invalid token')\n      }\n    },\n    \n    onMessage(event, ws) {\n      const connection = connections.get(ws)\n      if (!connection) {\n        ws.close(1008, 'Unauthenticated')\n        return\n      }\n      \n      try {\n        const data = JSON.parse(event.data.toString())\n        handleMessage(ws, connection, data)\n      } catch (error) {\n        ws.send(JSON.stringify({\n          type: 'error',\n          message: 'Invalid JSON'\n        }))\n      }\n    },\n    \n    onClose(event, ws) {\n      const connection = connections.get(ws)\n      if (connection) {\n        console.log(`User ${connection.userId} disconnected`)\n        connections.delete(ws)\n      }\n    },\n    \n    onError(event, ws) {\n      console.error('WebSocket error:', event)\n      connections.delete(ws)\n    }\n  }\n})\n\nasync function handleMessage(\n  ws: WebSocket, \n  connection: ConnectionInfo, \n  data: any\n) {\n  switch (data.type) {\n    case 'ping':\n      ws.send(JSON.stringify({ type: 'pong' }))\n      break\n      \n    case 'chat':\n      await handleChatMessage(ws, connection, data)\n      break\n      \n    default:\n      ws.send(JSON.stringify({\n        type: 'error',\n        message: `Unknown message type: ${data.type}`\n      }))\n  }\n}\n```\n\n### Chat Room Implementation\n\n```typescript\n// src/websocket/chat.ts\nimport { z } from 'zod'\n\ninterface Room {\n  id: string\n  name: string\n  connections: Set<WebSocket>\n  createdAt: Date\n}\n\ninterface User {\n  id: string\n  name: string\n  ws: WebSocket\n}\n\nconst rooms = new Map<string, Room>()\nconst users = new Map<WebSocket, User>()\n\nconst messageSchema = z.object({\n  type: z.literal('chat'),\n  roomId: z.string(),\n  content: z.string().min(1).max(500)\n})\n\nconst joinRoomSchema = z.object({\n  type: z.literal('join'),\n  roomId: z.string(),\n  userName: z.string().min(1).max(50)\n})\n\nexport const chatWebSocket = upgradeWebSocket((c) => {\n  return {\n    onOpen(event, ws) {\n      console.log('Chat client connected')\n    },\n    \n    onMessage(event, ws) {\n      try {\n        const data = JSON.parse(event.data.toString())\n        \n        switch (data.type) {\n          case 'join':\n            handleJoinRoom(ws, joinRoomSchema.parse(data))\n            break\n            \n          case 'chat':\n            handleChatMessage(ws, messageSchema.parse(data))\n            break\n            \n          case 'leave':\n            handleLeaveRoom(ws, data.roomId)\n            break\n            \n          default:\n            ws.send(JSON.stringify({\n              type: 'error',\n              message: 'Unknown message type'\n            }))\n        }\n      } catch (error) {\n        ws.send(JSON.stringify({\n          type: 'error',\n          message: error instanceof z.ZodError \n            ? 'Invalid message format'\n            : 'Message processing failed'\n        }))\n      }\n    },\n    \n    onClose(event, ws) {\n      const user = users.get(ws)\n      if (user) {\n        // Remove user from all rooms\n        for (const room of rooms.values()) {\n          if (room.connections.has(ws)) {\n            room.connections.delete(ws)\n            broadcastToRoom(room.id, {\n              type: 'user-left',\n              userId: user.id,\n              userName: user.name\n            }, ws)\n          }\n        }\n        users.delete(ws)\n      }\n    }\n  }\n})\n\nfunction handleJoinRoom(ws: WebSocket, data: z.infer<typeof joinRoomSchema>) {\n  const { roomId, userName } = data\n  \n  // Create room if it doesn't exist\n  if (!rooms.has(roomId)) {\n    rooms.set(roomId, {\n      id: roomId,\n      name: roomId,\n      connections: new Set(),\n      createdAt: new Date()\n    })\n  }\n  \n  const room = rooms.get(roomId)!\n  const user: User = {\n    id: crypto.randomUUID(),\n    name: userName,\n    ws\n  }\n  \n  // Add user to room and tracking\n  room.connections.add(ws)\n  users.set(ws, user)\n  \n  // Notify user of successful join\n  ws.send(JSON.stringify({\n    type: 'joined',\n    roomId,\n    userId: user.id,\n    userCount: room.connections.size\n  }))\n  \n  // Notify other users\n  broadcastToRoom(roomId, {\n    type: 'user-joined',\n    userId: user.id,\n    userName: user.name,\n    userCount: room.connections.size\n  }, ws)\n}\n\nfunction handleChatMessage(ws: WebSocket, data: z.infer<typeof messageSchema>) {\n  const user = users.get(ws)\n  if (!user) {\n    ws.send(JSON.stringify({\n      type: 'error',\n      message: 'Not in a room'\n    }))\n    return\n  }\n  \n  const { roomId, content } = data\n  const room = rooms.get(roomId)\n  \n  if (!room || !room.connections.has(ws)) {\n    ws.send(JSON.stringify({\n      type: 'error',\n      message: 'Not in this room'\n    }))\n    return\n  }\n  \n  // Broadcast message to all users in room\n  broadcastToRoom(roomId, {\n    type: 'message',\n    roomId,\n    userId: user.id,\n    userName: user.name,\n    content,\n    timestamp: new Date().toISOString()\n  })\n}\n\nfunction handleLeaveRoom(ws: WebSocket, roomId: string) {\n  const user = users.get(ws)\n  const room = rooms.get(roomId)\n  \n  if (room && user && room.connections.has(ws)) {\n    room.connections.delete(ws)\n    \n    // Notify other users\n    broadcastToRoom(roomId, {\n      type: 'user-left',\n      userId: user.id,\n      userName: user.name,\n      userCount: room.connections.size\n    }, ws)\n    \n    // Clean up empty rooms\n    if (room.connections.size === 0) {\n      rooms.delete(roomId)\n    }\n  }\n}\n\nfunction broadcastToRoom(roomId: string, message: any, exclude?: WebSocket) {\n  const room = rooms.get(roomId)\n  if (!room) return\n  \n  const messageStr = JSON.stringify(message)\n  \n  for (const ws of room.connections) {\n    if (ws !== exclude && ws.readyState === WebSocket.OPEN) {\n      try {\n        ws.send(messageStr)\n      } catch (error) {\n        console.error('Failed to send message to client:', error)\n        room.connections.delete(ws)\n      }\n    }\n  }\n}\n```\n\n### Rate Limiting for WebSocket\n\n```typescript\n// src/websocket/rate-limit.ts\ninterface ClientInfo {\n  lastMessage: number\n  messageCount: number\n  banned: boolean\n}\n\nconst clients = new Map<WebSocket, ClientInfo>()\nconst RATE_LIMIT = {\n  maxMessages: 10,\n  windowMs: 60000, // 1 minute\n  banDuration: 300000 // 5 minutes\n}\n\nexport function initRateLimit(ws: WebSocket) {\n  clients.set(ws, {\n    lastMessage: 0,\n    messageCount: 0,\n    banned: false\n  })\n}\n\nexport function checkRateLimit(ws: WebSocket): boolean {\n  const client = clients.get(ws)\n  if (!client) return false\n  \n  const now = Date.now()\n  \n  // Check if client is banned\n  if (client.banned && now - client.lastMessage < RATE_LIMIT.banDuration) {\n    return false\n  }\n  \n  // Reset ban if duration has passed\n  if (client.banned && now - client.lastMessage >= RATE_LIMIT.banDuration) {\n    client.banned = false\n    client.messageCount = 0\n  }\n  \n  // Reset message count if window has passed\n  if (now - client.lastMessage > RATE_LIMIT.windowMs) {\n    client.messageCount = 0\n  }\n  \n  client.messageCount++\n  client.lastMessage = now\n  \n  // Ban if rate limit exceeded\n  if (client.messageCount > RATE_LIMIT.maxMessages) {\n    client.banned = true\n    ws.send(JSON.stringify({\n      type: 'error',\n      message: 'Rate limit exceeded. You are temporarily banned.'\n    }))\n    return false\n  }\n  \n  return true\n}\n\nexport function cleanupRateLimit(ws: WebSocket) {\n  clients.delete(ws)\n}\n```\n\n### Node.js WebSocket Implementation\n\n```typescript\n// src/node-websocket.ts\nimport { Hono } from 'hono'\nimport { createNodeWebSocket } from '@hono/node-ws'\n\nconst { injectWebSocket, upgradeWebSocket } = createNodeWebSocket({ app })\n\nconst app = new Hono()\n\napp.get('/ws', upgradeWebSocket((c) => {\n  return {\n    onOpen(event, ws) {\n      console.log('Connection opened')\n    },\n    \n    onMessage(event, ws) {\n      const message = event.data.toString()\n      ws.send(`Echo: ${message}`)\n    },\n    \n    onClose() {\n      console.log('Connection closed')\n    }\n  }\n}))\n\n// For Node.js server\nimport { serve } from '@hono/node-server'\n\nconst server = serve({\n  fetch: app.fetch,\n  port: 3000\n})\n\ninjectWebSocket(server)\n```\n\n### WebSocket Client (Frontend)\n\n```typescript\n// client/websocket.ts\nexport class WebSocketClient {\n  private ws: WebSocket | null = null\n  private reconnectAttempts = 0\n  private maxReconnectAttempts = 5\n  private reconnectDelay = 1000\n  \n  constructor(\n    private url: string,\n    private token?: string\n  ) {}\n  \n  connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const wsUrl = this.token \n        ? `${this.url}?token=${this.token}`\n        : this.url\n      \n      this.ws = new WebSocket(wsUrl)\n      \n      this.ws.onopen = () => {\n        console.log('WebSocket connected')\n        this.reconnectAttempts = 0\n        resolve()\n      }\n      \n      this.ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data)\n          this.handleMessage(data)\n        } catch (error) {\n          console.error('Failed to parse message:', error)\n        }\n      }\n      \n      this.ws.onclose = (event) => {\n        console.log('WebSocket disconnected:', event.code, event.reason)\n        this.handleReconnect()\n      }\n      \n      this.ws.onerror = (error) => {\n        console.error('WebSocket error:', error)\n        reject(error)\n      }\n    })\n  }\n  \n  private handleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++\n      const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1)\n      \n      console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`)\n      \n      setTimeout(() => {\n        this.connect().catch(console.error)\n      }, delay)\n    } else {\n      console.error('Max reconnection attempts reached')\n    }\n  }\n  \n  send(data: any) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(data))\n    } else {\n      console.error('WebSocket is not connected')\n    }\n  }\n  \n  private handleMessage(data: any) {\n    switch (data.type) {\n      case 'message':\n        this.onMessage?.(data)\n        break\n      case 'user-joined':\n        this.onUserJoined?.(data)\n        break\n      case 'user-left':\n        this.onUserLeft?.(data)\n        break\n      case 'error':\n        this.onError?.(data)\n        break\n    }\n  }\n  \n  // Event handlers (to be overridden)\n  onMessage?: (data: any) => void\n  onUserJoined?: (data: any) => void\n  onUserLeft?: (data: any) => void\n  onError?: (data: any) => void\n  \n  disconnect() {\n    if (this.ws) {\n      this.ws.close()\n      this.ws = null\n    }\n  }\n}\n\n// Usage\nconst client = new WebSocketClient('ws://localhost:3000/ws', 'your-jwt-token')\n\nclient.onMessage = (data) => {\n  console.log('Received message:', data)\n}\n\nclient.onUserJoined = (data) => {\n  console.log('User joined:', data.userName)\n}\n\nawait client.connect()\nclient.send({ type: 'join', roomId: 'general', userName: 'Alice' })\n```\n\n### Sources\n\n- [WebSocket Support](https://hono.dev/docs/helpers/websocket)\n- [Cloudflare Workers WebSocket](https://developers.cloudflare.com/workers/runtime-apis/websockets/)\n- [Node.js WebSocket](https://github.com/honojs/node-ws)"
    }
  ],
  "presets": {
    "minimal": ["honojs:structure", "honojs:routing", "honojs:error-handling"],
    "recommended": [
      "honojs:structure",
      "honojs:routing",
      "honojs:middleware",
      "honojs:validation",
      "honojs:error-handling",
      "honojs:typescript"
    ],
    "full-stack": [
      "honojs:structure",
      "honojs:routing",
      "honojs:middleware",
      "honojs:validation",
      "honojs:error-handling",
      "honojs:typescript",
      "honojs:rpc",
      "honojs:database",
      "honojs:authentication",
      "honojs:testing"
    ],
    "api": [
      "honojs:routing",
      "honojs:validation",
      "honojs:error-handling",
      "honojs:security",
      "honojs:authentication",
      "honojs:performance"
    ],
    "edge": [
      "honojs:structure",
      "honojs:routing",
      "honojs:middleware",
      "honojs:performance",
      "honojs:deployment"
    ]
  }
}
