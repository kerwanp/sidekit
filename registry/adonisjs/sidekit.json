{
  "$schema": "https://raw.githubusercontent.com/kerwanp/sidekit/refs/heads/main/schemas/kit.json",
  "name": "AdonisJS",
  "description": "Comprehensive rules for AdonisJS 6 development",
  "rules": [
    {
      "parent": "adonisjs",
      "id": "api",
      "name": "API Development",
      "description": "Guidelines for building RESTful APIs with AdonisJS 6",
      "type": "rule",
      "content": "## API Development Patterns\n\n### RESTful API Structure\n\nFollow RESTful conventions for API design:\n\n```typescript\n// start/routes.ts - API Routes\nimport router from \"@adonisjs/core/services/router\";\nimport { middleware } from \"./kernel.js\";\n\n// ✅ API versioning\nrouter\n  .group(() => {\n    // ✅ Resource-based routes\n    router.resource(\"users\", \"#controllers/api/v1/users_controller\").apiOnly();\n    router.resource(\"posts\", \"#controllers/api/v1/posts_controller\").apiOnly();\n    router\n      .resource(\"posts.comments\", \"#controllers/api/v1/comments_controller\")\n      .apiOnly();\n\n    // ✅ Custom actions\n    router.post(\n      \"users/:id/activate\",\n      \"#controllers/api/v1/users_controller.activate\",\n    );\n    router.post(\n      \"posts/:id/publish\",\n      \"#controllers/api/v1/posts_controller.publish\",\n    );\n    router.get(\n      \"posts/:id/related\",\n      \"#controllers/api/v1/posts_controller.related\",\n    );\n  })\n  .prefix(\"api/v1\")\n  .middleware([\n    middleware.auth({ guards: [\"api\"] }),\n    middleware.throttle({ max: 1000, duration: \"1h\" }),\n  ]);\n\n// ✅ Public API routes\nrouter\n  .group(() => {\n    router.get(\"posts\", \"#controllers/api/v1/posts_controller.index\");\n    router.get(\"posts/:id\", \"#controllers/api/v1/posts_controller.show\");\n    router.get(\"categories\", \"#controllers/api/v1/categories_controller.index\");\n  })\n  .prefix(\"api/v1/public\")\n  .middleware([middleware.throttle({ max: 100, duration: \"1h\" })]);\n```\n\n### API Controller Base Class\n\n```typescript\n// app/controllers/api/base_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\n\nexport default class BaseApiController {\n  // ✅ Success response\n  protected successResponse(\n    ctx: HttpContext,\n    data: any,\n    message?: string,\n    statusCode: number = 200,\n  ) {\n    return ctx.response.status(statusCode).json({\n      success: true,\n      data,\n      message,\n    });\n  }\n\n  // ✅ Error response\n  protected errorResponse(\n    ctx: HttpContext,\n    message: string,\n    statusCode: number = 400,\n  ) {\n    return ctx.response.status(statusCode).json({\n      success: false,\n      error: message,\n    });\n  }\n\n  // ✅ Pagination parameters\n  protected getPaginationParams(ctx: HttpContext) {\n    const page = Math.max(1, parseInt(ctx.request.input(\"page\", \"1\")));\n    const limit = Math.min(100, parseInt(ctx.request.input(\"limit\", \"20\")));\n    return { page, limit };\n  }\n}\n```\n\n### API Resource Controllers\n\n```typescript\n// app/controllers/api/v1/users_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport BaseApiController from \"#controllers/api/base_controller\";\nimport User from \"#models/user\";\nimport {\n  createUserValidator,\n  updateUserValidator,\n} from \"#validators/user_validator\";\n\nexport default class UsersController extends BaseApiController {\n  // ✅ GET /api/v1/users\n  async index({ request, response }: HttpContext) {\n    const { page, limit } = this.getPaginationParams({\n      request,\n    } as HttpContext);\n    const users = await User.query().paginate(page, limit);\n\n    return this.successResponse(\n      { response } as HttpContext,\n      users,\n      \"Users retrieved successfully\",\n    );\n  }\n\n  // ✅ GET /api/v1/users/:id\n  async show({ params, response }: HttpContext) {\n    const user = await User.findOrFail(params.id);\n\n    return this.successResponse(\n      { response } as HttpContext,\n      user,\n      \"User retrieved successfully\",\n    );\n  }\n\n  // ✅ POST /api/v1/users\n  async store({ request, response }: HttpContext) {\n    const data = await request.validateUsing(createUserValidator);\n    const user = await User.create(data);\n\n    return this.successResponse(\n      { response } as HttpContext,\n      user,\n      \"User created successfully\",\n      201,\n    );\n  }\n\n  // ✅ PUT /api/v1/users/:id\n  async update({ params, request, response }: HttpContext) {\n    const user = await User.findOrFail(params.id);\n    const data = await request.validateUsing(updateUserValidator);\n    await user.merge(data).save();\n\n    return this.successResponse(\n      { response } as HttpContext,\n      user,\n      \"User updated successfully\",\n    );\n  }\n\n  // ✅ DELETE /api/v1/users/:id\n  async destroy({ params, response }: HttpContext) {\n    const user = await User.findOrFail(params.id);\n    await user.delete();\n\n    return this.successResponse(\n      { response } as HttpContext,\n      null,\n      \"User deleted successfully\",\n    );\n  }\n}\n```\n\n### API Serialization\n\n```typescript\n// app/serializers/user_serializer.ts\nexport default class UserSerializer {\n  // ✅ Transform user data for API responses\n  static serialize(user: any) {\n    return {\n      id: user.id,\n      email: user.email,\n      name: user.fullName,\n      role: user.role,\n      isActive: user.isActive,\n      createdAt: user.createdAt,\n      updatedAt: user.updatedAt,\n    };\n  }\n\n  // ✅ Serialize collection\n  static serializeCollection(users: any[]) {\n    return users.map((user) => this.serialize(user));\n  }\n\n  // ✅ Public user data\n  static serializeForPublic(user: any) {\n    return {\n      id: user.id,\n      name: user.fullName,\n    };\n  }\n}\n```\n\n### API Validation\n\n```typescript\n// app/validators/api/user_validator.ts\nimport vine from \"@vinejs/vine\";\n\n// ✅ API-specific validators\nexport const createUserApiValidator = vine.compile(\n  vine.object({\n    email: vine.string().email().normalizeEmail(),\n    password: vine.string().minLength(8).maxLength(32),\n    fullName: vine.string().minLength(2).maxLength(100),\n    role: vine.enum([\"user\", \"admin\", \"moderator\"]).optional(),\n    metadata: vine\n      .object({\n        source: vine.string().optional(),\n        referrer: vine.string().optional(),\n        utm: vine\n          .object({\n            source: vine.string().optional(),\n            medium: vine.string().optional(),\n            campaign: vine.string().optional(),\n          })\n          .optional(),\n      })\n      .optional(),\n  }),\n);\n\nexport const updateUserApiValidator = vine.compile(\n  vine.object({\n    email: vine.string().email().normalizeEmail().optional(),\n    fullName: vine.string().minLength(2).maxLength(100).optional(),\n    role: vine.enum([\"user\", \"admin\", \"moderator\"]).optional(),\n    isActive: vine.boolean().optional(),\n  }),\n);\n\nexport const bulkActionValidator = vine.compile(\n  vine.object({\n    ids: vine.array(vine.number().positive()).minLength(1).maxLength(100),\n    action: vine.enum([\"activate\", \"deactivate\", \"delete\"]),\n  }),\n);\n```\n\n### API Middleware\n\n```typescript\n// app/middleware/api_version_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\n\nexport default class ApiVersionMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    const { request, response } = ctx;\n\n    // ✅ API version from header or URL\n    const version =\n      request.header(\"api-version\") ||\n      request.url().match(/\\/api\\/(v\\d+)\\//)?.[1] ||\n      \"v1\";\n\n    // Add version to context\n    ctx.apiVersion = version;\n\n    // ✅ Set API response headers\n    response.header(\"API-Version\", version);\n    response.header(\"Content-Type\", \"application/json\");\n    response.header(\"X-RateLimit-Limit\", \"1000\");\n    response.header(\"X-RateLimit-Window\", \"1h\");\n\n    return await next();\n  }\n}\n```\n\n### API Rate Limiting\n\n```typescript\n// app/middleware/api_rate_limit_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\nimport redis from \"@adonisjs/redis/services/main\";\n\nexport default class ApiRateLimitMiddleware {\n  async handle(\n    ctx: HttpContext,\n    next: NextFn,\n    options: { maxRequests: number; windowMs: number },\n  ) {\n    const { request, response } = ctx;\n\n    const key = `rate_limit:${request.ip()}`;\n    const current = await redis.get(key);\n    const requests = current ? parseInt(current) : 0;\n\n    if (requests >= options.maxRequests) {\n      response.header(\"X-RateLimit-Limit\", options.maxRequests.toString());\n      response.header(\"X-RateLimit-Remaining\", \"0\");\n\n      return response.status(429).json({\n        success: false,\n        error: \"Rate limit exceeded\",\n      });\n    }\n\n    // Increment counter\n    await redis.incr(key);\n    await redis.expire(key, Math.ceil(options.windowMs / 1000));\n\n    // Add headers\n    response.header(\"X-RateLimit-Limit\", options.maxRequests.toString());\n    response.header(\n      \"X-RateLimit-Remaining\",\n      (options.maxRequests - requests - 1).toString(),\n    );\n\n    return await next();\n  }\n}\n```\n\n### API Documentation\n\n```typescript\n// app/controllers/api/docs_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\n\nexport default class DocsController {\n  // ✅ Basic API documentation\n  async index({ response }: HttpContext) {\n    const spec = {\n      openapi: \"3.0.0\",\n      info: {\n        title: \"My API\",\n        version: \"1.0.0\",\n      },\n      paths: {\n        \"/users\": {\n          get: {\n            summary: \"List users\",\n            responses: {\n              200: {\n                description: \"Users retrieved successfully\",\n              },\n            },\n          },\n        },\n      },\n    };\n\n    return response.json(spec);\n  }\n}\n```\n\n### API Testing\n\n```typescript\n// tests/functional/api/users.spec.ts\nimport { test } from \"@japa/runner\";\nimport { UserFactory } from \"#factories/user_factory\";\n\ntest.group(\"Users API\", () => {\n  test(\"GET /api/v1/users should return paginated users\", async ({\n    client,\n  }) => {\n    await UserFactory.createMany(25);\n\n    const response = await client\n      .get(\"/api/v1/users\")\n      .header(\"Authorization\", \"Bearer valid-token\")\n      .qs({ page: 1, limit: 10 });\n\n    response.assertStatus(200);\n    response.assertBodyContains({\n      success: true,\n      data: (users: any[]) => users.length === 10,\n      meta: {\n        pagination: {\n          currentPage: 1,\n          perPage: 10,\n          total: 25,\n        },\n      },\n    });\n  });\n\n  test(\"POST /api/v1/users should create user with valid data\", async ({\n    client,\n  }) => {\n    const userData = {\n      email: \"test@example.com\",\n      password: \"password123\",\n      fullName: \"Test User\",\n    };\n\n    const response = await client\n      .post(\"/api/v1/users\")\n      .header(\"Authorization\", \"Bearer admin-token\")\n      .json(userData);\n\n    response.assertStatus(201);\n    response.assertBodyContains({\n      success: true,\n      data: {\n        email: userData.email,\n        name: userData.fullName,\n      },\n      message: \"User created successfully\",\n    });\n  });\n\n  test(\"should handle rate limiting\", async ({ client }) => {\n    // Make requests up to the limit\n    for (let i = 0; i < 100; i++) {\n      await client\n        .get(\"/api/v1/users\")\n        .header(\"Authorization\", \"Bearer valid-token\");\n    }\n\n    // This request should be rate limited\n    const response = await client\n      .get(\"/api/v1/users\")\n      .header(\"Authorization\", \"Bearer valid-token\");\n\n    response.assertStatus(429);\n    response.assertBodyContains({\n      success: false,\n      error: {\n        code: \"RATE_LIMIT_EXCEEDED\",\n      },\n    });\n  });\n});\n```\n\n### API Best Practices\n\n#### DO's\n\n```typescript\n// ✅ Use proper HTTP methods\nrouter.get('users', 'UsersController.index')       // List\nrouter.post('users', 'UsersController.store')      // Create\nrouter.get('users/:id', 'UsersController.show')    // Read\nrouter.put('users/:id', 'UsersController.update')  // Update\nrouter.delete('users/:id', 'UsersController.destroy') // Delete\n\n// ✅ Use consistent response format\n{\n  \"success\": true,\n  \"data\": { ... },\n  \"message\": \"Operation successful\",\n  \"meta\": { ... }\n}\n\n// ✅ Include pagination metadata\n{\n  \"data\": [...],\n  \"meta\": {\n    \"pagination\": {\n      \"currentPage\": 1,\n      \"perPage\": 20,\n      \"total\": 100,\n      \"lastPage\": 5\n    }\n  }\n}\n\n// ✅ Use proper status codes\n201 // Created\n200 // Success\n404 // Not Found\n422 // Validation Error\n429 // Rate Limited\n```\n\n#### DON'Ts\n\n```typescript\n// ❌ Inconsistent response formats\n{ \"users\": [...] }  // Sometimes\n{ \"data\": [...] }   // Other times\n\n// ❌ Exposing sensitive data\n{\n  \"user\": {\n    \"password\": \"hashed_password\",\n    \"secret_key\": \"sensitive_data\"\n  }\n}\n\n// ❌ Not handling edge cases\n// Missing pagination, error handling, validation\n\n// ❌ Poor endpoint naming\nPOST /api/getUserById\nGET /api/createUser\n```\n\n### Sources\n\n- [AdonisJS API Development](https://docs.adonisjs.com/guides/controllers#api-controllers)\n- [RESTful API Design](https://restfulapi.net/)\n- [OpenAPI Specification](https://swagger.io/specification/)\n- [HTTP Status Codes](https://httpstatuses.com/)\n"
    },
    {
      "parent": "adonisjs",
      "id": "auth",
      "name": "Authentication",
      "description": "Guidelines for authentication and authorization in AdonisJS 6",
      "type": "rule",
      "content": "## Authentication and Authorization\n\n### Authentication Setup\n\nInstall the auth package and configure guards:\n\n```bash\nnode ace add @adonisjs/auth --guard=session\n# or\nnode ace add @adonisjs/auth --guard=access_tokens\n```\n\n### Authentication Configuration\n\n```typescript\n// config/auth.ts\nimport { defineConfig } from \"@adonisjs/auth\";\nimport { sessionGuard, sessionUserProvider } from \"@adonisjs/auth/session\";\nimport {\n  accessTokensGuard,\n  accessTokensUserProvider,\n} from \"@adonisjs/auth/access_tokens\";\n\nconst authConfig = defineConfig({\n  default: \"web\",\n  guards: {\n    // ✅ Session-based authentication for web apps\n    web: sessionGuard({\n      provider: sessionUserProvider({\n        model: () => import(\"#models/user\"),\n      }),\n    }),\n\n    // ✅ Token-based authentication for APIs\n    api: accessTokensGuard({\n      provider: accessTokensUserProvider({\n        model: () => import(\"#models/user\"),\n        tokens: \"accessTokens\",\n      }),\n    }),\n  },\n});\n\nexport default authConfig;\n```\n\n### User Model for Authentication\n\n```typescript\n// app/models/user.ts\nimport { DateTime } from \"luxon\";\nimport hash from \"@adonisjs/core/services/hash\";\nimport { compose } from \"@adonisjs/core/helpers\";\nimport { BaseModel, column, beforeSave } from \"@adonisjs/lucid/orm\";\nimport { withAuthFinder } from \"@adonisjs/auth/mixins/lucid\";\nimport { DbAccessTokensProvider } from \"@adonisjs/auth/access_tokens\";\n\nconst AuthFinder = withAuthFinder(() => hash.use(\"scrypt\"), {\n  uids: [\"email\"],\n  passwordColumnName: \"password\",\n});\n\nexport default class User extends compose(BaseModel, AuthFinder) {\n  @column({ isPrimary: true })\n  declare id: number;\n\n  @column()\n  declare email: string;\n\n  @column()\n  declare fullName: string;\n\n  @column({ serializeAs: null })\n  declare password: string;\n\n  @column()\n  declare role: string;\n\n  @column.dateTime({ autoCreate: true })\n  declare createdAt: DateTime;\n\n  @column.dateTime({ autoCreate: true, autoUpdate: true })\n  declare updatedAt: DateTime;\n\n  // ✅ For access tokens authentication\n  static accessTokens = DbAccessTokensProvider.forModel(User);\n\n  // ✅ Password hashing\n  @beforeSave()\n  static async hashPassword(user: User) {\n    if (user.$dirty.password) {\n      user.password = await hash.make(user.password);\n    }\n  }\n\n  // ✅ Password verification\n  async verifyPassword(plainPassword: string) {\n    return await hash.verify(this.password, plainPassword);\n  }\n}\n```\n\n### Authentication Controller\n\n```typescript\n// app/controllers/auth_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport User from \"#models/user\";\nimport { loginValidator, registerValidator } from \"#validators/auth_validator\";\n\nexport default class AuthController {\n  // ✅ Session-based login\n  async login({ request, response, auth }: HttpContext) {\n    const { email, password } = await request.validateUsing(loginValidator);\n\n    try {\n      const user = await User.verifyCredentials(email, password);\n      await auth.use(\"web\").login(user);\n\n      return response.json({\n        message: \"Login successful\",\n        user: {\n          id: user.id,\n          email: user.email,\n          fullName: user.fullName,\n          role: user.role,\n        },\n      });\n    } catch {\n      return response.unauthorized({\n        error: \"Invalid credentials\",\n      });\n    }\n  }\n\n  // ✅ API token-based login\n  async apiLogin({ request, response }: HttpContext) {\n    const { email, password } = await request.validateUsing(loginValidator);\n\n    try {\n      const user = await User.verifyCredentials(email, password);\n      const token = await User.accessTokens.create(user, [\"*\"], {\n        expiresIn: \"30 days\",\n      });\n\n      return response.json({\n        message: \"Login successful\",\n        user: {\n          id: user.id,\n          email: user.email,\n          fullName: user.fullName,\n          role: user.role,\n        },\n        token: {\n          type: \"Bearer\",\n          value: token.value!.release(),\n        },\n      });\n    } catch {\n      return response.unauthorized({\n        error: \"Invalid credentials\",\n      });\n    }\n  }\n\n  // ✅ User registration\n  async register({ request, response }: HttpContext) {\n    const data = await request.validateUsing(registerValidator);\n\n    try {\n      const user = await User.create({\n        ...data,\n        role: \"user\", // Default role\n      });\n\n      return response.status(201).json({\n        message: \"Registration successful\",\n        user: {\n          id: user.id,\n          email: user.email,\n          fullName: user.fullName,\n          role: user.role,\n        },\n      });\n    } catch (error) {\n      if (error.code === \"23505\") {\n        // Unique constraint violation\n        return response.conflict({\n          error: \"Email already registered\",\n        });\n      }\n      throw error;\n    }\n  }\n\n  // ✅ Session logout\n  async logout({ response, auth }: HttpContext) {\n    await auth.use(\"web\").logout();\n    return response.json({\n      message: \"Logout successful\",\n    });\n  }\n\n  // ✅ API token logout\n  async apiLogout({ response, auth }: HttpContext) {\n    const user = auth.getUserOrFail();\n    const token = auth.use(\"api\").tokenOrFail();\n\n    await User.accessTokens.delete(user, token.identifier);\n\n    return response.json({\n      message: \"Logout successful\",\n    });\n  }\n\n  // ✅ Get current user profile\n  async me({ response, auth }: HttpContext) {\n    const user = auth.getUserOrFail();\n\n    return response.json({\n      user: {\n        id: user.id,\n        email: user.email,\n        fullName: user.fullName,\n        role: user.role,\n        createdAt: user.createdAt,\n        updatedAt: user.updatedAt,\n      },\n    });\n  }\n}\n```\n\n### Authentication Validators\n\n```typescript\n// app/validators/auth_validator.ts\nimport vine from \"@vinejs/vine\";\n\nexport const loginValidator = vine.compile(\n  vine.object({\n    email: vine.string().email().normalizeEmail(),\n    password: vine.string().minLength(1),\n    rememberMe: vine.boolean().optional(),\n  }),\n);\n\nexport const registerValidator = vine.compile(\n  vine.object({\n    email: vine.string().email().normalizeEmail(),\n    password: vine.string().minLength(8).maxLength(32).confirmed(),\n    fullName: vine.string().minLength(2).maxLength(100),\n    agreeToTerms: vine.boolean().isTrue(),\n  }),\n);\n\nexport const changePasswordValidator = vine.compile(\n  vine.object({\n    currentPassword: vine.string(),\n    password: vine.string().minLength(8).confirmed(),\n  }),\n);\n```\n\n### Authentication Middleware\n\n```typescript\n// app/middleware/auth_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\n\nexport default class AuthMiddleware {\n  async handle(\n    ctx: HttpContext,\n    next: NextFn,\n    options: { guards?: string[] } = {},\n  ) {\n    const guards = options.guards || [\"web\"];\n\n    for (const guard of guards) {\n      try {\n        await ctx.auth.use(guard).check();\n        if (ctx.auth.use(guard).isAuthenticated) {\n          return await next();\n        }\n      } catch {\n        // Continue to next guard\n      }\n    }\n\n    return ctx.response.unauthorized({\n      error: \"Authentication required\",\n    });\n  }\n}\n```\n\n### Authorization Patterns\n\n#### Role-Based Access Control\n\n```typescript\n// app/middleware/role_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\n\nexport default class RoleMiddleware {\n  async handle(ctx: HttpContext, next: NextFn, options: { roles: string[] }) {\n    const user = ctx.auth.getUserOrFail();\n\n    if (!options.roles.includes(user.role)) {\n      return ctx.response.forbidden({\n        error: \"Insufficient permissions\",\n      });\n    }\n\n    return await next();\n  }\n}\n\n// Usage in routes\nrouter\n  .group(() => {\n    router.get(\"admin/users\", \"#controllers/admin/users_controller.index\");\n  })\n  .middleware([middleware.auth(), middleware.role({ roles: [\"admin\"] })]);\n```\n\n#### Policy-Based Authorization\n\n```typescript\n// app/policies/post_policy.ts\nimport User from \"#models/user\";\nimport Post from \"#models/post\";\n\nexport default class PostPolicy {\n  static async canUpdate(user: User, post: Post) {\n    return user.role === \"admin\" || post.userId === user.id;\n  }\n\n  static async canDelete(user: User, post: Post) {\n    return user.role === \"admin\" || post.userId === user.id;\n  }\n}\n\n// Usage in controller\nexport default class PostsController {\n  async update({ params, request, response, auth }: HttpContext) {\n    const user = auth.getUserOrFail();\n    const post = await Post.findOrFail(params.id);\n\n    if (!(await PostPolicy.canUpdate(user, post))) {\n      return response.forbidden({\n        error: \"Not authorized to update this post\",\n      });\n    }\n\n    const data = await request.validateUsing(updatePostValidator);\n    await post.merge(data).save();\n\n    return response.json({ data: post });\n  }\n}\n```\n\n### Password Management\n\n```typescript\n// app/controllers/password_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport User from \"#models/user\";\nimport { changePasswordValidator } from \"#validators/auth_validator\";\n\nexport default class PasswordController {\n  // ✅ Change password for authenticated user\n  async change({ request, response, auth }: HttpContext) {\n    const user = auth.getUserOrFail();\n    const { currentPassword, password } = await request.validateUsing(\n      changePasswordValidator,\n    );\n\n    // Verify current password\n    if (!(await user.verifyPassword(currentPassword))) {\n      return response.badRequest({\n        error: \"Current password is incorrect\",\n      });\n    }\n\n    // Update password\n    user.password = password;\n    await user.save();\n\n    return response.json({\n      message: \"Password changed successfully\",\n    });\n  }\n\n  // ✅ Request password reset\n  async requestReset({ request, response }: HttpContext) {\n    const { email } = await request.validateUsing(\n      vine.compile(\n        vine.object({\n          email: vine.string().email().normalizeEmail(),\n        }),\n      ),\n    );\n\n    const user = await User.findBy(\"email\", email);\n    if (!user) {\n      return response.json({\n        message: \"If the email exists, a reset link has been sent\",\n      });\n    }\n\n    // Generate and send reset token\n    // Implementation depends on your requirements\n\n    return response.json({\n      message: \"Password reset link sent\",\n    });\n  }\n}\n```\n\n### API Authentication Routes\n\n```typescript\n// start/routes.ts\nimport router from \"@adonisjs/core/services/router\";\nimport { middleware } from \"./kernel.js\";\n\n// ✅ Public authentication routes\nrouter\n  .group(() => {\n    router.post(\"login\", \"#controllers/auth_controller.login\");\n    router.post(\"register\", \"#controllers/auth_controller.register\");\n    router.post(\n      \"forgot-password\",\n      \"#controllers/password_controller.requestReset\",\n    );\n    router.post(\"reset-password\", \"#controllers/password_controller.reset\");\n  })\n  .prefix(\"auth\");\n\n// ✅ API routes with token authentication\nrouter\n  .group(() => {\n    router.post(\"login\", \"#controllers/auth_controller.apiLogin\");\n    router.post(\"logout\", \"#controllers/auth_controller.apiLogout\");\n    router.get(\"me\", \"#controllers/auth_controller.me\");\n    router.put(\"password\", \"#controllers/password_controller.change\");\n  })\n  .prefix(\"api/auth\")\n  .middleware([middleware.auth({ guards: [\"api\"] })]);\n\n// ✅ Protected API routes\nrouter\n  .group(() => {\n    router.resource(\"posts\", \"#controllers/posts_controller\").apiOnly();\n    router.resource(\"comments\", \"#controllers/comments_controller\").apiOnly();\n  })\n  .prefix(\"api/v1\")\n  .middleware([middleware.auth({ guards: [\"api\"] })]);\n```\n\n### Testing Authentication\n\n```typescript\n// tests/functional/auth.spec.ts\nimport { test } from \"@japa/runner\";\nimport User from \"#models/user\";\n\ntest.group(\"Authentication\", () => {\n  test(\"should login with valid credentials\", async ({ client, assert }) => {\n    const user = await User.create({\n      email: \"test@example.com\",\n      password: \"password123\",\n      fullName: \"Test User\",\n      role: \"user\",\n    });\n\n    const response = await client.post(\"/auth/login\").json({\n      email: \"test@example.com\",\n      password: \"password123\",\n    });\n\n    response.assertStatus(200);\n    response.assertBodyContains({\n      message: \"Login successful\",\n      user: {\n        email: \"test@example.com\",\n      },\n    });\n  });\n\n  test(\"should reject invalid credentials\", async ({ client }) => {\n    const response = await client.post(\"/auth/login\").json({\n      email: \"test@example.com\",\n      password: \"wrong-password\",\n    });\n\n    response.assertStatus(401);\n    response.assertBodyContains({\n      error: \"Invalid credentials\",\n    });\n  });\n\n  test(\"should access protected route with token\", async ({ client }) => {\n    const user = await User.create({\n      email: \"test@example.com\",\n      password: \"password123\",\n      fullName: \"Test User\",\n      role: \"user\",\n    });\n\n    const token = await User.accessTokens.create(user);\n\n    const response = await client\n      .get(\"/api/auth/me\")\n      .header(\"Authorization\", `Bearer ${token.value!.release()}`);\n\n    response.assertStatus(200);\n    response.assertBodyContains({\n      user: {\n        email: \"test@example.com\",\n      },\n    });\n  });\n});\n```\n\n### Authentication Best Practices\n\n#### DO's\n\n- ALWAYS hash passwords using the built-in hash service\n- ALWAYS validate credentials before creating sessions/tokens\n- ALWAYS use HTTPS in production for session-based auth\n- ALWAYS set appropriate token expiration times\n- ALWAYS implement rate limiting on auth endpoints\n- ALWAYS use secure session configuration\n- ALWAYS validate and sanitize user input\n\n#### DON'Ts\n\n```typescript\n// ❌ Incorrect: Plain text password storage\nuser.password = plainPassword;\n\n// ❌ Incorrect: Revealing user existence\nif (!user) {\n  return response.notFound({ error: \"User not found\" });\n}\n\n// ❌ Incorrect: Not using auth middleware\nrouter.get(\"profile\", \"#controllers/users_controller.profile\"); // No auth\n\n// ❌ Incorrect: Exposing sensitive data\nreturn response.json({ user }); // Includes password hash\n\n// ❌ Incorrect: Weak password requirements\npassword: vine.string().minLength(4); // Too weak\n```\n\n### Sources\n\n- [Authentication Documentation](https://docs.adonisjs.com/guides/authentication)\n- [Session Guard](https://docs.adonisjs.com/guides/authentication#session-guard)\n- [Access Tokens Guard](https://docs.adonisjs.com/guides/authentication#access-tokens-guard)\n- [Authorization Patterns](https://docs.adonisjs.com/guides/authorization)\n"
    },
    {
      "parent": "adonisjs",
      "id": "commands",
      "name": "Commands",
      "description": "Guidelines for CLI command development in AdonisJS 6",
      "type": "rule",
      "content": "## CLI Command Development\n\n### Creating Commands\n\nCommands MUST be created using the Ace CLI and placed in `app/commands/`:\n\n```bash\n# Create a new command\nnode ace make:command CreateUser\n```\n\n### Command Structure\n\n```typescript\n// app/commands/create_user.ts\nimport { BaseCommand, args, flags } from \"@adonisjs/core/ace\";\nimport type { CommandOptions } from \"@adonisjs/core/types/ace\";\nimport User from \"#models/user\";\nimport hash from \"@adonisjs/core/services/hash\";\n\nexport default class CreateUser extends BaseCommand {\n  static commandName = \"user:create\";\n  static description = \"Create a new user account\";\n\n  // ✅ Define command arguments\n  @args.string({ description: \"User email address\" })\n  declare email: string;\n\n  @args.string({ description: \"User full name\" })\n  declare fullName: string;\n\n  // ✅ Define command flags\n  @flags.string({\n    description: \"User password (will prompt if not provided)\",\n    alias: \"p\",\n  })\n  declare password?: string;\n\n  @flags.string({\n    description: \"User role\",\n    default: \"user\",\n  })\n  declare role: string;\n\n  @flags.boolean({\n    description: \"Activate user immediately\",\n    default: false,\n  })\n  declare active: boolean;\n\n  @flags.boolean({\n    description: \"Force creation even if user exists\",\n    default: false,\n  })\n  declare force: boolean;\n\n  static options: CommandOptions = {\n    startApp: true,\n    allowUnknownFlags: false,\n    staysAlive: false,\n  };\n\n  async run(): Promise<void> {\n    const { email, fullName, role, active, force } = this;\n\n    try {\n      // ✅ Validation\n      if (!this.isValidEmail(email)) {\n        this.logger.error(\"Invalid email address provided\");\n        this.exitCode = 1;\n        return;\n      }\n\n      // ✅ Check if user exists\n      const existingUser = await User.findBy(\"email\", email);\n      if (existingUser && !force) {\n        this.logger.error(\n          `User with email ${email} already exists. Use --force to override.`,\n        );\n        this.exitCode = 1;\n        return;\n      }\n\n      // ✅ Get password\n      let password = this.password;\n      if (!password) {\n        password = await this.prompt.secure(\"Enter password\");\n      }\n\n      if (password.length < 8) {\n        this.logger.error(\"Password must be at least 8 characters long\");\n        this.exitCode = 1;\n        return;\n      }\n\n      // ✅ Create or update user\n      let user: User;\n\n      if (existingUser && force) {\n        user = existingUser;\n        user.merge({\n          fullName,\n          password: await hash.make(password),\n          role,\n          isActive: active,\n        });\n        await user.save();\n        this.logger.success(`User ${email} updated successfully`);\n      } else {\n        user = await User.create({\n          email,\n          fullName,\n          password: await hash.make(password),\n          role,\n          isActive: active,\n        });\n        this.logger.success(`User ${email} created successfully`);\n      }\n\n      // ✅ Display user information\n      this.logger.info(\"User details:\");\n      const table = this.ui.table();\n      table.head([\"Field\", \"Value\"]);\n      table.row([\"ID\", user.id.toString()]);\n      table.row([\"Email\", user.email]);\n      table.row([\"Name\", user.fullName]);\n      table.row([\"Role\", user.role]);\n      table.row([\"Active\", user.isActive ? \"Yes\" : \"No\"]);\n      table.row([\"Created\", user.createdAt.toLocaleString()]);\n      table.render();\n    } catch (error) {\n      this.logger.error(`Failed to create user: ${error.message}`);\n      this.exitCode = 1;\n    }\n  }\n\n  private isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n}\n```\n\n### Database Commands\n\n```typescript\n// app/commands/database_seed.ts\nimport { BaseCommand, flags } from \"@adonisjs/core/ace\";\nimport type { CommandOptions } from \"@adonisjs/core/types/ace\";\nimport Database from \"@adonisjs/lucid/services/db\";\nimport { UserFactory } from \"#factories/user_factory\";\nimport { PostFactory } from \"#factories/post_factory\";\n\nexport default class DatabaseSeed extends BaseCommand {\n  static commandName = \"db:seed\";\n  static description = \"Seed the database with sample data\";\n\n  @flags.number({\n    description: \"Number of users to create\",\n    default: 10,\n  })\n  declare users: number;\n\n  @flags.number({\n    description: \"Number of posts per user\",\n    default: 5,\n  })\n  declare postsPerUser: number;\n\n  @flags.boolean({\n    description: \"Truncate existing data\",\n    default: false,\n  })\n  declare fresh: boolean;\n\n  static options: CommandOptions = {\n    startApp: true,\n  };\n\n  async run(): Promise<void> {\n    const { users, postsPerUser, fresh } = this;\n\n    try {\n      if (fresh) {\n        this.logger.info(\"Truncating existing data...\");\n        await Database.truncate(\"posts\");\n        await Database.truncate(\"users\");\n      }\n\n      this.logger.info(\n        `Creating ${users} users with ${postsPerUser} posts each...`,\n      );\n\n      // ✅ Use progress bar for long operations\n      const progressBar = this.ui.progressBar();\n      progressBar.start(users, 0);\n\n      for (let i = 0; i < users; i++) {\n        const user = await UserFactory.create();\n        await PostFactory.merge({ userId: user.id }).createMany(postsPerUser);\n        progressBar.update(i + 1);\n      }\n\n      progressBar.stop();\n\n      // ✅ Display summary\n      const userCount = await Database.from(\"users\")\n        .count(\"* as total\")\n        .first();\n      const postCount = await Database.from(\"posts\")\n        .count(\"* as total\")\n        .first();\n\n      this.logger.success(\"Database seeding completed!\");\n      this.logger.info(`Total users: ${userCount?.total}`);\n      this.logger.info(`Total posts: ${postCount?.total}`);\n    } catch (error) {\n      this.logger.error(`Seeding failed: ${error.message}`);\n      this.exitCode = 1;\n    }\n  }\n}\n```\n\n### Data Import Commands\n\n```typescript\n// app/commands/import_users.ts\nimport { BaseCommand, args, flags } from \"@adonisjs/core/ace\";\nimport type { CommandOptions } from \"@adonisjs/core/types/ace\";\nimport fs from \"node:fs/promises\";\nimport csv from \"csv-parser\";\nimport { createReadStream } from \"node:fs\";\nimport User from \"#models/user\";\nimport Database from \"@adonisjs/lucid/services/db\";\n\nexport default class ImportUsers extends BaseCommand {\n  static commandName = \"import:users\";\n  static description = \"Import users from CSV file\";\n\n  @args.string({ description: \"Path to CSV file\" })\n  declare filePath: string;\n\n  @flags.number({\n    description: \"Batch size for processing\",\n    default: 100,\n  })\n  declare batchSize: number;\n\n  @flags.boolean({\n    description: \"Skip invalid rows\",\n    default: true,\n  })\n  declare skipInvalid: boolean;\n\n  @flags.boolean({\n    description: \"Dry run - validate without importing\",\n    default: false,\n  })\n  declare dryRun: boolean;\n\n  static options: CommandOptions = {\n    startApp: true,\n  };\n\n  async run(): Promise<void> {\n    const { filePath, batchSize, skipInvalid, dryRun } = this;\n\n    try {\n      // ✅ Validate file exists\n      await fs.access(filePath);\n\n      this.logger.info(`Reading CSV file: ${filePath}`);\n\n      const rows: any[] = [];\n      const errors: string[] = [];\n      let lineNumber = 1;\n\n      // ✅ Stream CSV file\n      await new Promise((resolve, reject) => {\n        createReadStream(filePath)\n          .pipe(csv())\n          .on(\"data\", (row) => {\n            lineNumber++;\n            const validation = this.validateRow(row, lineNumber);\n\n            if (validation.valid) {\n              rows.push(validation.data);\n            } else {\n              errors.push(`Line ${lineNumber}: ${validation.error}`);\n              if (!skipInvalid) {\n                reject(\n                  new Error(\n                    `Validation failed at line ${lineNumber}: ${validation.error}`,\n                  ),\n                );\n                return;\n              }\n            }\n          })\n          .on(\"end\", resolve)\n          .on(\"error\", reject);\n      });\n\n      // ✅ Display validation results\n      this.logger.info(`Found ${rows.length} valid rows`);\n      if (errors.length > 0) {\n        this.logger.warning(\n          `${errors.length} invalid rows ${skipInvalid ? \"skipped\" : \"found\"}`,\n        );\n        if (this.logger.level <= 3) {\n          // Debug level\n          errors.forEach((error) => this.logger.debug(error));\n        }\n      }\n\n      if (dryRun) {\n        this.logger.info(\"Dry run completed - no data imported\");\n        return;\n      }\n\n      // ✅ Process in batches\n      const progressBar = this.ui.progressBar();\n      progressBar.start(rows.length, 0);\n\n      let processed = 0;\n      let imported = 0;\n      let skipped = 0;\n\n      for (let i = 0; i < rows.length; i += batchSize) {\n        const batch = rows.slice(i, i + batchSize);\n\n        const trx = await Database.transaction();\n\n        try {\n          for (const row of batch) {\n            const existingUser = await User.findBy(\"email\", row.email, {\n              client: trx,\n            });\n\n            if (existingUser) {\n              skipped++;\n            } else {\n              await User.create(row, { client: trx });\n              imported++;\n            }\n\n            processed++;\n            progressBar.update(processed);\n          }\n\n          await trx.commit();\n        } catch (error) {\n          await trx.rollback();\n          throw error;\n        }\n      }\n\n      progressBar.stop();\n\n      // ✅ Display results\n      this.logger.success(\"Import completed!\");\n      const table = this.ui.table();\n      table.head([\"Metric\", \"Count\"]);\n      table.row([\"Total processed\", processed.toString()]);\n      table.row([\"Successfully imported\", imported.toString()]);\n      table.row([\"Skipped (existing)\", skipped.toString()]);\n      table.row([\"Errors\", errors.length.toString()]);\n      table.render();\n    } catch (error) {\n      this.logger.error(`Import failed: ${error.message}`);\n      this.exitCode = 1;\n    }\n  }\n\n  private validateRow(\n    row: any,\n    lineNumber: number,\n  ): { valid: boolean; data?: any; error?: string } {\n    const { email, name, role } = row;\n\n    if (!email || !email.trim()) {\n      return { valid: false, error: \"Email is required\" };\n    }\n\n    if (!this.isValidEmail(email)) {\n      return { valid: false, error: \"Invalid email format\" };\n    }\n\n    if (!name || !name.trim()) {\n      return { valid: false, error: \"Name is required\" };\n    }\n\n    const validRoles = [\"user\", \"admin\", \"moderator\"];\n    const userRole = role || \"user\";\n\n    if (!validRoles.includes(userRole)) {\n      return { valid: false, error: `Invalid role: ${userRole}` };\n    }\n\n    return {\n      valid: true,\n      data: {\n        email: email.trim().toLowerCase(),\n        fullName: name.trim(),\n        role: userRole,\n        password: \"temporary123\", // Will need to be changed\n        isActive: true,\n      },\n    };\n  }\n\n  private isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n}\n```\n\n### System Commands\n\n```typescript\n// app/commands/system_health.ts\nimport { BaseCommand, flags } from \"@adonisjs/core/ace\";\nimport type { CommandOptions } from \"@adonisjs/core/types/ace\";\nimport Database from \"@adonisjs/lucid/services/db\";\nimport redis from \"@adonisjs/redis/services/main\";\n\nexport default class SystemHealth extends BaseCommand {\n  static commandName = \"system:health\";\n  static description = \"Check system health and dependencies\";\n\n  @flags.boolean({\n    description: \"Output in JSON format\",\n    default: false,\n  })\n  declare json: boolean;\n\n  @flags.boolean({\n    description: \"Exit with error code if unhealthy\",\n    default: false,\n  })\n  declare strict: boolean;\n\n  static options: CommandOptions = {\n    startApp: true,\n  };\n\n  async run(): Promise<void> {\n    const checks = {\n      database: await this.checkDatabase(),\n      redis: await this.checkRedis(),\n      disk: await this.checkDiskSpace(),\n      memory: await this.checkMemory(),\n    };\n\n    const overall = Object.values(checks).every(\n      (check) => check.status === \"healthy\",\n    );\n\n    if (this.json) {\n      this.logger.info(\n        JSON.stringify(\n          {\n            overall: overall ? \"healthy\" : \"unhealthy\",\n            checks,\n            timestamp: new Date().toISOString(),\n          },\n          null,\n          2,\n        ),\n      );\n    } else {\n      this.displayHealthReport(checks, overall);\n    }\n\n    if (this.strict && !overall) {\n      this.exitCode = 1;\n    }\n  }\n\n  private async checkDatabase(): Promise<{\n    status: string;\n    message: string;\n    details?: any;\n  }> {\n    try {\n      const start = Date.now();\n      await Database.rawQuery(\"SELECT 1\");\n      const responseTime = Date.now() - start;\n\n      return {\n        status: \"healthy\",\n        message: `Connected (${responseTime}ms)`,\n        details: { responseTime },\n      };\n    } catch (error) {\n      return {\n        status: \"unhealthy\",\n        message: error.message,\n      };\n    }\n  }\n\n  private async checkRedis(): Promise<{\n    status: string;\n    message: string;\n    details?: any;\n  }> {\n    try {\n      const start = Date.now();\n      await redis.ping();\n      const responseTime = Date.now() - start;\n\n      return {\n        status: \"healthy\",\n        message: `Connected (${responseTime}ms)`,\n        details: { responseTime },\n      };\n    } catch (error) {\n      return {\n        status: \"unhealthy\",\n        message: error.message,\n      };\n    }\n  }\n\n  private async checkDiskSpace(): Promise<{\n    status: string;\n    message: string;\n    details?: any;\n  }> {\n    try {\n      const fs = await import(\"node:fs/promises\");\n      const stats = await fs.statfs(\".\");\n\n      const total = stats.blocks * stats.bsize;\n      const free = stats.bavail * stats.bsize;\n      const used = total - free;\n      const usedPercent = (used / total) * 100;\n\n      const status = usedPercent > 90 ? \"unhealthy\" : \"healthy\";\n      const message = `${usedPercent.toFixed(1)}% used`;\n\n      return {\n        status,\n        message,\n        details: {\n          total: this.formatBytes(total),\n          used: this.formatBytes(used),\n          free: this.formatBytes(free),\n          usedPercent: Math.round(usedPercent),\n        },\n      };\n    } catch (error) {\n      return {\n        status: \"unhealthy\",\n        message: error.message,\n      };\n    }\n  }\n\n  private async checkMemory(): Promise<{\n    status: string;\n    message: string;\n    details?: any;\n  }> {\n    const usage = process.memoryUsage();\n    const total = usage.heapTotal;\n    const used = usage.heapUsed;\n    const usedPercent = (used / total) * 100;\n\n    const status = usedPercent > 90 ? \"unhealthy\" : \"healthy\";\n    const message = `${usedPercent.toFixed(1)}% used`;\n\n    return {\n      status,\n      message,\n      details: {\n        heapTotal: this.formatBytes(usage.heapTotal),\n        heapUsed: this.formatBytes(usage.heapUsed),\n        external: this.formatBytes(usage.external),\n        rss: this.formatBytes(usage.rss),\n      },\n    };\n  }\n\n  private displayHealthReport(checks: any, overall: boolean): void {\n    this.logger.info(\n      `System Health: ${overall ? \"✅ HEALTHY\" : \"❌ UNHEALTHY\"}`,\n    );\n    this.logger.info(\"\");\n\n    const table = this.ui.table();\n    table.head([\"Component\", \"Status\", \"Details\"]);\n\n    for (const [component, check] of Object.entries(checks)) {\n      const status = check.status === \"healthy\" ? \"✅ Healthy\" : \"❌ Unhealthy\";\n      table.row([\n        component.charAt(0).toUpperCase() + component.slice(1),\n        status,\n        check.message,\n      ]);\n    }\n\n    table.render();\n  }\n\n  private formatBytes(bytes: number): string {\n    const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"];\n    if (bytes === 0) return \"0 Bytes\";\n    const i = Math.floor(Math.log(bytes) / Math.log(1024));\n    return Math.round((bytes / Math.pow(1024, i)) * 100) / 100 + \" \" + sizes[i];\n  }\n}\n```\n\n### Command Registration\n\nCommands are automatically discovered and registered. You can also manually register them:\n\n```typescript\n// start/kernel.ts\nimport { Kernel } from \"@adonisjs/core/ace\";\n\n// ✅ Auto-discovery (default)\nKernel.defaultImports([\n  () => import(\"#commands/create_user\"),\n  () => import(\"#commands/import_users\"),\n  () => import(\"#commands/system_health\"),\n]);\n```\n\n### Command Best Practices\n\n#### DO's\n\n```typescript\n// ✅ Use descriptive command names\nstatic commandName = 'user:create'\nstatic commandName = 'import:users'\nstatic commandName = 'system:health'\n\n// ✅ Provide helpful descriptions\nstatic description = 'Create a new user account with specified role and permissions'\n\n// ✅ Use progress indicators for long operations\nconst progressBar = this.ui.progressBar()\nprogressBar.start(total, 0)\n\n// ✅ Handle errors gracefully\ntry {\n  await operation()\n} catch (error) {\n  this.logger.error(`Operation failed: ${error.message}`)\n  this.exitCode = 1\n}\n\n// ✅ Validate inputs\nif (!this.isValidEmail(email)) {\n  this.logger.error('Invalid email address provided')\n  this.exitCode = 1\n  return\n}\n\n// ✅ Use transactions for database operations\nconst trx = await Database.transaction()\ntry {\n  // operations\n  await trx.commit()\n} catch (error) {\n  await trx.rollback()\n  throw error\n}\n```\n\n#### DON'Ts\n\n```typescript\n// ❌ Vague command names\nstatic commandName = 'do-stuff'\nstatic commandName = 'command1'\n\n// ❌ No error handling\nawait riskyOperation() // Can fail silently\n\n// ❌ No progress indication for long operations\nfor (let i = 0; i < 10000; i++) {\n  await operation(i) // User has no feedback\n}\n\n// ❌ Not setting exit codes\nif (error) {\n  console.log('Error occurred') // Should set this.exitCode = 1\n}\n```\n\n### Command Testing\n\n```typescript\n// tests/commands/create_user.spec.ts\nimport { test } from \"@japa/runner\";\nimport { AceFactory } from \"@adonisjs/core/factories/ace\";\n\ntest.group(\"CreateUser Command\", () => {\n  test(\"should create user with valid arguments\", async ({ assert }) => {\n    const ace = await new AceFactory().make();\n\n    const command = await ace.exec(\"user:create\", [\n      \"test@example.com\",\n      \"Test User\",\n      \"--password=password123\",\n      \"--role=admin\",\n    ]);\n\n    assert.equal(command.exitCode, 0);\n    assert.isTrue(\n      command.ui.logger.logs.some((log) =>\n        log.message.includes(\"User test@example.com created successfully\"),\n      ),\n    );\n\n    const user = await User.findBy(\"email\", \"test@example.com\");\n    assert.exists(user);\n    assert.equal(user?.role, \"admin\");\n  });\n\n  test(\"should fail with invalid email\", async ({ assert }) => {\n    const ace = await new AceFactory().make();\n\n    const command = await ace.exec(\"user:create\", [\n      \"invalid-email\",\n      \"Test User\",\n    ]);\n\n    assert.equal(command.exitCode, 1);\n    assert.isTrue(\n      command.ui.logger.logs.some((log) =>\n        log.message.includes(\"Invalid email address provided\"),\n      ),\n    );\n  });\n});\n```\n\n### Sources\n\n- [Ace Commands Documentation](https://docs.adonisjs.com/guides/ace-commandline)\n- [Creating Commands](https://docs.adonisjs.com/guides/ace-commandline#creating-commands)\n- [Command Arguments and Flags](https://docs.adonisjs.com/guides/ace-commandline#arguments-and-flags)\n- [Command Testing](https://docs.adonisjs.com/guides/testing#testing-ace-commands)\n"
    },
    {
      "parent": "adonisjs",
      "id": "controllers",
      "name": "Controllers",
      "description": "Guidelines for controllers and routing patterns in AdonisJS 6",
      "type": "rule",
      "content": "## Controllers and Routing\n\n### Controller Guidelines\n\nControllers MUST be placed in `app/controllers/` and follow these patterns:\n\n#### Controller Structure\n\n```typescript\n// app/controllers/users_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport User from \"#models/user\";\n\nexport default class UsersController {\n  // Resource methods following RESTful conventions\n  async index({ response }: HttpContext) {\n    const users = await User.all();\n    return response.json(users);\n  }\n\n  async show({ params, response }: HttpContext) {\n    const user = await User.findOrFail(params.id);\n    return response.json(user);\n  }\n\n  async store({ request, response }: HttpContext) {\n    const data = request.only([\"email\", \"name\", \"password\"]);\n    const user = await User.create(data);\n    return response.status(201).json(user);\n  }\n\n  async update({ params, request, response }: HttpContext) {\n    const user = await User.findOrFail(params.id);\n    const data = request.only([\"email\", \"name\"]);\n    await user.merge(data).save();\n    return response.json(user);\n  }\n\n  async destroy({ params, response }: HttpContext) {\n    const resource = await Resource.findOrFail(params.id);\n    await resource.delete();\n    return response.status(204).send(\"\");\n  }\n}\n```\n\n#### Controller Best Practices\n\n- ALWAYS use TypeScript and type the HttpContext destructured parameters\n- ALWAYS use dependency injection via `@inject()` decorator for services\n- NEVER put business logic directly in controllers - use services\n- ALWAYS return consistent response formats\n- RELY on AdonisJS global error handling - avoid unnecessary try-catch blocks\n- ALWAYS validate input data using validators\n- NEVER access request body directly without validation\n\n### Route Organization\n\nRoutes MUST be defined in `start/routes.ts` following these patterns:\n\n#### Basic Routing\n\n```typescript\n// start/routes.ts\nimport router from \"@adonisjs/core/services/router\";\nimport { middleware } from \"./kernel.js\";\n\n// ✅ Correct: Use magic strings for lazy loading\nrouter.get(\"users\", \"#controllers/users_controller.index\");\nrouter.post(\"users\", \"#controllers/users_controller.store\");\n\n// ✅ Alternative: Direct import (not lazy loaded)\nimport UsersController from \"#controllers/users_controller\";\nrouter.get(\"users\", [UsersController, \"index\"]);\n```\n\n#### Resource Routes\n\n```typescript\n// ✅ Correct: Full resource routes\nrouter.resource(\"users\", \"#controllers/users_controller\");\n\n// ✅ Correct: API-only resource routes (no create/edit forms)\nrouter.resource(\"users\", \"#controllers/users_controller\").apiOnly();\n\n// ✅ Correct: Specific resource methods only\nrouter\n  .resource(\"users\", \"#controllers/users_controller\")\n  .only([\"index\", \"show\", \"store\"]);\n\n// ✅ Correct: Nested resources\nrouter.resource(\"users.posts\", \"#controllers/posts_controller\");\n```\n\n#### Route Groups\n\n```typescript\n// ✅ Correct: API versioning with groups\nrouter\n  .group(() => {\n    router.resource(\"entities\", \"#controllers/entities_controller\").apiOnly();\n    router.resource(\"items\", \"#controllers/items_controller\").apiOnly();\n    router\n      .resource(\"categories\", \"#controllers/categories_controller\")\n      .apiOnly();\n  })\n  .prefix(\"api/v1\")\n  .middleware([middleware.auth()]);\n\n// ✅ Correct: Admin routes with multiple middleware\nrouter\n  .group(() => {\n    router.get(\"dashboard\", \"#controllers/admin/dashboard_controller.index\");\n    router.resource(\"entities\", \"#controllers/admin/entities_controller\");\n  })\n  .prefix(\"admin\")\n  .middleware([middleware.auth(), middleware.admin()]);\n\n// ✅ Correct: Public routes\nrouter\n  .group(() => {\n    router.post(\"login\", \"#controllers/auth_controller.login\");\n    router.post(\"register\", \"#controllers/auth_controller.register\");\n    router.post(\n      \"forgot-password\",\n      \"#controllers/auth_controller.forgotPassword\",\n    );\n  })\n  .prefix(\"auth\");\n```\n\n#### Route Parameters\n\n```typescript\n// ✅ Correct: Route parameters with validation\nrouter\n  .get(\"resources/:id\", \"#controllers/resources_controller.show\")\n  .where(\"id\", router.matchers.number());\n\n// ✅ Correct: Optional parameters\nrouter.get(\"items/:slug?\", \"#controllers/items_controller.show\");\n\n// ✅ Correct: Wildcard parameters\nrouter.get(\"files/*\", \"#controllers/files_controller.serve\");\n\n// ✅ Correct: Multiple parameters\nrouter\n  .get(\"entities/:entityId/items/:itemId\", \"#controllers/items_controller.show\")\n  .where(\"entityId\", router.matchers.number())\n  .where(\"itemId\", router.matchers.number());\n```\n\n#### Route Middleware\n\n```typescript\n// ✅ Correct: Global middleware on routes\nrouter\n  .get(\"profile\", \"#controllers/resources_controller.profile\")\n  .middleware([middleware.auth()]);\n\n// ✅ Correct: Multiple middleware with options\nrouter\n  .post(\"admin/resources\", \"#controllers/admin/resources_controller.store\")\n  .middleware([middleware.auth(), middleware.role([\"admin\", \"moderator\"])]);\n\n// ✅ Correct: Route-specific middleware\nrouter\n  .get(\"api/resources\", \"#controllers/api/resources_controller.index\")\n  .middleware([middleware.throttle({ max: 100, duration: \"1m\" })]);\n```\n\n### HttpContext Usage\n\nALWAYS destructure only the properties you need from HttpContext:\n\n```typescript\n// ✅ Correct: Destructure only needed properties\nasync store({ request, response, auth }: HttpContext) {\n  const entity = auth.getUserOrFail()\n  const data = request.only(['field1', 'field2'])\n  // ...\n}\n\n// ❌ Incorrect: Using entire context\nasync store(ctx: HttpContext) {\n  const entity = ctx.auth.getUserOrFail()\n  const data = ctx.request.only(['field1', 'field2'])\n  // ...\n}\n```\n\n### Response Patterns\n\nALWAYS return consistent response formats:\n\n```typescript\nexport default class ResourcesController {\n  // ✅ Correct: Consistent success responses\n  async index({ response }: HttpContext) {\n    const resources = await Resource.all();\n    return response.json({\n      data: resources,\n      meta: {\n        total: resources.length,\n      },\n    });\n  }\n\n  // ✅ Correct: Let AdonisJS handle errors globally\n  async show({ params, response }: HttpContext) {\n    const resource = await Resource.findOrFail(params.id); // Throws 404 automatically\n    return response.json({ data: resource });\n  }\n\n  // ✅ Correct: Status codes for different operations\n  async store({ request, response }: HttpContext) {\n    const resource = await Resource.create(request.only([\"field1\", \"field2\"]));\n    return response.status(201).json({ data: resource });\n  }\n\n  async destroy({ params, response }: HttpContext) {\n    const resource = await Resource.findOrFail(params.id);\n    await resource.delete();\n    return response.status(204).send(\"\");\n  }\n}\n```\n\n### Route Testing\n\n```typescript\n// tests/functional/resources.spec.ts\nimport { test } from \"@japa/runner\";\n\ntest.group(\"Resources Controller\", () => {\n  test(\"should list all resources\", async ({ client }) => {\n    const response = await client.get(\"/api/resources\");\n\n    response.assertStatus(200);\n    response.assertBodyContains({\n      data: [],\n    });\n  });\n\n  test(\"should create a new resource\", async ({ client }) => {\n    const resourceData = {\n      field1: \"value1\",\n      field2: \"value2\",\n    };\n\n    const response = await client.post(\"/api/resources\").json(resourceData);\n\n    response.assertStatus(201);\n    response.assertBodyContains({\n      data: {\n        field1: resourceData.field1,\n        field2: resourceData.field2,\n      },\n    });\n  });\n});\n```\n\n### Common Anti-Patterns\n\n```typescript\n// ❌ Incorrect: Business logic in controller\nasync store({ request, response }: HttpContext) {\n  const field1 = request.input('field1')\n\n  // ❌ Don't put validation logic here\n  if (!field1 || field1.length < 3) {\n    return response.status(400).json({ error: 'Invalid field1' })\n  }\n\n  // ❌ Don't put complex business logic here\n  const existingResource = await Resource.findBy('field1', field1)\n  if (existingResource) {\n    return response.status(409).json({ error: 'Resource exists' })\n  }\n\n  const resource = await Resource.create(request.all())\n  return response.json(resource)\n}\n\n// ✅ Correct: Delegate to service\nasync store({ request, response }: HttpContext) {\n  const data = await request.validateUsing(CreateResourceValidator)\n  const resource = await this.resourceService.createResource(data)\n  return response.status(201).json({ data: resource })\n}\n```\n\n### Sources\n\n- [Controllers Documentation](https://docs.adonisjs.com/guides/controllers)\n- [Routing Documentation](https://docs.adonisjs.com/guides/routing)\n- [HTTP Context](https://docs.adonisjs.com/guides/context)\n- [Resource Routes](https://docs.adonisjs.com/guides/routing#resource-routes)\n- [Route Groups](https://docs.adonisjs.com/guides/routing#route-groups)\n- [Route Middleware](https://docs.adonisjs.com/guides/routing#route-middleware)\n- [Dependency Injection](https://docs.adonisjs.com/guides/dependency-injection)\n"
    },
    {
      "parent": "adonisjs",
      "id": "deployment",
      "name": "Deployment",
      "description": "Deployment guidelines and best practices for AdonisJS 6 applications",
      "type": "rule",
      "content": "## Deployment Guidelines\n\n### Production Environment Setup\n\n#### Environment Configuration\n\n```env\n# Production .env\nNODE_ENV=production\nPORT=3333\nHOST=0.0.0.0\n\n# Application\nAPP_KEY=your-32-character-secure-app-key\nLOG_LEVEL=info\n\n# Database\nDB_HOST=your-database-host\nDB_PORT=5432\nDB_USER=your-db-user\nDB_PASSWORD=your-secure-db-password\nDB_DATABASE=your-production-db\n\n# Redis\nREDIS_HOST=your-redis-host\nREDIS_PORT=6379\nREDIS_PASSWORD=your-redis-password\n\n# Security\nSESSION_DRIVER=redis\nCORS_ENABLED=true\n\n# External Services\nSMTP_HOST=your-smtp-host\nSMTP_PORT=587\nSMTP_USERNAME=your-smtp-user\nSMTP_PASSWORD=your-smtp-password\n\n# Monitoring\nSENTRY_DSN=your-sentry-dsn\nNEW_RELIC_LICENSE_KEY=your-new-relic-key\n```\n\n#### Production Configuration\n\n```typescript\n// config/app.ts\nimport env from \"#start/env\";\n\nexport default {\n  appKey: env.get(\"APP_KEY\"),\n  http: {\n    host: env.get(\"HOST\"),\n    port: env.get(\"PORT\"),\n    // ✅ Trust proxy in production\n    trustProxy: env.get(\"NODE_ENV\") === \"production\",\n    cookie: {\n      // ✅ Secure cookies in production\n      secure: env.get(\"NODE_ENV\") === \"production\",\n      sameSite: \"strict\",\n      httpOnly: true,\n    },\n  },\n\n  // ✅ Disable debug in production\n  debug: env.get(\"NODE_ENV\") !== \"production\",\n\n  // ✅ Production optimizations\n  profiler: {\n    enabled: env.get(\"NODE_ENV\") === \"development\",\n  },\n};\n```\n\n### Docker Deployment\n\n#### Dockerfile\n\n```dockerfile\n# Dockerfile\nFROM node:18-alpine AS base\n\n# Install dependencies only when needed\nFROM base AS deps\nRUN apk add --no-cache libc6-compat\nWORKDIR /app\n\n# Copy package files\nCOPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./\nRUN \\\n  if [ -f yarn.lock ]; then yarn --frozen-lockfile; \\\n  elif [ -f package-lock.json ]; then npm ci; \\\n  elif [ -f pnpm-lock.yaml ]; then yarn global add pnpm && pnpm i --frozen-lockfile; \\\n  else echo \"Lockfile not found.\" && exit 1; \\\n  fi\n\n# Build the application\nFROM base AS builder\nWORKDIR /app\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY . .\n\n# Build application\nRUN npm run build\n\n# Production image\nFROM base AS runner\nWORKDIR /app\n\nENV NODE_ENV=production\n\n# Create app user\nRUN addgroup --system --gid 1001 nodejs\nRUN adduser --system --uid 1001 adonisjs\n\n# Copy built application\nCOPY --from=builder --chown=adonisjs:nodejs /app/build ./\nCOPY --from=builder --chown=adonisjs:nodejs /app/node_modules ./node_modules\nCOPY --from=builder --chown=adonisjs:nodejs /app/package.json ./package.json\n\nUSER adonisjs\n\nEXPOSE 3333\n\nENV PORT=3333\nENV HOST=0.0.0.0\n\nCMD [\"node\", \"bin/server.js\"]\n```\n\n#### Docker Compose\n\n```yaml\n# docker-compose.yml\nversion: \"3.8\"\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"3333:3333\"\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp\n      - REDIS_URL=redis://redis:6379\n    depends_on:\n      - db\n      - redis\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3333/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  db:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_DB: myapp\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    restart: unless-stopped\n\n  redis:\n    image: redis:7-alpine\n    restart: unless-stopped\n    volumes:\n      - redis_data:/data\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf\n      - ./ssl:/etc/nginx/ssl\n    depends_on:\n      - app\n    restart: unless-stopped\n\nvolumes:\n  postgres_data:\n  redis_data:\n```\n\n### Nginx Configuration\n\n```nginx\n# nginx.conf\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    upstream app {\n        server app:3333;\n    }\n\n    # Rate limiting\n    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;\n    limit_req_zone $binary_remote_addr zone=login:10m rate=5r/m;\n\n    server {\n        listen 80;\n        server_name yourdomain.com www.yourdomain.com;\n\n        # Redirect HTTP to HTTPS\n        return 301 https://$server_name$request_uri;\n    }\n\n    server {\n        listen 443 ssl http2;\n        server_name yourdomain.com www.yourdomain.com;\n\n        # SSL Configuration\n        ssl_certificate /etc/nginx/ssl/cert.pem;\n        ssl_certificate_key /etc/nginx/ssl/key.pem;\n        ssl_protocols TLSv1.2 TLSv1.3;\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;\n        ssl_prefer_server_ciphers off;\n\n        # Security headers\n        add_header X-Frame-Options DENY;\n        add_header X-Content-Type-Options nosniff;\n        add_header X-XSS-Protection \"1; mode=block\";\n        add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n\n        # Gzip compression\n        gzip on;\n        gzip_vary on;\n        gzip_min_length 1024;\n        gzip_types\n            application/atom+xml\n            application/javascript\n            application/json\n            application/ld+json\n            application/manifest+json\n            application/rss+xml\n            application/vnd.geo+json\n            application/vnd.ms-fontobject\n            application/x-font-ttf\n            application/x-web-app-manifest+json\n            application/xhtml+xml\n            application/xml\n            font/opentype\n            image/bmp\n            image/svg+xml\n            image/x-icon\n            text/cache-manifest\n            text/css\n            text/plain\n            text/vcard\n            text/vnd.rim.location.xloc\n            text/vtt\n            text/x-component\n            text/x-cross-domain-policy;\n\n        # Static files\n        location /static/ {\n            alias /app/public/;\n            expires 1y;\n            add_header Cache-Control \"public, immutable\";\n        }\n\n        # API rate limiting\n        location /api/ {\n            limit_req zone=api burst=20 nodelay;\n            proxy_pass http://app;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n        }\n\n        # Login rate limiting\n        location /auth/login {\n            limit_req zone=login burst=5 nodelay;\n            proxy_pass http://app;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n        }\n\n        # Default proxy\n        location / {\n            proxy_pass http://app;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n\n            # WebSocket support\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"upgrade\";\n        }\n    }\n}\n```\n\n### CI/CD Pipeline\n\n#### GitHub Actions\n\n```yaml\n# .github/workflows/deploy.yml\nname: Deploy to Production\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_PASSWORD: postgres\n          POSTGRES_DB: test_db\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n      redis:\n        image: redis:7\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: \"18\"\n          cache: \"npm\"\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Run linting\n        run: npm run lint\n\n      - name: Run type checking\n        run: npm run typecheck\n\n      - name: Run tests\n        run: npm test\n        env:\n          NODE_ENV: test\n          DB_HOST: localhost\n          DB_PORT: 5432\n          DB_USER: postgres\n          DB_PASSWORD: postgres\n          DB_DATABASE: test_db\n          REDIS_HOST: localhost\n          REDIS_PORT: 6379\n\n      - name: Build application\n        run: npm run build\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup Docker Buildx\n        uses: docker/setup-buildx-action@v2\n\n      - name: Login to Container Registry\n        uses: docker/login-action@v2\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          push: true\n          tags: ghcr.io/${{ github.repository }}:latest\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n\n      - name: Deploy to production\n        uses: appleboy/ssh-action@v0.1.7\n        with:\n          host: ${{ secrets.DEPLOY_HOST }}\n          username: ${{ secrets.DEPLOY_USER }}\n          key: ${{ secrets.DEPLOY_KEY }}\n          script: |\n            cd /app\n            docker compose pull\n            docker compose up -d\n            docker system prune -f\n```\n\n### Health Checks\n\n```typescript\n// app/controllers/health_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport Database from \"@adonisjs/lucid/services/db\";\nimport redis from \"@adonisjs/redis/services/main\";\n\nexport default class HealthController {\n  // ✅ Basic health check\n  async index({ response }: HttpContext) {\n    return response.json({\n      status: \"ok\",\n      timestamp: new Date().toISOString(),\n      version: process.env.npm_package_version || \"1.0.0\",\n    });\n  }\n\n  // ✅ Detailed health check\n  async detailed({ response }: HttpContext) {\n    const checks = await Promise.allSettled([\n      this.checkDatabase(),\n      this.checkRedis(),\n      this.checkMemory(),\n      this.checkDisk(),\n    ]);\n\n    const results = {\n      database:\n        checks[0].status === \"fulfilled\"\n          ? checks[0].value\n          : { status: \"error\", error: checks[0].reason?.message },\n      redis:\n        checks[1].status === \"fulfilled\"\n          ? checks[1].value\n          : { status: \"error\", error: checks[1].reason?.message },\n      memory:\n        checks[2].status === \"fulfilled\"\n          ? checks[2].value\n          : { status: \"error\", error: checks[2].reason?.message },\n      disk:\n        checks[3].status === \"fulfilled\"\n          ? checks[3].value\n          : { status: \"error\", error: checks[3].reason?.message },\n    };\n\n    const overall = Object.values(results).every(\n      (check) => check.status === \"ok\",\n    );\n\n    return response.status(overall ? 200 : 503).json({\n      status: overall ? \"ok\" : \"error\",\n      checks: results,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  private async checkDatabase() {\n    const start = Date.now();\n    await Database.rawQuery(\"SELECT 1\");\n    const responseTime = Date.now() - start;\n\n    return {\n      status: \"ok\",\n      responseTime,\n      message: `Database connected (${responseTime}ms)`,\n    };\n  }\n\n  private async checkRedis() {\n    const start = Date.now();\n    await redis.ping();\n    const responseTime = Date.now() - start;\n\n    return {\n      status: \"ok\",\n      responseTime,\n      message: `Redis connected (${responseTime}ms)`,\n    };\n  }\n\n  private async checkMemory() {\n    const usage = process.memoryUsage();\n    const usedMB = Math.round(usage.heapUsed / 1024 / 1024);\n    const totalMB = Math.round(usage.heapTotal / 1024 / 1024);\n\n    return {\n      status: \"ok\",\n      memory: {\n        used: `${usedMB}MB`,\n        total: `${totalMB}MB`,\n        percentage: Math.round((usage.heapUsed / usage.heapTotal) * 100),\n      },\n    };\n  }\n\n  private async checkDisk() {\n    // Simplified disk check\n    return {\n      status: \"ok\",\n      message: \"Disk space available\",\n    };\n  }\n}\n```\n\n### Database Migrations in Production\n\n```typescript\n// database/migrations/production_deployment.ts\nimport { BaseSchema } from \"@adonisjs/lucid/schema\";\n\nexport default class extends BaseSchema {\n  protected tableName = \"users\";\n\n  async up() {\n    // ✅ Safe migrations for production\n    this.schema.alterTable(this.tableName, (table) => {\n      // Add columns with defaults\n      table.boolean(\"email_verified\").defaultTo(false);\n      table.timestamp(\"last_login_at\").nullable();\n\n      // Create indexes\n      table.index([\"email\"], \"users_email_index\");\n      table.index([\"created_at\"], \"users_created_at_index\");\n    });\n  }\n\n  async down() {\n    this.schema.alterTable(this.tableName, (table) => {\n      table.dropIndex([\"email\"], \"users_email_index\");\n      table.dropIndex([\"created_at\"], \"users_created_at_index\");\n      table.dropColumn(\"email_verified\");\n      table.dropColumn(\"last_login_at\");\n    });\n  }\n}\n```\n\n### Monitoring and Logging\n\n```typescript\n// config/logger.ts\nimport env from \"#start/env\";\n\nexport default {\n  default: \"app\",\n\n  loggers: {\n    app: {\n      enabled: true,\n      name: env.get(\"APP_NAME\"),\n      level: env.get(\"LOG_LEVEL\"),\n      redact: {\n        paths: [\"password\", \"password_confirmation\", \"token\", \"secret\"],\n        censor: \"***\",\n      },\n\n      // ✅ Production logging\n      targets:\n        env.get(\"NODE_ENV\") === \"production\"\n          ? [\n              {\n                target: \"pino/file\",\n                options: {\n                  destination: \"./storage/logs/app.log\",\n                },\n                level: \"info\",\n              },\n              {\n                target: \"@sentry/node\",\n                options: {\n                  dsn: env.get(\"SENTRY_DSN\"),\n                },\n                level: \"error\",\n              },\n            ]\n          : [\n              {\n                target: \"pino-pretty\",\n                options: {\n                  colorize: true,\n                },\n              },\n            ],\n    },\n  },\n};\n```\n\n### Performance Monitoring\n\n```typescript\n// app/middleware/performance_monitoring_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\nimport logger from \"@adonisjs/core/services/logger\";\n\nexport default class PerformanceMonitoringMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    const start = process.hrtime.bigint();\n    const startMemory = process.memoryUsage().heapUsed;\n\n    try {\n      await next();\n    } finally {\n      const end = process.hrtime.bigint();\n      const endMemory = process.memoryUsage().heapUsed;\n\n      const duration = Number(end - start) / 1000000; // Convert to milliseconds\n      const memoryDelta = endMemory - startMemory;\n\n      // ✅ Log performance metrics\n      if (duration > 1000) {\n        // Log slow requests\n        logger.warn(\"Slow request detected\", {\n          method: ctx.request.method(),\n          url: ctx.request.url(),\n          duration: `${duration.toFixed(2)}ms`,\n          memoryDelta: `${(memoryDelta / 1024 / 1024).toFixed(2)}MB`,\n          statusCode: ctx.response.getStatus(),\n          userId: ctx.auth?.user?.id,\n        });\n      }\n\n      // ✅ Add performance headers\n      ctx.response.header(\"X-Response-Time\", `${duration.toFixed(2)}ms`);\n    }\n  }\n}\n```\n\n### Deployment Checklist\n\n#### Pre-deployment\n\n- [ ] Environment variables are properly configured\n- [ ] Database migrations have been tested\n- [ ] Application builds successfully\n- [ ] All tests pass\n- [ ] Security headers are configured\n- [ ] SSL certificates are valid\n- [ ] Backup strategy is in place\n- [ ] Monitoring is configured\n\n#### Deployment\n\n- [ ] Deploy to staging environment first\n- [ ] Run database migrations\n- [ ] Verify health checks pass\n- [ ] Test critical user journeys\n- [ ] Monitor error rates and performance\n- [ ] Verify all external integrations work\n\n#### Post-deployment\n\n- [ ] Monitor application logs\n- [ ] Check performance metrics\n- [ ] Verify database connections\n- [ ] Test API endpoints\n- [ ] Monitor error tracking\n- [ ] Verify backup systems\n\n### Rollback Strategy\n\n```bash\n#!/bin/bash\n# rollback.sh\n\n# ✅ Rollback script\nset -e\n\nPREVIOUS_VERSION=$1\n\nif [ -z \"$PREVIOUS_VERSION\" ]; then\n  echo \"Usage: $0 <previous_version>\"\n  exit 1\nfi\n\necho \"Rolling back to version: $PREVIOUS_VERSION\"\n\n# Stop current application\ndocker compose down\n\n# Restore previous image\ndocker tag myapp:$PREVIOUS_VERSION myapp:latest\n\n# Rollback database if needed\n# node ace migration:rollback --batch=1\n\n# Start application\ndocker compose up -d\n\n# Verify rollback\nsleep 10\ncurl -f http://localhost:3333/health || {\n  echo \"Health check failed after rollback\"\n  exit 1\n}\n\necho \"Rollback completed successfully\"\n```\n\n### Scaling Considerations\n\n```yaml\n# docker-compose.scale.yml\nversion: \"3.8\"\n\nservices:\n  app:\n    build: .\n    deploy:\n      replicas: 3\n    ports:\n      - \"3333-3335:3333\"\n    environment:\n      - NODE_ENV=production\n    depends_on:\n      - db\n      - redis\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx-load-balancer.conf:/etc/nginx/nginx.conf\n    depends_on:\n      - app\n```\n\n### Sources\n\n- [AdonisJS Deployment Guide](https://docs.adonisjs.com/guides/deployment)\n- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)\n- [Nginx Configuration](https://nginx.org/en/docs/)\n- [GitHub Actions](https://docs.github.com/en/actions)\n"
    },
    {
      "parent": "adonisjs",
      "id": "env",
      "name": "Environment Variables",
      "description": "Guidelines for environment variables and configuration in AdonisJS 6",
      "type": "rule",
      "content": "## Environment Variables and Configuration\n\n### Environment Validation\n\nEnvironment variables MUST be validated in `start/env.ts`:\n\n```typescript\n// start/env.ts\nimport { Env } from \"@adonisjs/core/env\";\n\nexport default await Env.create(new URL(\"../\", import.meta.url), {\n  // ✅ App configuration\n  NODE_ENV: Env.schema.enum([\"development\", \"production\", \"test\"] as const),\n  PORT: Env.schema.number(),\n  APP_KEY: Env.schema.string(),\n  HOST: Env.schema.string({ format: \"host\" }),\n  LOG_LEVEL: Env.schema.enum([\n    \"fatal\",\n    \"error\",\n    \"warn\",\n    \"info\",\n    \"debug\",\n    \"trace\",\n  ]),\n\n  // ✅ Database configuration\n  DB_HOST: Env.schema.string({ format: \"host\" }),\n  DB_PORT: Env.schema.number(),\n  DB_USER: Env.schema.string(),\n  DB_PASSWORD: Env.schema.string.optional(),\n  DB_DATABASE: Env.schema.string(),\n\n  // ✅ Redis configuration\n  REDIS_HOST: Env.schema.string({ format: \"host\" }),\n  REDIS_PORT: Env.schema.number(),\n  REDIS_PASSWORD: Env.schema.string.optional(),\n\n  // ✅ Email configuration\n  SMTP_HOST: Env.schema.string({ format: \"host\" }),\n  SMTP_PORT: Env.schema.number(),\n  SMTP_USERNAME: Env.schema.string.optional(),\n  SMTP_PASSWORD: Env.schema.string.optional(),\n\n  // ✅ Third-party services\n  AWS_ACCESS_KEY_ID: Env.schema.string.optional(),\n  AWS_SECRET_ACCESS_KEY: Env.schema.string.optional(),\n  AWS_BUCKET: Env.schema.string.optional(),\n  AWS_REGION: Env.schema.string.optional(),\n\n  // ✅ Social authentication\n  GITHUB_CLIENT_ID: Env.schema.string.optional(),\n  GITHUB_CLIENT_SECRET: Env.schema.string.optional(),\n  GOOGLE_CLIENT_ID: Env.schema.string.optional(),\n  GOOGLE_CLIENT_SECRET: Env.schema.string.optional(),\n\n  // ✅ API keys\n  STRIPE_SECRET_KEY: Env.schema.string.optional(),\n  STRIPE_PUBLISHABLE_KEY: Env.schema.string.optional(),\n  SENDGRID_API_KEY: Env.schema.string.optional(),\n\n  // ✅ Feature flags\n  ENABLE_DEBUG_MODE: Env.schema.boolean.optional(),\n  ENABLE_ANALYTICS: Env.schema.boolean.optional(),\n  MAINTENANCE_MODE: Env.schema.boolean.optional(),\n\n  // ✅ Security settings\n  SESSION_DRIVER: Env.schema.enum([\"cookie\", \"memory\", \"redis\"] as const),\n  CORS_ENABLED: Env.schema.boolean(),\n  RATE_LIMIT_ENABLED: Env.schema.boolean.optional(),\n});\n```\n\n### Environment File Structure\n\n#### .env (Development)\n\n```env\n# ✅ Application\nNODE_ENV=development\nPORT=3333\nAPP_KEY=your-32-character-secret-key\nHOST=localhost\nLOG_LEVEL=debug\n\n# ✅ Database\nDB_HOST=localhost\nDB_PORT=5432\nDB_USER=postgres\nDB_PASSWORD=password\nDB_DATABASE=myapp_development\n\n# ✅ Redis\nREDIS_HOST=localhost\nREDIS_PORT=6379\n# REDIS_PASSWORD=\n\n# ✅ Email (Development)\nSMTP_HOST=localhost\nSMTP_PORT=1025\n# SMTP_USERNAME=\n# SMTP_PASSWORD=\n\n# ✅ Development flags\nENABLE_DEBUG_MODE=true\nENABLE_ANALYTICS=false\nMAINTENANCE_MODE=false\n\n# ✅ Session\nSESSION_DRIVER=cookie\nCORS_ENABLED=true\n```\n\n#### .env.example (Template)\n\n```env\n# Application Configuration\nNODE_ENV=development\nPORT=3333\nAPP_KEY=\nHOST=localhost\nLOG_LEVEL=info\n\n# Database Configuration\nDB_HOST=localhost\nDB_PORT=5432\nDB_USER=\nDB_PASSWORD=\nDB_DATABASE=\n\n# Redis Configuration (Optional)\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_PASSWORD=\n\n# Email Configuration\nSMTP_HOST=\nSMTP_PORT=587\nSMTP_USERNAME=\nSMTP_PASSWORD=\n\n# AWS S3 Configuration (Optional)\nAWS_ACCESS_KEY_ID=\nAWS_SECRET_ACCESS_KEY=\nAWS_BUCKET=\nAWS_REGION=us-east-1\n\n# Third-party API Keys (Optional)\nSTRIPE_SECRET_KEY=\nSTRIPE_PUBLISHABLE_KEY=\nSENDGRID_API_KEY=\n\n# Social Authentication (Optional)\nGITHUB_CLIENT_ID=\nGITHUB_CLIENT_SECRET=\nGOOGLE_CLIENT_ID=\nGOOGLE_CLIENT_SECRET=\n\n# Feature Flags\nENABLE_DEBUG_MODE=false\nENABLE_ANALYTICS=true\nMAINTENANCE_MODE=false\n\n# Security\nSESSION_DRIVER=cookie\nCORS_ENABLED=true\nRATE_LIMIT_ENABLED=true\n```\n\n### Configuration Files\n\nConfiguration files MUST use environment variables:\n\n```typescript\n// config/app.ts\nimport env from \"#start/env\";\n\nexport default {\n  // ✅ App settings\n  appKey: env.get(\"APP_KEY\"),\n  http: {\n    host: env.get(\"HOST\"),\n    port: env.get(\"PORT\"),\n    trustProxy: env.get(\"NODE_ENV\") === \"production\",\n  },\n\n  // ✅ Debug settings\n  debug: env.get(\"ENABLE_DEBUG_MODE\", false),\n\n  // ✅ Feature flags\n  features: {\n    analytics: env.get(\"ENABLE_ANALYTICS\", true),\n    maintenanceMode: env.get(\"MAINTENANCE_MODE\", false),\n  },\n};\n```\n\n```typescript\n// config/database.ts\nimport env from \"#start/env\";\n\nexport default {\n  connection: env.get(\"DB_CONNECTION\", \"pg\"),\n\n  connections: {\n    pg: {\n      client: \"pg\",\n      connection: {\n        host: env.get(\"DB_HOST\"),\n        port: env.get(\"DB_PORT\"),\n        user: env.get(\"DB_USER\"),\n        password: env.get(\"DB_PASSWORD\"),\n        database: env.get(\"DB_DATABASE\"),\n      },\n      migrations: {\n        naturalSort: true,\n        paths: [\"./database/migrations\"],\n      },\n      debug: env.get(\"NODE_ENV\") === \"development\",\n    },\n  },\n};\n```\n\n```typescript\n// config/redis.ts\nimport env from \"#start/env\";\n\nexport default {\n  connection: \"main\",\n\n  connections: {\n    main: {\n      host: env.get(\"REDIS_HOST\"),\n      port: env.get(\"REDIS_PORT\"),\n      password: env.get(\"REDIS_PASSWORD\", \"\"),\n      db: 0,\n      keyPrefix: \"\",\n    },\n  },\n};\n```\n\n### Using Environment Variables\n\n```typescript\n// ✅ In services\nimport env from \"#start/env\";\n\nexport default class EmailService {\n  private config = {\n    host: env.get(\"SMTP_HOST\"),\n    port: env.get(\"SMTP_PORT\"),\n    username: env.get(\"SMTP_USERNAME\"),\n    password: env.get(\"SMTP_PASSWORD\"),\n  };\n\n  async sendEmail(to: string, subject: string, body: string) {\n    if (!this.config.host) {\n      throw new Error(\"SMTP configuration is missing\");\n    }\n    // Send email logic\n  }\n}\n\n// ✅ In controllers with feature flags\nimport env from \"#start/env\";\n\nexport default class AnalyticsController {\n  async track({ request, response }: HttpContext) {\n    if (!env.get(\"ENABLE_ANALYTICS\")) {\n      return response.noContent();\n    }\n\n    // Track analytics\n    return response.json({ tracked: true });\n  }\n}\n\n// ✅ In middleware\nexport default class MaintenanceMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    if (env.get(\"MAINTENANCE_MODE\")) {\n      return ctx.response.status(503).json({\n        error: \"Service temporarily unavailable\",\n        message: \"The application is under maintenance\",\n      });\n    }\n\n    return await next();\n  }\n}\n```\n\n### Environment-Specific Configuration\n\n```typescript\n// config/cors.ts\nimport env from \"#start/env\";\n\nexport default {\n  enabled: env.get(\"CORS_ENABLED\"),\n\n  // ✅ Different origins per environment\n  origin:\n    env.get(\"NODE_ENV\") === \"production\"\n      ? [\"https://yourdomain.com\", \"https://app.yourdomain.com\"]\n      : true,\n\n  methods: [\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"],\n  headers: true,\n  exposeHeaders: [],\n  credentials: true,\n  maxAge: false,\n};\n```\n\n```typescript\n// config/session.ts\nimport env from \"#start/env\";\n\nexport default {\n  driver: env.get(\"SESSION_DRIVER\"),\n\n  cookieName: \"adonis-session\",\n  clearWithBrowser: false,\n\n  // ✅ Secure cookies in production\n  cookie: {\n    domain: env.get(\"NODE_ENV\") === \"production\" ? \".yourdomain.com\" : \"\",\n    path: \"/\",\n    maxAge: \"2h\",\n    httpOnly: true,\n    secure: env.get(\"NODE_ENV\") === \"production\",\n    sameSite: false,\n  },\n};\n```\n\n### Environment Variable Best Practices\n\n#### Naming Conventions\n\n```env\n# ✅ Correct: Use SCREAMING_SNAKE_CASE\nDATABASE_URL=postgresql://user:pass@localhost/db\nAPI_BASE_URL=https://api.example.com\nENABLE_FEATURE_X=true\nMAX_UPLOAD_SIZE=10485760\n\n# ❌ Incorrect: Mixed case or spaces\ndatabase_url=postgresql://user:pass@localhost/db\nApi-Base-Url=https://api.example.com\nenable feature x=true\n```\n\n#### Sensitive Data Handling\n\n```typescript\n// ✅ Correct: Optional sensitive variables\nAWS_SECRET_ACCESS_KEY: Env.schema.string.optional(),\nSTRIPE_SECRET_KEY: Env.schema.string.optional(),\n\n// ✅ Correct: Required in production only\nJWT_SECRET: Env.schema.string.optional({\n  validate: (value) => {\n    if (env.get('NODE_ENV') === 'production' && !value) {\n      throw new Error('JWT_SECRET is required in production')\n    }\n  }\n})\n\n// ✅ Correct: Default values for development\nREDIS_PORT: Env.schema.number.optional(6379),\nLOG_LEVEL: Env.schema.enum(['debug', 'info', 'warn', 'error']).optional('info')\n```\n\n#### Type Safety\n\n```typescript\n// ✅ Correct: Proper validation\nexport default class PaymentService {\n  constructor() {\n    if (!env.get(\"STRIPE_SECRET_KEY\")) {\n      throw new Error(\"Stripe configuration is required\");\n    }\n  }\n\n  async processPayment(amount: number) {\n    const stripe = new Stripe(env.get(\"STRIPE_SECRET_KEY\")!, {\n      apiVersion: \"2023-10-16\",\n    });\n    // Process payment\n  }\n}\n\n// ✅ Correct: Feature flags\nexport default class FeatureService {\n  isAnalyticsEnabled(): boolean {\n    return env.get(\"ENABLE_ANALYTICS\", false);\n  }\n\n  isMaintenanceMode(): boolean {\n    return env.get(\"MAINTENANCE_MODE\", false);\n  }\n\n  getMaxUploadSize(): number {\n    return env.get(\"MAX_UPLOAD_SIZE\", 10485760); // 10MB default\n  }\n}\n```\n\n### Testing with Environment Variables\n\n```typescript\n// tests/.env\nNODE_ENV=test\nPORT=3334\nAPP_KEY=test-app-key-32-characters-long\nHOST=localhost\nLOG_LEVEL=error\n\n# Test database\nDB_HOST=localhost\nDB_PORT=5432\nDB_USER=test_user\nDB_PASSWORD=test_password\nDB_DATABASE=myapp_test\n\n# Disable external services in tests\nENABLE_ANALYTICS=false\nENABLE_EMAIL=false\nSTRIPE_SECRET_KEY=sk_test_fake_key\n```\n\n```typescript\n// tests/unit/services/email_service.spec.ts\nimport { test } from \"@japa/runner\";\nimport env from \"#start/env\";\n\ntest.group(\"Email Service\", () => {\n  test(\"should handle missing SMTP configuration\", async ({ assert }) => {\n    // Temporarily override env for test\n    const originalHost = env.get(\"SMTP_HOST\");\n    process.env.SMTP_HOST = \"\";\n\n    const emailService = new EmailService();\n\n    await assert.rejects(\n      () => emailService.sendEmail(\"test@example.com\", \"Test\", \"Body\"),\n      \"SMTP configuration is missing\",\n    );\n\n    // Restore original value\n    process.env.SMTP_HOST = originalHost;\n  });\n});\n```\n\n### Common Anti-Patterns\n\n```typescript\n// ❌ Incorrect: Hardcoded values\nconst config = {\n  database: {\n    host: \"localhost\",\n    port: 5432,\n    user: \"postgres\",\n  },\n};\n\n// ❌ Incorrect: Direct process.env access\nconst apiKey = process.env.API_KEY;\nconst port = parseInt(process.env.PORT || \"3333\");\n\n// ❌ Incorrect: No validation\nconst requiredValue = env.get(\"REQUIRED_VALUE\"); // Could be undefined\n\n// ❌ Incorrect: Exposing secrets in logs\nconsole.log(\"Database config:\", {\n  host: env.get(\"DB_HOST\"),\n  password: env.get(\"DB_PASSWORD\"), // Don't log passwords!\n});\n\n// ✅ Correct: Safe logging\nconsole.log(\"Database config:\", {\n  host: env.get(\"DB_HOST\"),\n  password: env.get(\"DB_PASSWORD\") ? \"***\" : undefined,\n});\n```\n\n### Environment Variable Documentation\n\nAlways document environment variables in your README.md:\n\n```markdown\n## Environment Variables\n\n### Required\n\n- `APP_KEY`: 32-character application encryption key\n- `DB_HOST`: Database server hostname\n- `DB_PORT`: Database server port\n- `DB_USER`: Database username\n- `DB_PASSWORD`: Database password\n- `DB_DATABASE`: Database name\n\n### Optional\n\n- `REDIS_HOST`: Redis server hostname (default: localhost)\n- `REDIS_PORT`: Redis server port (default: 6379)\n- `ENABLE_ANALYTICS`: Enable analytics tracking (default: true)\n- `LOG_LEVEL`: Application log level (default: info)\n\n### Development Only\n\n- `ENABLE_DEBUG_MODE`: Enable debug mode (default: false)\n- `SMTP_HOST`: SMTP server for local email testing\n```\n\n### Sources\n\n- [Environment Variables](https://docs.adonisjs.com/guides/environment-variables)\n- [Configuration](https://docs.adonisjs.com/guides/configuration)\n- [Validation](https://docs.adonisjs.com/guides/environment-variables#validation)\n"
    },
    {
      "parent": "adonisjs",
      "id": "errors",
      "name": "Error Handling",
      "description": "Error handling patterns and exception management in AdonisJS 6",
      "type": "rule",
      "content": "## Error Handling\n\n### Custom Exceptions\n\nCreate custom exceptions in `app/exceptions/` for specific error scenarios:\n\n```typescript\n// app/exceptions/user_not_found_exception.ts\nimport { Exception } from \"@adonisjs/core/exceptions\";\nimport type { HttpContext } from \"@adonisjs/core/http\";\n\nexport default class UserNotFoundException extends Exception {\n  constructor(userId: number | string) {\n    super(`User with ID ${userId} not found`, {\n      status: 404,\n      code: \"USER_NOT_FOUND\",\n    });\n  }\n\n  async handle(error: this, ctx: HttpContext) {\n    return ctx.response.status(this.status).json({\n      error: this.message,\n      code: this.code,\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n```\n\n```typescript\n// app/exceptions/validation_exception.ts\nimport { Exception } from \"@adonisjs/core/exceptions\";\nimport type { HttpContext } from \"@adonisjs/core/http\";\n\nexport default class ValidationException extends Exception {\n  constructor(\n    message: string,\n    public errors: Record<string, string[]>,\n  ) {\n    super(message, {\n      status: 422,\n      code: \"VALIDATION_ERROR\",\n    });\n  }\n\n  async handle(error: this, ctx: HttpContext) {\n    return ctx.response.status(this.status).json({\n      error: this.message,\n      code: this.code,\n      errors: this.errors,\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n```\n\n```typescript\n// app/exceptions/business_logic_exception.ts\nimport { Exception } from \"@adonisjs/core/exceptions\";\nimport type { HttpContext } from \"@adonisjs/core/http\";\n\nexport default class BusinessLogicException extends Exception {\n  constructor(\n    message: string,\n    public businessCode: string,\n    statusCode: number = 400,\n  ) {\n    super(message, {\n      status: statusCode,\n      code: businessCode,\n    });\n  }\n\n  async handle(error: this, ctx: HttpContext) {\n    return ctx.response.status(this.status).json({\n      error: this.message,\n      code: this.code,\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n```\n\n### Exception Handler\n\nConfigure global exception handling in `app/exceptions/handler.ts`:\n\n```typescript\n// app/exceptions/handler.ts\nimport logger from \"@adonisjs/core/services/logger\";\nimport { ExceptionHandler } from \"@adonisjs/core/exceptions\";\nimport type { HttpContext } from \"@adonisjs/core/http\";\n\nexport default class HttpExceptionHandler extends ExceptionHandler {\n  protected debug = ![\"production\", \"staging\"].includes(\n    process.env.NODE_ENV || \"\",\n  );\n\n  async handle(error: any, ctx: HttpContext) {\n    // ✅ Handle validation errors\n    if (error.code === \"E_VALIDATION_ERROR\") {\n      return ctx.response.status(422).json({\n        error: \"Validation failed\",\n        code: \"VALIDATION_ERROR\",\n        messages: error.messages,\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    // ✅ Handle authentication errors\n    if (error.code === \"E_UNAUTHORIZED_ACCESS\") {\n      return ctx.response.status(401).json({\n        error: \"Authentication required\",\n        code: \"UNAUTHORIZED\",\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    // ✅ Handle route not found\n    if (error.code === \"E_ROUTE_NOT_FOUND\") {\n      return ctx.response.status(404).json({\n        error: \"Route not found\",\n        code: \"ROUTE_NOT_FOUND\",\n        path: ctx.request.url(),\n        method: ctx.request.method(),\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    // ✅ Handle database errors\n    if (error.code === \"23505\") {\n      // Unique constraint violation\n      return ctx.response.status(409).json({\n        error: \"Resource already exists\",\n        code: \"DUPLICATE_RESOURCE\",\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    // ✅ Handle model not found errors\n    if (error.code === \"E_ROW_NOT_FOUND\") {\n      return ctx.response.status(404).json({\n        error: \"Resource not found\",\n        code: \"RESOURCE_NOT_FOUND\",\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    // ✅ Handle rate limiting errors\n    if (error.code === \"E_TOO_MANY_REQUESTS\") {\n      return ctx.response.status(429).json({\n        error: \"Too many requests\",\n        code: \"RATE_LIMIT_EXCEEDED\",\n        retryAfter: error.retryAfter,\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    return super.handle(error, ctx);\n  }\n\n  async report(error: any, ctx: HttpContext) {\n    // ✅ Log errors with context\n    if (this.shouldReport(error)) {\n      logger.error(\"Unhandled exception\", {\n        error: error.message,\n        stack: error.stack,\n        code: error.code,\n        status: error.status,\n        url: ctx.request.url(),\n        method: ctx.request.method(),\n        userId: ctx.auth?.user?.id,\n        ip: ctx.request.ip(),\n        userAgent: ctx.request.header(\"user-agent\"),\n        timestamp: new Date().toISOString(),\n      });\n    }\n\n    return super.report(error, ctx);\n  }\n\n  private shouldReport(error: any): boolean {\n    // ✅ Don't report client errors and validation errors\n    const ignoredCodes = [\n      \"E_VALIDATION_ERROR\",\n      \"E_ROUTE_NOT_FOUND\",\n      \"E_UNAUTHORIZED_ACCESS\",\n      \"E_ROW_NOT_FOUND\",\n    ];\n\n    return !ignoredCodes.includes(error.code) && error.status >= 500;\n  }\n}\n```\n\n### Error Handling in Controllers\n\n```typescript\n// app/controllers/users_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport User from \"#models/user\";\nimport UserService from \"#services/user_service\";\nimport UserNotFoundException from \"#exceptions/user_not_found_exception\";\nimport BusinessLogicException from \"#exceptions/business_logic_exception\";\n\nexport default class UsersController {\n  constructor(private userService: UserService) {}\n\n  // ✅ Let AdonisJS handle exceptions globally\n  async show({ params, response }: HttpContext) {\n    const user = await User.findOrFail(params.id); // Throws 404 automatically\n    return response.json({ data: user });\n  }\n\n  // ✅ Custom exception for business logic\n  async update({ params, request, response }: HttpContext) {\n    const user = await User.findOrFail(params.id);\n    const data = request.only([\"email\", \"name\"]);\n\n    // Throw custom exception when needed\n    if (data.email && !data.email.includes(\"@\")) {\n      throw new ValidationException(\"Invalid email format\");\n    }\n\n    await user.merge(data).save();\n    return response.json({ data: user });\n  }\n\n  // ✅ Validation with global error handling\n  async store({ request, response }: HttpContext) {\n    const data = await request.validateUsing(createUserValidator);\n    const user = await this.userService.createUser(data);\n\n    return response.status(201).json({ data: user });\n  }\n}\n```\n\n### Error Handling in Services\n\n```typescript\n// app/services/user_service.ts\nimport User from \"#models/user\";\nimport UserNotFoundException from \"#exceptions/user_not_found_exception\";\nimport BusinessLogicException from \"#exceptions/business_logic_exception\";\n\nexport default class UserService {\n  // ✅ Service-level error handling\n  async findUser(id: number): Promise<User> {\n    const user = await User.find(id);\n\n    if (!user) {\n      throw new UserNotFoundException(id);\n    }\n\n    return user;\n  }\n\n  async createUser(data: any): Promise<User> {\n    // Only catch specific database errors that need transformation\n    try {\n      return await User.create(data);\n    } catch (error) {\n      // Transform database constraint errors to business exceptions\n      if (error.code === \"23505\") {\n        throw new BusinessLogicException(\n          \"Resource already exists\",\n          \"DUPLICATE_ENTRY\",\n          409,\n        );\n      }\n      throw error;\n    }\n  }\n\n  async updateUser(id: number, data: any): Promise<User> {\n    const user = await this.findUser(id); // Will throw if not found\n\n    try {\n      await user.merge(data).save();\n      return user;\n    } catch (error) {\n      if (error.code === \"23505\") {\n        throw new BusinessLogicException(\n          \"Email address is already taken\",\n          \"EMAIL_ALREADY_EXISTS\",\n          409,\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  async deleteUser(id: number): Promise<void> {\n    const user = await this.findUser(id);\n\n    // Business logic check\n    if (user.role === \"admin\") {\n      throw new BusinessLogicException(\n        \"Admin users cannot be deleted\",\n        \"ADMIN_DELETION_FORBIDDEN\",\n        403,\n      );\n    }\n\n    await user.delete();\n  }\n}\n```\n\n### Error Handling Middleware\n\n```typescript\n// app/middleware/error_boundary_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\nimport logger from \"@adonisjs/core/services/logger\";\n\nexport default class ErrorBoundaryMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    try {\n      return await next();\n    } catch (error) {\n      // ✅ Add request context to error\n      error.requestId =\n        ctx.request.header(\"x-request-id\") || this.generateRequestId();\n      error.url = ctx.request.url();\n      error.method = ctx.request.method();\n      error.userId = ctx.auth?.user?.id;\n\n      // Re-throw to let the global handler deal with it\n      throw error;\n    }\n  }\n\n  private generateRequestId(): string {\n    return Math.random().toString(36).substr(2, 9);\n  }\n}\n```\n\n### API Error Responses\n\n```typescript\n// app/controllers/api/base_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\n\nexport default class BaseApiController {\n  // ✅ Standardized error responses\n  protected errorResponse(\n    ctx: HttpContext,\n    message: string,\n    code: string,\n    statusCode: number = 400,\n    details?: any,\n  ) {\n    return ctx.response.status(statusCode).json({\n      success: false,\n      error: {\n        message,\n        code,\n        details,\n        timestamp: new Date().toISOString(),\n        path: ctx.request.url(),\n        requestId: ctx.request.header(\"x-request-id\"),\n      },\n    });\n  }\n\n  // ✅ Standardized success responses\n  protected successResponse(\n    ctx: HttpContext,\n    data: any,\n    message?: string,\n    statusCode: number = 200,\n  ) {\n    return ctx.response.status(statusCode).json({\n      success: true,\n      data,\n      message,\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n```\n\n### Async Error Handling\n\n```typescript\n// app/services/external_api_service.ts\nexport default class ExternalApiService {\n  // ✅ Handle network and timeout errors\n  async fetchUserData(userId: number): Promise<any> {\n    try {\n      const response = await fetch(`https://api.example.com/users/${userId}`, {\n        timeout: 5000, // 5 second timeout\n        headers: {\n          Authorization: `Bearer ${process.env.API_TOKEN}`,\n          \"Content-Type\": \"application/json\",\n        },\n      });\n\n      if (!response.ok) {\n        throw new BusinessLogicException(\n          `External API error: ${response.statusText}`,\n          \"EXTERNAL_API_ERROR\",\n          response.status,\n        );\n      }\n\n      return await response.json();\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        throw new BusinessLogicException(\n          \"External API request timed out\",\n          \"API_TIMEOUT\",\n          504,\n        );\n      }\n\n      if (error.code === \"ECONNREFUSED\") {\n        throw new BusinessLogicException(\n          \"External API is unavailable\",\n          \"API_UNAVAILABLE\",\n          503,\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  // ✅ Retry logic with exponential backoff\n  async fetchWithRetry<T>(\n    operation: () => Promise<T>,\n    maxRetries: number = 3,\n  ): Promise<T> {\n    let lastError: any;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error;\n\n        // Don't retry client errors (4xx)\n        if (error.status >= 400 && error.status < 500) {\n          throw error;\n        }\n\n        if (attempt === maxRetries) {\n          break;\n        }\n\n        // Exponential backoff\n        const delay = Math.pow(2, attempt) * 1000;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n\n    throw lastError;\n  }\n}\n```\n\n### Database Error Handling\n\n```typescript\n// app/services/database_service.ts\nimport Database from \"@adonisjs/lucid/services/db\";\n\nexport default class DatabaseService {\n  // ✅ Transaction error handling\n  async performComplexOperation(data: any) {\n    const trx = await Database.transaction();\n\n    try {\n      const user = await User.create(data.user, { client: trx });\n      const profile = await Profile.create(\n        {\n          ...data.profile,\n          userId: user.id,\n        },\n        { client: trx },\n      );\n\n      await trx.commit();\n      return { user, profile };\n    } catch (error) {\n      await trx.rollback();\n\n      // Handle specific database errors\n      if (error.code === \"23505\") {\n        throw new BusinessLogicException(\n          \"Duplicate entry detected\",\n          \"DUPLICATE_ENTRY\",\n          409,\n        );\n      }\n\n      if (error.code === \"23503\") {\n        throw new BusinessLogicException(\n          \"Foreign key constraint violation\",\n          \"INVALID_REFERENCE\",\n          400,\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  // ✅ Connection error handling\n  async checkDatabaseHealth(): Promise<boolean> {\n    try {\n      await Database.rawQuery(\"SELECT 1\");\n      return true;\n    } catch (error) {\n      logger.error(\"Database health check failed\", { error: error.message });\n      return false;\n    }\n  }\n}\n```\n\n### Error Monitoring\n\n```typescript\n// app/services/error_monitoring_service.ts\nimport logger from \"@adonisjs/core/services/logger\";\n\nexport default class ErrorMonitoringService {\n  // ✅ Track error metrics\n  async trackError(error: any, context: Record<string, any> = {}) {\n    const errorData = {\n      message: error.message,\n      stack: error.stack,\n      code: error.code,\n      status: error.status,\n      timestamp: new Date().toISOString(),\n      environment: process.env.NODE_ENV,\n      ...context,\n    };\n\n    // Log the error\n    logger.error(\"Application error\", errorData);\n\n    // Send to external monitoring service in production\n    if (process.env.NODE_ENV === \"production\") {\n      await this.sendToMonitoringService(errorData);\n    }\n  }\n\n  private async sendToMonitoringService(errorData: any) {\n    try {\n      // Send to Sentry, LogRocket, or other monitoring service\n      // await sentry.captureException(errorData)\n    } catch (monitoringError) {\n      logger.error(\"Failed to send error to monitoring service\", {\n        originalError: errorData,\n        monitoringError: monitoringError.message,\n      });\n    }\n  }\n\n  // ✅ Track performance issues\n  async trackSlowOperation(\n    operation: string,\n    duration: number,\n    threshold: number = 1000,\n  ) {\n    if (duration > threshold) {\n      logger.warn(\"Slow operation detected\", {\n        operation,\n        duration: `${duration}ms`,\n        threshold: `${threshold}ms`,\n        timestamp: new Date().toISOString(),\n      });\n    }\n  }\n}\n```\n\n### Error Handling Best Practices\n\n#### DO's\n\n```typescript\n// ✅ Use specific exception types\nthrow new UserNotFoundException(userId);\n\n// ✅ Provide meaningful error messages\nthrow new BusinessLogicException(\n  \"User cannot delete their own account\",\n  \"SELF_DELETION_FORBIDDEN\",\n);\n\n// ✅ Let AdonisJS handle rejections globally\nawait someAsyncOperation(); // Exceptions bubble up to global handler\n\n// ✅ Only use try-catch when transforming errors\ntry {\n  await riskyDatabaseOperation();\n} catch (error) {\n  // Transform specific errors into business exceptions\n  if (error.code === \"SPECIFIC_DB_ERROR\") {\n    throw new BusinessLogicException(\"User-friendly message\", \"BUSINESS_CODE\");\n  }\n  throw error;\n}\n\n// ✅ Use proper HTTP status codes\nreturn response.status(404).json({ error: \"Resource not found\" });\n\n// ✅ Log errors with context\nlogger.error(\"Operation failed\", {\n  userId,\n  operation: \"updateProfile\",\n  error: error.message,\n});\n```\n\n#### DON'Ts\n\n```typescript\n// ❌ Generic error handling\nthrow new Error(\"Something went wrong\");\n\n// ❌ Swallowing errors\ntry {\n  await riskyOperation();\n} catch {\n  // Ignoring error\n}\n\n// ❌ Exposing sensitive information\nthrow new Error(`Database connection failed: ${dbPassword}`);\n\n// ❌ Not using appropriate status codes\nreturn response.status(200).json({ error: \"Not found\" });\n\n// ❌ Synchronous operations that might throw\nconst data = JSON.parse(untrustedInput); // Can throw\n```\n\n### Testing Error Handling\n\n```typescript\n// tests/unit/services/user_service.spec.ts\nimport { test } from \"@japa/runner\";\nimport UserService from \"#services/user_service\";\nimport UserNotFoundException from \"#exceptions/user_not_found_exception\";\n\ntest.group(\"User Service Error Handling\", () => {\n  test(\"should throw UserNotFoundException for non-existent user\", async ({\n    assert,\n  }) => {\n    const userService = new UserService();\n\n    await assert.rejects(\n      () => userService.findUser(999),\n      UserNotFoundException,\n    );\n  });\n\n  test(\"should handle duplicate email gracefully\", async ({ assert }) => {\n    const userService = new UserService();\n\n    await UserFactory.create({ email: \"test@example.com\" });\n\n    await assert.rejects(\n      () =>\n        userService.createUser({\n          email: \"test@example.com\",\n          password: \"password\",\n          name: \"Test User\",\n        }),\n      \"Email address is already registered\",\n    );\n  });\n});\n```\n\n### Sources\n\n- [Exception Handling](https://docs.adonisjs.com/guides/exception-handling)\n- [Custom Exceptions](https://docs.adonisjs.com/guides/exception-handling#custom-exceptions)\n- [Error Reporting](https://docs.adonisjs.com/guides/exception-handling#error-reporting)\n- [HTTP Status Codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)\n"
    },
    {
      "parent": "adonisjs",
      "id": "middleware",
      "name": "Middleware",
      "description": "Guidelines for middleware usage and creation in AdonisJS 6",
      "type": "rule",
      "content": "## Middleware\n\n### Middleware Structure\n\nMiddleware MUST be placed in `app/middleware/` and follow these patterns:\n\n#### Basic Middleware Structure\n\n```typescript\n// app/middleware/auth_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\n\nexport default class AuthMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    // Downstream logic (before route handler)\n    const { auth, response } = ctx;\n\n    try {\n      await auth.check();\n    } catch {\n      return response.unauthorized({ error: \"Unauthorized access\" });\n    }\n\n    // Continue to next middleware or route handler\n    const result = await next();\n\n    // Upstream logic (after route handler)\n    // Optional: Modify response or perform cleanup\n\n    return result;\n  }\n}\n```\n\n#### Middleware with Parameters\n\n```typescript\n// app/middleware/role_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\n\nexport default class RoleMiddleware {\n  async handle(ctx: HttpContext, next: NextFn, options: { roles: string[] }) {\n    const { auth, response } = ctx;\n    const user = auth.getUserOrFail();\n\n    if (!options.roles.includes(user.role)) {\n      return response.forbidden({\n        error: \"Insufficient permissions\",\n        required_roles: options.roles,\n      });\n    }\n\n    return await next();\n  }\n}\n```\n\n### Middleware Registration\n\nMiddleware must be registered in `start/kernel.ts`:\n\n```typescript\n// start/kernel.ts\nimport router from \"@adonisjs/core/services/router\";\nimport server from \"@adonisjs/core/services/server\";\n\n// ✅ Correct: Server middleware (runs on every request)\nserver.use([\n  () => import(\"@adonisjs/cors/cors_middleware\"),\n  () => import(\"@adonisjs/static/static_middleware\"),\n]);\n\n// ✅ Correct: Router middleware (runs on matched routes)\nrouter.use([\n  () => import(\"@adonisjs/core/bodyparser_middleware\"),\n  () => import(\"@adonisjs/session/session_middleware\"),\n]);\n\n// ✅ Correct: Named middleware registration\nexport const middleware = router.named({\n  auth: () => import(\"#middleware/auth_middleware\"),\n  guest: () => import(\"#middleware/guest_middleware\"),\n  role: () => import(\"#middleware/role_middleware\"),\n  throttle: () => import(\"#middleware/throttle_middleware\"),\n  cors: () => import(\"#middleware/cors_middleware\"),\n});\n```\n\n### Middleware Usage\n\n```typescript\n// start/routes.ts\nimport router from \"@adonisjs/core/services/router\";\nimport { middleware } from \"./kernel.js\";\n\n// ✅ Correct: Single middleware\nrouter\n  .get(\"profile\", \"#controllers/users_controller.profile\")\n  .middleware([middleware.auth()]);\n\n// ✅ Correct: Multiple middleware\nrouter\n  .post(\"admin/users\", \"#controllers/admin/users_controller.store\")\n  .middleware([middleware.auth(), middleware.role({ roles: [\"admin\"] })]);\n\n// ✅ Correct: Route group with middleware\nrouter\n  .group(() => {\n    router.resource(\"posts\", \"#controllers/posts_controller\");\n    router.resource(\"comments\", \"#controllers/comments_controller\");\n  })\n  .prefix(\"api\")\n  .middleware([middleware.auth()]);\n\n// ✅ Correct: Conditional middleware\nrouter\n  .get(\"public-data\", \"#controllers/data_controller.public\")\n  .middleware([middleware.throttle({ max: 100, duration: \"1m\" })]);\n```\n\n### Common Middleware Patterns\n\n#### Authentication Middleware\n\n```typescript\n// app/middleware/auth_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\n\nexport default class AuthMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    const { auth, response } = ctx;\n\n    try {\n      await auth.check();\n\n      // Optional: Add user to context for easy access\n      ctx.user = auth.user!;\n    } catch {\n      return response.unauthorized({\n        error: \"Authentication required\",\n        code: \"UNAUTHORIZED\",\n      });\n    }\n\n    return await next();\n  }\n}\n```\n\n#### Rate Limiting Middleware\n\n```typescript\n// app/middleware/throttle_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\nimport redis from \"@adonisjs/redis/services/main\";\n\nexport default class ThrottleMiddleware {\n  async handle(\n    ctx: HttpContext,\n    next: NextFn,\n    options: { max: number; duration: string },\n  ) {\n    const { request, response } = ctx;\n    const key = `throttle:${request.ip()}:${request.url()}`;\n\n    const attempts = await redis.get(key);\n    const maxAttempts = options.max;\n\n    if (attempts && parseInt(attempts) >= maxAttempts) {\n      return response.tooManyRequests({\n        error: \"Rate limit exceeded\",\n      });\n    }\n\n    // Increment counter\n    const ttl = options.duration === \"1h\" ? 3600 : 60; // Simple duration parsing\n    await redis.setex(key, ttl, attempts ? parseInt(attempts) + 1 : 1);\n\n    const result = await next();\n\n    // Add rate limit headers\n    response.header(\"X-RateLimit-Limit\", maxAttempts.toString());\n    response.header(\n      \"X-RateLimit-Remaining\",\n      (maxAttempts - parseInt(attempts || \"0\") - 1).toString(),\n    );\n\n    return result;\n  }\n}\n```\n\n#### CORS Middleware\n\n```typescript\n// app/middleware/cors_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\n\nexport default class CorsMiddleware {\n  async handle(\n    ctx: HttpContext,\n    next: NextFn,\n    options: {\n      origin?: string;\n      methods?: string[];\n    } = {},\n  ) {\n    const { request, response } = ctx;\n\n    // Set CORS headers\n    response.header(\"Access-Control-Allow-Origin\", options.origin || \"*\");\n    response.header(\n      \"Access-Control-Allow-Methods\",\n      options.methods?.join(\", \") || \"GET, POST, PUT, DELETE\",\n    );\n    response.header(\n      \"Access-Control-Allow-Headers\",\n      \"Content-Type, Authorization\",\n    );\n\n    // Handle preflight requests\n    if (request.method() === \"OPTIONS\") {\n      return response.status(204).send(\"\");\n    }\n\n    return await next();\n  }\n}\n```\n\n#### Logging Middleware\n\n```typescript\n// app/middleware/logger_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\nimport logger from \"@adonisjs/core/services/logger\";\n\nexport default class LoggerMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    const { request } = ctx;\n    const startTime = Date.now();\n\n    // Log incoming request\n    logger.info(\"Request started\", {\n      method: request.method(),\n      url: request.url(),\n      ip: request.ip(),\n    });\n\n    try {\n      const result = await next();\n\n      // Log successful response\n      const duration = Date.now() - startTime;\n      logger.info(\"Request completed\", {\n        method: request.method(),\n        url: request.url(),\n        status: ctx.response.getStatus(),\n        duration: `${duration}ms`,\n      });\n\n      return result;\n    } catch (error) {\n      // Log error\n      logger.error(\"Request failed\", {\n        method: request.method(),\n        url: request.url(),\n        error: error.message,\n      });\n\n      throw error;\n    }\n  }\n}\n```\n\n#### Validation Middleware\n\n```typescript\n// app/middleware/validate_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\nimport vine from \"@vinejs/vine\";\n\nexport default class ValidateMiddleware {\n  async handle(ctx: HttpContext, next: NextFn, options: { schema: any }) {\n    const { request, response } = ctx;\n\n    try {\n      const validatedData = await vine.validate({\n        schema: options.schema,\n        data: request.all(),\n      });\n\n      // Add validated data to context\n      ctx.validatedData = validatedData;\n    } catch (error) {\n      return response.badRequest({\n        error: \"Validation failed\",\n        messages: error.messages,\n      });\n    }\n\n    return await next();\n  }\n}\n```\n\n### Middleware Testing\n\n```typescript\n// tests/unit/middleware/auth_middleware.spec.ts\nimport { test } from \"@japa/runner\";\nimport { HttpContextFactory } from \"@adonisjs/core/factories/http\";\nimport AuthMiddleware from \"#middleware/auth_middleware\";\n\ntest.group(\"Auth Middleware\", () => {\n  test(\"should allow authenticated users\", async ({ assert }) => {\n    const ctx = new HttpContextFactory().create();\n    const middleware = new AuthMiddleware();\n\n    // Mock authenticated user\n    ctx.auth.user = { id: 1, email: \"test@example.com\" };\n    ctx.auth.check = async () => true;\n\n    let nextCalled = false;\n    const next = async () => {\n      nextCalled = true;\n      return \"success\";\n    };\n\n    const result = await middleware.handle(ctx, next);\n\n    assert.isTrue(nextCalled);\n    assert.equal(result, \"success\");\n  });\n\n  test(\"should reject unauthenticated users\", async ({ assert }) => {\n    const ctx = new HttpContextFactory().create();\n    const middleware = new AuthMiddleware();\n\n    // Mock unauthenticated user\n    ctx.auth.check = async () => {\n      throw new Error(\"Unauthenticated\");\n    };\n\n    let nextCalled = false;\n    const next = async () => {\n      nextCalled = true;\n      return \"success\";\n    };\n\n    await middleware.handle(ctx, next);\n\n    assert.isFalse(nextCalled);\n    assert.equal(ctx.response.getStatus(), 401);\n  });\n});\n```\n\n### Middleware Best Practices\n\n#### DO's\n\n- ALWAYS use TypeScript types for middleware parameters\n- ALWAYS handle errors gracefully\n- ALWAYS call `await next()` to continue the chain\n- ALWAYS use dependency injection for services\n- ALWAYS add appropriate response headers\n- ALWAYS validate middleware options\n- ALWAYS test middleware thoroughly\n\n#### DON'Ts\n\n```typescript\n// ❌ Incorrect: Not calling next()\nasync handle(ctx: HttpContext, next: NextFn) {\n  // Logic here\n  // Missing: await next()\n}\n\n// ❌ Incorrect: Not handling errors\nasync handle(ctx: HttpContext, next: NextFn) {\n  await auth.check() // Can throw error\n  return await next()\n}\n\n// ❌ Incorrect: Blocking I/O operations\nasync handle(ctx: HttpContext, next: NextFn) {\n  // Synchronous file operation\n  const data = fs.readFileSync('/path/to/file')\n  return await next()\n}\n\n// ❌ Incorrect: Not typing parameters\nasync handle(ctx: any, next: any, options?: any) {\n  // No type safety\n}\n```\n\n### Global vs Named Middleware\n\n```typescript\n// ✅ Correct: Use server middleware for cross-cutting concerns\nserver.use([\n  () => import(\"@adonisjs/cors/cors_middleware\"), // CORS for all routes\n  () => import(\"#middleware/logger_middleware\"), // Logging for all requests\n]);\n\n// ✅ Correct: Use router middleware for route-specific logic\nrouter.use([\n  () => import(\"@adonisjs/core/bodyparser_middleware\"), // Parse request body\n  () => import(\"@adonisjs/session/session_middleware\"), // Session handling\n]);\n\n// ✅ Correct: Use named middleware for optional features\nexport const middleware = router.named({\n  auth: () => import(\"#middleware/auth_middleware\"), // Authentication\n  admin: () => import(\"#middleware/admin_middleware\"), // Admin access\n  throttle: () => import(\"#middleware/throttle_middleware\"), // Rate limiting\n});\n```\n\n### Sources\n\n- [Middleware Documentation](https://docs.adonisjs.com/guides/middleware)\n- [HTTP Context](https://docs.adonisjs.com/guides/context)\n- [Middleware Testing](https://docs.adonisjs.com/guides/testing)\n"
    },
    {
      "parent": "adonisjs",
      "id": "models",
      "name": "Models",
      "description": "Guidelines for Lucid ORM models and database operations in AdonisJS 6",
      "type": "rule",
      "content": "## Models and Lucid ORM\n\n### Model Definition\n\nModels MUST be placed in `app/models/` and follow these patterns:\n\n#### Basic Model Structure\n\n```typescript\n// app/models/user.ts\nimport { DateTime } from \"luxon\";\nimport { BaseModel, column, hasMany } from \"@adonisjs/lucid/orm\";\nimport type { HasMany } from \"@adonisjs/lucid/types/relations\";\nimport Post from \"./post.js\";\n\nexport default class User extends BaseModel {\n  @column({ isPrimary: true })\n  declare id: number;\n\n  @column()\n  declare email: string;\n\n  @column()\n  declare username: string;\n\n  @column({ serializeAs: null }) // Don't serialize password\n  declare password: string;\n\n  @column()\n  declare fullName: string;\n\n  @column()\n  declare isActive: boolean;\n\n  @column.dateTime({ autoCreate: true })\n  declare createdAt: DateTime;\n\n  @column.dateTime({ autoCreate: true, autoUpdate: true })\n  declare updatedAt: DateTime;\n\n  // Relationships\n  @hasMany(() => Post)\n  declare posts: HasMany<typeof Post>;\n}\n```\n\n#### Model Naming Conventions\n\n- Model class names MUST be PascalCase and singular (e.g., `User`, `BlogPost`)\n- File names MUST be snake_case and singular (e.g., `user.ts`, `blog_post.ts`)\n- Table names are automatically inferred as snake_case plural (e.g., `users`, `blog_posts`)\n- ALWAYS use explicit `declare` for TypeScript properties\n\n### Column Decorators\n\n```typescript\nexport default class User extends BaseModel {\n  // ✅ Correct: Primary key\n  @column({ isPrimary: true })\n  declare id: number;\n\n  // ✅ Correct: Custom column name\n  @column({ columnName: \"full_name\" })\n  declare fullName: string;\n\n  // ✅ Correct: Don't serialize sensitive data\n  @column({ serializeAs: null })\n  declare password: string;\n\n  // ✅ Correct: Custom serialization name\n  @column({ serializeAs: \"display_name\" })\n  declare fullName: string;\n\n  // ✅ Correct: Data transformation\n  @column({\n    prepare: (value: string) => value.toLowerCase(),\n    consume: (value: string) => value.toUpperCase(),\n  })\n  declare email: string;\n\n  // ✅ Correct: Auto timestamps\n  @column.dateTime({ autoCreate: true })\n  declare createdAt: DateTime;\n\n  @column.dateTime({ autoCreate: true, autoUpdate: true })\n  declare updatedAt: DateTime;\n\n  // ✅ Correct: Custom datetime column\n  @column.dateTime()\n  declare lastLoginAt: DateTime | null;\n}\n```\n\n### Relationships\n\n```typescript\n// app/models/user.ts\nimport { BaseModel, column, hasMany, hasOne } from \"@adonisjs/lucid/orm\";\nimport type { HasMany, HasOne } from \"@adonisjs/lucid/types/relations\";\nimport Post from \"./post.js\";\nimport Profile from \"./profile.js\";\n\nexport default class User extends BaseModel {\n  @column({ isPrimary: true })\n  declare id: number;\n\n  // ✅ Correct: One-to-many relationship\n  @hasMany(() => Post)\n  declare posts: HasMany<typeof Post>;\n\n  // ✅ Correct: One-to-one relationship\n  @hasOne(() => Profile)\n  declare profile: HasOne<typeof Profile>;\n\n  // ✅ Correct: Custom foreign key\n  @hasMany(() => Post, {\n    foreignKey: \"authorId\",\n  })\n  declare posts: HasMany<typeof Post>;\n}\n\n// app/models/post.ts\nimport { BaseModel, column, belongsTo, manyToMany } from \"@adonisjs/lucid/orm\";\nimport type { BelongsTo, ManyToMany } from \"@adonisjs/lucid/types/relations\";\nimport User from \"./user.js\";\nimport Tag from \"./tag.js\";\n\nexport default class Post extends BaseModel {\n  @column({ isPrimary: true })\n  declare id: number;\n\n  @column()\n  declare userId: number;\n\n  @column()\n  declare title: string;\n\n  // ✅ Correct: Belongs to relationship\n  @belongsTo(() => User)\n  declare author: BelongsTo<typeof User>;\n\n  // ✅ Correct: Many-to-many relationship\n  @manyToMany(() => Tag)\n  declare tags: ManyToMany<typeof Tag>;\n\n  // ✅ Correct: Custom pivot table\n  @manyToMany(() => Tag, {\n    pivotTable: \"post_tags\",\n    pivotForeignKey: \"post_id\",\n    pivotRelatedForeignKey: \"tag_id\",\n  })\n  declare tags: ManyToMany<typeof Tag>;\n}\n```\n\n### Query Patterns\n\n```typescript\n// ✅ Correct: Basic queries\nexport default class UserService {\n  async getAllUsers() {\n    return await User.all();\n  }\n\n  async findUser(id: number) {\n    return await User.find(id); // Returns null if not found\n  }\n\n  async findUserOrFail(id: number) {\n    return await User.findOrFail(id); // Throws exception if not found\n  }\n\n  async findByEmail(email: string) {\n    return await User.findBy(\"email\", email);\n  }\n\n  // ✅ Correct: Query builder\n  async getActiveUsers() {\n    return await User.query()\n      .where(\"isActive\", true)\n      .orderBy(\"createdAt\", \"desc\")\n      .limit(50);\n  }\n\n  // ✅ Correct: Queries with relationships\n  async getUsersWithPosts() {\n    return await User.query().preload(\"posts\").where(\"isActive\", true);\n  }\n\n  // ✅ Correct: Pagination\n  async getUsersPaginated(page: number, limit: number = 20) {\n    return await User.query().paginate(page, limit);\n  }\n\n  // ✅ Correct: Aggregation\n  async getUserStats() {\n    return await User.query().count(\"* as total\").first();\n  }\n}\n```\n\n### Model Hooks\n\n```typescript\n// app/models/user.ts\nimport { BaseModel, column, beforeSave } from \"@adonisjs/lucid/orm\";\nimport hash from \"@adonisjs/core/services/hash\";\n\nexport default class User extends BaseModel {\n  @column({ isPrimary: true })\n  declare id: number;\n\n  @column()\n  declare email: string;\n\n  @column({ serializeAs: null })\n  declare password: string;\n\n  // ✅ Correct: Hash password before saving\n  @beforeSave()\n  static async hashPassword(user: User) {\n    if (user.$dirty.password) {\n      user.password = await hash.make(user.password);\n    }\n  }\n\n  // ✅ Correct: Custom methods\n  async verifyPassword(plainPassword: string) {\n    return await hash.verify(this.password, plainPassword);\n  }\n}\n```\n\n### Model Configuration\n\n```typescript\nexport default class User extends BaseModel {\n  // ✅ Correct: Custom table name\n  static table = \"app_users\";\n\n  // ✅ Correct: Custom primary key\n  static primaryKey = \"userId\";\n\n  // ✅ Correct: Self-assigned primary key (UUIDs)\n  static selfAssignPrimaryKey = true;\n\n  // ✅ Correct: Custom connection\n  static connection = \"pg\";\n\n  // ✅ Correct: Disable timestamps\n  static timestamps = false;\n\n  // ✅ Correct: Custom timestamp columns\n  static createdAtColumn = \"created_at\";\n  static updatedAtColumn = \"updated_at\";\n}\n```\n\n### Scopes\n\n```typescript\n// app/models/user.ts\nexport default class User extends BaseModel {\n  @column({ isPrimary: true })\n  declare id: number;\n\n  @column()\n  declare isActive: boolean;\n\n  @column()\n  declare role: string;\n\n  // ✅ Correct: Local scopes\n  static scopeActive(query: any) {\n    query.where(\"isActive\", true);\n  }\n\n  static scopeByRole(query: any, role: string) {\n    query.where(\"role\", role);\n  }\n}\n\n// Usage\nconst activeUsers = await User.query().active();\nconst admins = await User.query().byRole(\"admin\");\n```\n\n### CRUD Operations\n\n```typescript\nexport default class UserService {\n  // ✅ Correct: Create\n  async createUser(data: {\n    email: string;\n    password: string;\n    fullName: string;\n  }) {\n    return await User.create(data);\n  }\n\n  // ✅ Correct: Update\n  async updateUser(\n    id: number,\n    data: Partial<{ email: string; fullName: string }>,\n  ) {\n    const user = await User.findOrFail(id);\n    user.merge(data);\n    await user.save();\n    return user;\n  }\n\n  // ✅ Correct: Delete\n  async deleteUser(id: number) {\n    const user = await User.findOrFail(id);\n    await user.delete();\n  }\n\n  // ✅ Correct: Bulk operations\n  async updateMultipleUsers(userIds: number[], data: any) {\n    await User.query().whereIn(\"id\", userIds).update(data);\n  }\n}\n```\n\n### Model Testing\n\n```typescript\n// tests/unit/models/user.spec.ts\nimport { test } from \"@japa/runner\";\nimport User from \"#models/user\";\n\ntest.group(\"User Model\", () => {\n  test(\"should hash password before saving\", async ({ assert }) => {\n    const user = new User();\n    user.email = \"test@example.com\";\n    user.password = \"plaintext\";\n\n    await user.save();\n\n    assert.notEqual(user.password, \"plaintext\");\n    assert.isTrue(await user.verifyPassword(\"plaintext\"));\n  });\n\n  test(\"should create user with valid data\", async ({ assert }) => {\n    const user = await User.create({\n      email: \"test@example.com\",\n      password: \"password123\",\n      fullName: \"Test User\",\n    });\n\n    assert.equal(user.email, \"test@example.com\");\n    assert.equal(user.fullName, \"Test User\");\n    assert.exists(user.id);\n  });\n});\n```\n\n### Common Anti-Patterns\n\n```typescript\n// ❌ Incorrect: Raw queries in controllers\nasync index({ response }: HttpContext) {\n  const users = await Database.rawQuery('SELECT * FROM users')\n  return response.json(users)\n}\n\n// ✅ Correct: Use model methods\nasync index({ response }: HttpContext) {\n  const users = await User.all()\n  return response.json(users)\n}\n\n// ❌ Incorrect: Not using relationships\nasync getUserPosts(userId: number) {\n  const posts = await Database.from('posts').where('user_id', userId)\n  return posts\n}\n\n// ✅ Correct: Use relationships\nasync getUserPosts(userId: number) {\n  const user = await User.query()\n    .where('id', userId)\n    .preload('posts')\n    .firstOrFail()\n\n  return user.posts\n}\n\n// ❌ Incorrect: Not using query builder\nasync searchUsers(searchTerm: string) {\n  const sql = `SELECT * FROM users WHERE email LIKE '%${searchTerm}%'`\n  return await Database.rawQuery(sql)\n}\n\n// ✅ Correct: Use query builder\nasync searchUsers(searchTerm: string) {\n  return await User.query()\n    .where('email', 'like', `%${searchTerm}%`)\n    .orWhere('fullName', 'like', `%${searchTerm}%`)\n}\n```\n\n### Sources\n\n- [Lucid ORM Documentation](https://lucid.adonisjs.com)\n- [Models Guide](https://lucid.adonisjs.com/docs/models)\n- [Relationships](https://lucid.adonisjs.com/docs/relationships)\n- [Query Builder](https://lucid.adonisjs.com/docs/select-query-builder)\n"
    },
    {
      "parent": "adonisjs",
      "id": "performance",
      "name": "Performance",
      "description": "Performance optimization guidelines for AdonisJS 6",
      "type": "rule",
      "content": "## Performance Optimization\n\n### Database Performance\n\n#### Query Optimization\n\n```typescript\n// ✅ Correct: Efficient database queries\nexport default class PostService {\n  // Use eager loading to prevent N+1 queries\n  async getPostsWithAuthors() {\n    return await Post.query()\n      .preload(\"author\")\n      .preload(\"comments\", (query) => {\n        query.preload(\"user\");\n        query.orderBy(\"createdAt\", \"desc\");\n        query.limit(5);\n      })\n      .orderBy(\"createdAt\", \"desc\")\n      .limit(20);\n  }\n\n  // Use pagination for large datasets\n  async getPostsPaginated(page: number, limit: number = 20) {\n    return await Post.query()\n      .preload(\"author\", (query) => {\n        query.select([\"id\", \"name\", \"avatar\"]);\n      })\n      .paginate(page, limit);\n  }\n\n  // Use specific columns selection\n  async getPostTitles() {\n    return await Post.query()\n      .select([\"id\", \"title\", \"slug\", \"publishedAt\"])\n      .where(\"published\", true)\n      .orderBy(\"publishedAt\", \"desc\");\n  }\n\n  // Use database-level aggregation\n  async getPostStats() {\n    return await Post.query()\n      .count(\"* as total\")\n      .countDistinct(\"userId as unique_authors\")\n      .where(\"published\", true)\n      .first();\n  }\n}\n```\n\n#### Database Indexing\n\n```sql\n-- ✅ Create indexes for frequently queried columns\nCREATE INDEX idx_posts_published ON posts(published);\nCREATE INDEX idx_posts_user_id ON posts(user_id);\nCREATE INDEX idx_posts_created_at ON posts(created_at);\n\n-- ✅ Composite indexes for complex queries\nCREATE INDEX idx_posts_published_created ON posts(published, created_at);\nCREATE INDEX idx_users_email_active ON users(email, is_active);\n\n-- ✅ Partial indexes for better performance\nCREATE INDEX idx_posts_published_only ON posts(created_at) WHERE published = true;\n```\n\n#### Connection Pooling\n\n```typescript\n// config/database.ts\nexport default {\n  connection: \"pg\",\n  connections: {\n    pg: {\n      client: \"pg\",\n      connection: {\n        host: env.get(\"DB_HOST\"),\n        port: env.get(\"DB_PORT\"),\n        user: env.get(\"DB_USER\"),\n        password: env.get(\"DB_PASSWORD\"),\n        database: env.get(\"DB_DATABASE\"),\n      },\n      // ✅ Optimize connection pool\n      pool: {\n        min: 2,\n        max: 10,\n        acquireTimeoutMillis: 60000,\n        createTimeoutMillis: 30000,\n        destroyTimeoutMillis: 5000,\n        idleTimeoutMillis: 30000,\n        reapIntervalMillis: 1000,\n        createRetryIntervalMillis: 100,\n      },\n      // ✅ Enable debugging in development only\n      debug: env.get(\"NODE_ENV\") === \"development\",\n    },\n  },\n};\n```\n\n### Caching Strategies\n\n#### Redis Caching\n\n```typescript\n// app/services/cache_service.ts\nimport redis from \"@adonisjs/redis/services/main\";\n\nexport default class CacheService {\n  // ✅ Cache user data\n  async getUser(id: number): Promise<User | null> {\n    const cacheKey = `user:${id}`;\n\n    // Try cache first\n    const cached = await redis.get(cacheKey);\n    if (cached) {\n      return JSON.parse(cached);\n    }\n\n    // Get from database and cache\n    const user = await User.find(id);\n    if (user) {\n      await redis.setex(cacheKey, 3600, JSON.stringify(user));\n    }\n\n    return user;\n  }\n\n  // ✅ Cache popular posts\n  async getPopularPosts(): Promise<Post[]> {\n    const cacheKey = \"posts:popular\";\n\n    const cached = await redis.get(cacheKey);\n    if (cached) {\n      return JSON.parse(cached);\n    }\n\n    const posts = await Post.query()\n      .preload(\"author\")\n      .orderBy(\"views\", \"desc\")\n      .limit(10);\n\n    await redis.setex(cacheKey, 900, JSON.stringify(posts));\n    return posts;\n  }\n\n  // ✅ Cache invalidation\n  async invalidateUserCache(userId: number) {\n    await redis.del(`user:${userId}`);\n  }\n}\n```\n\n#### HTTP Response Caching\n\n```typescript\n// app/middleware/cache_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\nimport redis from \"@adonisjs/redis/services/main\";\n\nexport default class CacheMiddleware {\n  async handle(ctx: HttpContext, next: NextFn, options: { ttl?: number } = {}) {\n    const { request, response } = ctx;\n\n    // Only cache GET requests\n    if (request.method() !== \"GET\") {\n      return await next();\n    }\n\n    const cacheKey = `http:${request.url()}`;\n    const ttl = options.ttl || 300; // 5 minutes\n\n    // Check cache\n    const cached = await redis.get(cacheKey);\n    if (cached) {\n      response.header(\"X-Cache\", \"HIT\");\n      return response.json(JSON.parse(cached));\n    }\n\n    // Execute request\n    const result = await next();\n\n    // Cache 200 responses\n    if (response.getStatus() === 200) {\n      await redis.setex(cacheKey, ttl, JSON.stringify(response.getBody()));\n      response.header(\"X-Cache\", \"MISS\");\n    }\n\n    return result;\n  }\n}\n```\n\n### Memory Optimization\n\n```typescript\n// ✅ Use Maps for caching\nexport default class UserService {\n  private userCache = new Map<number, User>();\n\n  async getUserByEmail(email: string): Promise<User | null> {\n    const user = await User.findBy(\"email\", email);\n    if (user) {\n      this.userCache.set(user.id, user);\n    }\n    return user;\n  }\n\n  // ✅ Clean up cache periodically\n  private cleanupCache() {\n    if (this.userCache.size > 1000) {\n      this.userCache.clear();\n    }\n  }\n}\n```\n\n#### Streaming Large Files\n\n```typescript\n// app/controllers/reports_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport { createReadStream } from \"node:fs\";\n\nexport default class ReportsController {\n  // ✅ Stream files instead of loading into memory\n  async downloadReport({ response, params }: HttpContext) {\n    const filename = `report-${params.id}.csv`;\n    const filepath = `./storage/reports/${filename}`;\n\n    response.header(\"Content-Type\", \"text/csv\");\n    response.header(\n      \"Content-Disposition\",\n      `attachment; filename=\"${filename}\"`,\n    );\n\n    const stream = createReadStream(filepath);\n    return response.stream(stream);\n  }\n\n  // ✅ Process data in chunks\n  async generateReport({ response }: HttpContext) {\n    response.header(\"Content-Type\", \"application/json\");\n\n    const users = await User.query().limit(1000);\n    return response.json({ data: users });\n  }\n}\n```\n\n### API Performance\n\n#### Response Optimization\n\n```typescript\n// app/controllers/api/posts_controller.ts\nexport default class PostsController {\n  // ✅ Implement field selection\n  async index({ request, response }: HttpContext) {\n    const fields = request.input(\"fields\", \"\").split(\",\").filter(Boolean);\n    const query = Post.query();\n\n    if (fields.length > 0) {\n      // Only select requested fields\n      query.select(fields);\n    }\n\n    // ✅ Implement cursor-based pagination for better performance\n    const cursor = request.input(\"cursor\");\n    const limit = Math.min(request.input(\"limit\", 20), 100);\n\n    if (cursor) {\n      query.where(\"id\", \">\", cursor);\n    }\n\n    const posts = await query\n      .preload(\"author\", (authorQuery) => {\n        authorQuery.select([\"id\", \"name\", \"avatar\"]);\n      })\n      .orderBy(\"id\", \"asc\")\n      .limit(limit);\n\n    const nextCursor =\n      posts.length === limit ? posts[posts.length - 1].id : null;\n\n    return response.json({\n      data: posts,\n      pagination: {\n        nextCursor,\n        hasMore: posts.length === limit,\n      },\n    });\n  }\n\n  // ✅ Implement ETags for caching\n  async show({ params, response }: HttpContext) {\n    const post = await Post.query()\n      .where(\"id\", params.id)\n      .preload(\"author\")\n      .firstOrFail();\n\n    // Generate ETag based on updated timestamp\n    const etag = `\"${post.updatedAt.toMillis()}\"`;\n    response.header(\"ETag\", etag);\n    response.header(\"Cache-Control\", \"max-age=300\"); // 5 minutes\n\n    return response.json({ data: post });\n  }\n}\n```\n\n#### Request Compression\n\n```typescript\n// app/middleware/compression_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\nimport { gzip, deflate } from \"node:zlib\";\nimport { promisify } from \"node:util\";\n\nexport default class CompressionMiddleware {\n  private gzipAsync = promisify(gzip);\n  private deflateAsync = promisify(deflate);\n\n  async handle(ctx: HttpContext, next: NextFn) {\n    await next();\n\n    const { request, response } = ctx;\n    const acceptEncoding = request.header(\"accept-encoding\", \"\");\n    const body = response.getBody();\n\n    // Only compress if body is substantial\n    if (!body || typeof body !== \"string\" || body.length < 1024) {\n      return;\n    }\n\n    try {\n      if (acceptEncoding.includes(\"gzip\")) {\n        const compressed = await this.gzipAsync(body);\n        response.header(\"Content-Encoding\", \"gzip\");\n        response.header(\"Content-Length\", compressed.length.toString());\n        response.send(compressed);\n      } else if (acceptEncoding.includes(\"deflate\")) {\n        const compressed = await this.deflateAsync(body);\n        response.header(\"Content-Encoding\", \"deflate\");\n        response.header(\"Content-Length\", compressed.length.toString());\n        response.send(compressed);\n      }\n    } catch (error) {\n      // Fall back to uncompressed response\n      console.error(\"Compression failed:\", error);\n    }\n  }\n}\n```\n\n### Background Jobs\n\n```typescript\n// app/services/queue_service.ts\nimport redis from \"@adonisjs/redis/services/main\";\n\nexport default class QueueService {\n  // ✅ Add job to queue\n  async addJob(queueName: string, jobData: any) {\n    const job = {\n      id: Date.now().toString(),\n      data: jobData,\n      createdAt: new Date().toISOString(),\n    };\n\n    await redis.lpush(`queue:${queueName}`, JSON.stringify(job));\n  }\n\n  // ✅ Process jobs\n  async processJobs(\n    queueName: string,\n    processor: (data: any) => Promise<void>,\n  ) {\n    while (true) {\n      try {\n        const jobData = await redis.brpop(`queue:${queueName}`, 10);\n        if (!jobData) continue;\n\n        const job = JSON.parse(jobData[1]);\n        await processor(job.data);\n        console.log(`Job ${job.id} completed`);\n      } catch (error) {\n        console.error(\"Job processing error:\", error);\n      }\n    }\n  }\n}\n```\n\n### Performance Monitoring\n\n```typescript\n// app/middleware/performance_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\nimport logger from \"@adonisjs/core/services/logger\";\n\nexport default class PerformanceMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    const startTime = Date.now();\n\n    try {\n      const result = await next();\n\n      const duration = Date.now() - startTime;\n\n      // Log slow requests\n      if (duration > 1000) {\n        logger.warn(\"Slow request\", {\n          method: ctx.request.method(),\n          url: ctx.request.url(),\n          duration: `${duration}ms`,\n        });\n      }\n\n      // Add response time header\n      ctx.response.header(\"X-Response-Time\", `${duration}ms`);\n\n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      logger.error(\"Request failed\", {\n        method: ctx.request.method(),\n        url: ctx.request.url(),\n        duration: `${duration}ms`,\n        error: error.message,\n      });\n\n      throw error;\n    }\n  }\n}\n```\n\n### Performance Best Practices\n\n#### DO's\n\n```typescript\n// ✅ Use database transactions for related operations\nasync createUserWithProfile(userData: any, profileData: any) {\n  const trx = await Database.transaction()\n\n  try {\n    const user = await User.create(userData, { client: trx })\n    const profile = await Profile.create({\n      ...profileData,\n      userId: user.id\n    }, { client: trx })\n\n    await trx.commit()\n    return { user, profile }\n  } catch (error) {\n    await trx.rollback()\n    throw error\n  }\n}\n\n// ✅ Use bulk operations for multiple records\nasync updateMultipleUsers(userIds: number[], data: any) {\n  return await User.query()\n    .whereIn('id', userIds)\n    .update(data)\n}\n\n// ✅ Implement proper pagination\nasync getPaginatedPosts(page: number, limit: number) {\n  return await Post.query()\n    .preload('author', query => query.select(['id', 'name']))\n    .paginate(page, Math.min(limit, 100)) // Cap at 100\n}\n```\n\n#### DON'Ts\n\n```typescript\n// ❌ N+1 query problem\nasync getBadPosts() {\n  const posts = await Post.all()\n\n  for (const post of posts) {\n    post.author = await User.find(post.userId) // N+1 queries!\n  }\n\n  return posts\n}\n\n// ❌ Loading too much data\nasync getAllUsers() {\n  return await User.all() // Could be millions of records!\n}\n\n// ❌ Not using indexes\nawait User.query().where('email', 'like', '%@gmail.com') // Can't use index\n\n// ❌ Synchronous operations in async context\nasync processFile() {\n  const data = fs.readFileSync('large-file.txt') // Blocks the event loop\n  return data\n}\n```\n\n### Sources\n\n- [AdonisJS Performance Guide](https://docs.adonisjs.com/guides/performance)\n- [Node.js Performance Best Practices](https://nodejs.org/en/docs/guides/simple-profiling/)\n- [Database Performance](https://lucid.adonisjs.com/docs/query-performance)\n- [Redis Caching](https://docs.adonisjs.com/guides/redis)\n"
    },
    {
      "parent": "adonisjs",
      "id": "security",
      "name": "Security",
      "description": "Security best practices for AdonisJS 6 applications",
      "type": "rule",
      "content": "## Security Best Practices\n\n### Input Validation and Sanitization\n\nALWAYS validate and sanitize user input using VineJS validators:\n\n```typescript\n// ✅ Correct: Comprehensive input validation\nexport const createPostValidator = vine.compile(\n  vine.object({\n    title: vine.string().minLength(1).maxLength(200).trim(),\n    content: vine.string().minLength(10).escape(), // Escape HTML\n    slug: vine.string().regex(/^[a-z0-9-]+$/), // Only alphanumeric and hyphens\n    tags: vine.array(vine.string().minLength(1).maxLength(50)).maxLength(10),\n    categoryId: vine.number().positive(),\n    metadata: vine\n      .object({\n        seoTitle: vine.string().maxLength(60).trim().optional(),\n        seoDescription: vine.string().maxLength(160).trim().optional(),\n      })\n      .optional(),\n  }),\n);\n\n// ✅ Correct: File upload validation\nexport const uploadValidator = vine.compile(\n  vine.object({\n    file: vine.file({\n      size: \"5mb\",\n      extnames: [\"jpg\", \"jpeg\", \"png\", \"gif\", \"pdf\", \"doc\", \"docx\"],\n    }),\n    description: vine.string().maxLength(500).optional(),\n  }),\n);\n```\n\n### Authentication Security\n\n#### Password Security\n\n```typescript\n// app/models/user.ts\nimport hash from \"@adonisjs/core/services/hash\";\n\nexport default class User extends BaseModel {\n  @column({ serializeAs: null })\n  declare password: string;\n\n  // ✅ Correct: Hash passwords\n  @beforeSave()\n  static async hashPassword(user: User) {\n    if (user.$dirty.password) {\n      user.password = await hash.make(user.password);\n    }\n  }\n\n  // ✅ Correct: Password verification\n  async verifyPassword(plainPassword: string) {\n    return await hash.verify(this.password, plainPassword);\n  }\n}\n```\n\n#### Session Security\n\n```typescript\n// config/session.ts\nimport env from \"#start/env\";\n\nexport default {\n  driver: env.get(\"SESSION_DRIVER\"),\n  cookieName: \"adonis-session\",\n\n  // ✅ Secure session configuration\n  cookie: {\n    path: \"/\",\n    maxAge: \"2h\",\n    httpOnly: true, // Prevent XSS\n    secure: env.get(\"NODE_ENV\") === \"production\", // HTTPS in production\n    sameSite: \"strict\", // CSRF protection\n  },\n\n  age: \"2 hours\",\n};\n```\n\n#### JWT Token Security\n\n```typescript\n// app/services/auth_service.ts\nimport jwt from \"jsonwebtoken\";\nimport env from \"#start/env\";\n\nexport default class AuthService {\n  // ✅ Correct: JWT token generation\n  generateToken(user: User) {\n    return jwt.sign(\n      {\n        sub: user.id,\n        email: user.email,\n        role: user.role,\n      },\n      env.get(\"JWT_SECRET\"),\n      {\n        expiresIn: \"1h\",\n      },\n    );\n  }\n\n  // ✅ Correct: Token verification\n  verifyToken(token: string) {\n    return jwt.verify(token, env.get(\"JWT_SECRET\"));\n  }\n}\n```\n\n### CORS Security\n\n```typescript\n// config/cors.ts\nimport env from \"#start/env\";\n\nexport default {\n  enabled: true,\n\n  // ✅ Correct: Configure allowed origins\n  origin:\n    env.get(\"NODE_ENV\") === \"production\" ? [\"https://yourdomain.com\"] : true, // Allow all origins in development\n\n  methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n  headers: [\"Content-Type\", \"Authorization\"],\n  credentials: true,\n};\n```\n\n### SQL Injection Prevention\n\n```typescript\n// ✅ Correct: Use query builder (automatically escapes)\nconst users = await User.query()\n  .where(\"email\", email)\n  .where(\"role\", role)\n  .limit(10);\n\n// ✅ Correct: Parameterized raw queries\nconst result = await Database.rawQuery(\n  \"SELECT * FROM users WHERE email = ? AND created_at > ?\",\n  [email, startDate],\n);\n\n// ❌ Incorrect: String concatenation (vulnerable to SQL injection)\nconst result = await Database.rawQuery(\n  `SELECT * FROM users WHERE email = '${email}'`,\n);\n```\n\n### XSS Prevention\n\n```typescript\n// app/middleware/security_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\n\nexport default class SecurityMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    // ✅ Correct: Set security headers\n    ctx.response.header(\"X-Content-Type-Options\", \"nosniff\");\n    ctx.response.header(\"X-Frame-Options\", \"DENY\");\n    ctx.response.header(\"X-XSS-Protection\", \"1; mode=block\");\n\n    // ✅ Basic Content Security Policy\n    ctx.response.header(\"Content-Security-Policy\", \"default-src 'self'\");\n\n    return await next();\n  }\n}\n```\n\n### CSRF Protection\n\n```typescript\n// app/middleware/csrf_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\n\nexport default class CsrfMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    const { request, response, session } = ctx;\n\n    // ✅ Generate CSRF token for safe methods\n    if ([\"GET\", \"HEAD\", \"OPTIONS\"].includes(request.method())) {\n      const token = await this.generateToken();\n      session.put(\"_csrf_token\", token);\n      response.header(\"X-CSRF-Token\", token);\n      return await next();\n    }\n\n    // ✅ Verify CSRF token for unsafe methods\n    const sessionToken = session.get(\"_csrf_token\");\n    const requestToken =\n      request.header(\"x-csrf-token\") || request.input(\"_csrf_token\");\n\n    if (!sessionToken || !requestToken || sessionToken !== requestToken) {\n      return response.forbidden({\n        error: \"CSRF token mismatch\",\n        code: \"CSRF_TOKEN_MISMATCH\",\n      });\n    }\n\n    return await next();\n  }\n\n  private async generateToken(): Promise<string> {\n    const crypto = await import(\"node:crypto\");\n    return crypto.randomBytes(32).toString(\"hex\");\n  }\n}\n```\n\n### Rate Limiting\n\n```typescript\n// app/middleware/rate_limit_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\nimport redis from \"@adonisjs/redis/services/main\";\n\nexport default class RateLimitMiddleware {\n  async handle(\n    ctx: HttpContext,\n    next: NextFn,\n    options: { max: number; window: number },\n  ) {\n    const { request, response } = ctx;\n    const key = `rate_limit:${request.ip()}`;\n\n    const current = await redis.get(key);\n    const requests = current ? parseInt(current) : 0;\n\n    if (requests >= options.max) {\n      return response.tooManyRequests({\n        error: \"Too many requests\",\n      });\n    }\n\n    // Increment counter\n    await redis.incr(key);\n    await redis.expire(key, options.window);\n\n    // Add rate limit headers\n    response.header(\"X-RateLimit-Limit\", options.max.toString());\n    response.header(\n      \"X-RateLimit-Remaining\",\n      (options.max - requests - 1).toString(),\n    );\n\n    return await next();\n  }\n}\n```\n\n### File Upload Security\n\n```typescript\n// app/services/file_upload_service.ts\nimport { MultipartFile } from \"@adonisjs/core/bodyparser\";\n\nexport default class FileUploadService {\n  private allowedMimeTypes = [\"image/jpeg\", \"image/png\", \"application/pdf\"];\n\n  async uploadFile(file: MultipartFile): Promise<string> {\n    // ✅ Validate file type\n    if (!this.allowedMimeTypes.includes(file.type || \"\")) {\n      throw new Error(\"File type not allowed\");\n    }\n\n    // ✅ Validate file size (2MB max)\n    if (file.size > 2 * 1024 * 1024) {\n      throw new Error(\"File too large\");\n    }\n\n    // ✅ Generate secure filename\n    const filename = this.generateSecureFilename(file.extname || \"\");\n    await file.move(\"uploads\", { name: filename });\n\n    return filename;\n  }\n\n  private generateSecureFilename(extension: string): string {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substring(2);\n    return `${timestamp}_${random}${extension}`;\n  }\n}\n```\n\n### Environment Security\n\n```typescript\n// start/env.ts\nimport { Env } from \"@adonisjs/core/env\";\n\nexport default await Env.create(new URL(\"../\", import.meta.url), {\n  // ✅ Environment validation\n  NODE_ENV: Env.schema.enum([\"development\", \"production\", \"test\"] as const),\n  APP_KEY: Env.schema.string(),\n  DB_PASSWORD: Env.schema.string(),\n  JWT_SECRET: Env.schema.string(),\n});\n```\n\n### Secure Logging\n\n```typescript\n// app/services/audit_service.ts\nimport logger from \"@adonisjs/core/services/logger\";\n\nexport default class AuditService {\n  // ✅ Log authentication attempts\n  logAuthenticationAttempt(email: string, success: boolean) {\n    logger.info(\"Authentication attempt\", {\n      email: this.maskEmail(email),\n      success,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  // ✅ Log data access\n  logDataAccess(userId: number, resource: string, action: string) {\n    logger.info(\"Data access\", {\n      userId,\n      resource,\n      action,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  private maskEmail(email: string): string {\n    const [username, domain] = email.split(\"@\");\n    return `${username.substring(0, 2)}***@${domain}`;\n  }\n}\n```\n\n### Security Headers\n\n```typescript\n// app/middleware/security_headers_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\n\nexport default class SecurityHeadersMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    const { response } = ctx;\n\n    // ✅ Basic security headers\n    response.header(\"X-Content-Type-Options\", \"nosniff\");\n    response.header(\"X-Frame-Options\", \"DENY\");\n    response.header(\"X-XSS-Protection\", \"1; mode=block\");\n\n    // ✅ HTTPS enforcement in production\n    if (ctx.request.secure()) {\n      response.header(\"Strict-Transport-Security\", \"max-age=31536000\");\n    }\n\n    return await next();\n  }\n}\n```\n\n### Common Security Anti-Patterns\n\n```typescript\n// ❌ Incorrect: Exposing sensitive information\nreturn response.json({\n  user: user, // Includes password hash and other sensitive data\n  token: token\n})\n\n// ✅ Correct: Only expose necessary data\nreturn response.json({\n  user: {\n    id: user.id,\n    email: user.email,\n    name: user.name,\n    role: user.role\n  },\n  token: token\n})\n\n// ❌ Incorrect: No input validation\nasync store({ request }: HttpContext) {\n  const data = request.all() // Raw, unvalidated data\n  return User.create(data)\n}\n\n// ✅ Correct: Always validate input\nasync store({ request }: HttpContext) {\n  const data = await request.validateUsing(createUserValidator)\n  return User.create(data)\n}\n\n// ❌ Incorrect: Logging sensitive data\nlogger.info('User login', { email, password, token })\n\n// ✅ Correct: Log only non-sensitive data\nlogger.info('User login', {\n  email: maskEmail(email),\n  success: true,\n  timestamp: new Date()\n})\n\n// ❌ Incorrect: Weak authentication\nif (user.password === plainPassword) {\n  // Never compare passwords directly\n}\n\n// ✅ Correct: Secure password verification\nif (await user.verifyPassword(plainPassword)) {\n  // Use proper password hashing/verification\n}\n```\n\n### Security Checklist\n\n#### Before Deployment\n\n- [ ] All environment variables are validated\n- [ ] APP_KEY is 32+ characters and unique per environment\n- [ ] HTTPS is enforced in production\n- [ ] Database credentials are secure and not default\n- [ ] All user inputs are validated and sanitized\n- [ ] File uploads are restricted and validated\n- [ ] Rate limiting is implemented on sensitive endpoints\n- [ ] CORS is properly configured\n- [ ] Security headers are set\n- [ ] Sensitive data is not logged\n- [ ] Dependencies are up to date and vulnerability-free\n- [ ] Database queries use parameterization\n- [ ] Sessions are configured securely\n- [ ] Error messages don't reveal sensitive information\n\n### Sources\n\n- [AdonisJS Security Guide](https://docs.adonisjs.com/guides/security)\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [Node.js Security Best Practices](https://nodejs.org/en/docs/guides/security/)\n- [MDN Web Security](https://developer.mozilla.org/en-US/docs/Web/Security)\n"
    },
    {
      "parent": "adonisjs",
      "id": "structure",
      "name": "Project Structure",
      "description": "Guidelines for organizing AdonisJS 6 applications",
      "type": "rule",
      "content": "## Project Structure\n\n### Standard AdonisJS 6 Structure\n\n```\nroot/\n├── app/\n│   ├── controllers/         # HTTP controllers\n│   ├── middleware/         # Custom middleware\n│   ├── models/             # Lucid ORM models\n│   ├── services/           # Business logic services\n│   ├── validators/         # VineJS validation schemas\n│   ├── exceptions/         # Custom exceptions\n│   └── policies/           # Authorization policies\n├── bin/\n│   ├── console.ts          # Console commands entry\n│   ├── server.ts           # HTTP server entry\n│   └── test.ts             # Testing entry\n├── config/\n│   ├── app.ts              # App configuration\n│   ├── database.ts         # Database configuration\n│   ├── cors.ts             # CORS configuration\n│   ├── session.ts          # Session configuration\n│   └── auth.ts             # Authentication config\n├── database/\n│   ├── migrations/         # Database migrations\n│   ├── seeders/           # Database seeders\n│   └── factories/         # Model factories\n├── public/                 # Static assets\n├── resources/\n│   ├── views/             # Edge templates\n│   ├── js/                # Frontend JavaScript\n│   └── css/               # Frontend CSS\n├── start/\n│   ├── routes.ts          # Route definitions\n│   ├── kernel.ts          # HTTP kernel\n│   └── env.ts             # Environment validation\n├── tests/\n│   ├── functional/        # End-to-end tests\n│   ├── unit/             # Unit tests\n│   └── bootstrap.ts      # Test bootstrap\n├── types/                 # TypeScript definitions\n├── .env                   # Environment variables\n├── .env.example          # Environment template\n├── adonisrc.ts           # AdonisJS configuration\n├── package.json          # Dependencies\n└── tsconfig.json         # TypeScript config\n```\n\n### Mandatory Rules\n\n- ALWAYS use the `app/` directory for application domain logic\n- Controllers MUST be placed in `app/controllers/`\n- Models MUST be placed in `app/models/`\n- Middleware MUST be placed in `app/middleware/`\n- Services MUST be placed in `app/services/`\n- Validators MUST be placed in `app/validators/`\n- Routes MUST be defined in `start/routes.ts`\n- Configuration files MUST be placed in `config/`\n- Database files MUST be placed in `database/`\n- NEVER commit `.env` files to version control\n- ALWAYS provide `.env.example` with sample values\n\n### File Naming Conventions\n\n- Controllers: PascalCase with \"Controller\" suffix (e.g., `UsersController.ts`)\n- Models: PascalCase, singular (e.g., `User.ts`)\n- Middleware: PascalCase with \"Middleware\" suffix (e.g., `AuthMiddleware.ts`)\n- Services: PascalCase with \"Service\" suffix (e.g., `UserService.ts`)\n- Validators: PascalCase with \"Validator\" suffix (e.g., `UserValidator.ts`)\n- Routes: snake_case for file names (e.g., `user_routes.ts`)\n- Config files: snake_case (e.g., `database.ts`)\n\n### Import Aliases\n\nAdonisJS 6 provides sub-path imports via `package.json`:\n\n```json\n{\n  \"imports\": {\n    \"#controllers/*\": \"./app/controllers/*.js\",\n    \"#models/*\": \"./app/models/*.js\",\n    \"#middleware/*\": \"./app/middleware/*.js\",\n    \"#services/*\": \"./app/services/*.js\",\n    \"#validators/*\": \"./app/validators/*.js\",\n    \"#config/*\": \"./config/*.js\",\n    \"#types/*\": \"./types/*.js\"\n  }\n}\n```\n\nALWAYS use these import aliases instead of relative paths:\n\n```typescript\n// ✅ Correct\nimport User from \"#models/user\";\nimport UsersController from \"#controllers/users_controller\";\n\n// ❌ Incorrect\nimport User from \"../models/User.js\";\nimport UsersController from \"./UsersController.js\";\n```\n\n### Examples\n\n#### Basic Controller Structure\n\n```typescript\n// app/controllers/users_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport User from \"#models/user\";\n\nexport default class UsersController {\n  async index({ response }: HttpContext) {\n    const users = await User.all();\n    return response.json(users);\n  }\n\n  async show({ params, response }: HttpContext) {\n    const user = await User.findOrFail(params.id);\n    return response.json(user);\n  }\n}\n```\n\n#### Service Layer Structure\n\n```typescript\n// app/services/user_service.ts\nimport User from \"#models/user\";\nimport { Exception } from \"@adonisjs/core/exceptions\";\n\nexport default class UserService {\n  async createUser(data: { email: string; password: string }) {\n    const existingUser = await User.findBy(\"email\", data.email);\n    if (existingUser) {\n      throw new Exception(\"User already exists\", { status: 409 });\n    }\n\n    return await User.create(data);\n  }\n\n  async getUserProfile(userId: number) {\n    return await User.query()\n      .where(\"id\", userId)\n      .preload(\"posts\")\n      .firstOrFail();\n  }\n}\n```\n\n#### Route Organization\n\n```typescript\n// start/routes.ts\nimport router from \"@adonisjs/core/services/router\";\nimport { middleware } from \"./kernel.js\";\n\n// API routes\nrouter\n  .group(() => {\n    router.get(\"users\", \"#controllers/users_controller.index\");\n    router.post(\"users\", \"#controllers/users_controller.store\");\n    router.get(\"users/:id\", \"#controllers/users_controller.show\");\n    router.put(\"users/:id\", \"#controllers/users_controller.update\");\n    router.delete(\"users/:id\", \"#controllers/users_controller.destroy\");\n  })\n  .prefix(\"api/v1\")\n  .middleware([middleware.auth()]);\n\n// Auth routes\nrouter\n  .group(() => {\n    router.post(\"login\", \"#controllers/auth_controller.login\");\n    router.post(\"register\", \"#controllers/auth_controller.register\");\n    router.post(\"logout\", \"#controllers/auth_controller.logout\");\n  })\n  .prefix(\"auth\");\n```\n\n### Sources\n\n- [AdonisJS 6 Folder Structure](https://docs.adonisjs.com/guides/folder-structure)\n- [Import Aliases](https://docs.adonisjs.com/guides/folder-structure#import-aliases)\n- [File Structure Best Practices](https://docs.adonisjs.com/guides/folder-structure)\n"
    },
    {
      "parent": "adonisjs",
      "id": "testing",
      "name": "Testing",
      "description": "Guidelines for testing patterns in AdonisJS 6",
      "type": "rule",
      "content": "## Testing Patterns\n\n### Test Structure\n\nTests MUST be organized in the `tests/` directory:\n\n```\ntests/\n├── bootstrap.ts          # Test bootstrap\n├── functional/          # End-to-end tests\n│   ├── auth.spec.ts     # Authentication tests\n│   ├── users.spec.ts    # User management tests\n│   └── posts.spec.ts    # Post management tests\n├── unit/                # Unit tests\n│   ├── models/          # Model tests\n│   ├── services/        # Service tests\n│   ├── validators/      # Validator tests\n│   └── middleware/      # Middleware tests\n└── integration/         # Integration tests\n    ├── database.spec.ts # Database tests\n    └── email.spec.ts    # Email service tests\n```\n\n### Test Configuration\n\n```typescript\n// tests/bootstrap.ts\nimport { assert } from \"@japa/assert\";\nimport { expectTypeOf } from \"@japa/expect-type\";\nimport { configure, processCLIArgs, run } from \"@japa/runner\";\nimport { fileSystem } from \"@japa/file-system\";\nimport { apiClient } from \"@japa/api-client\";\n\nprocessCLIArgs(process.argv.splice(2));\n\nconfigure({\n  files: [\n    \"tests/unit/**/*.spec.ts\",\n    \"tests/functional/**/*.spec.ts\",\n    \"tests/integration/**/*.spec.ts\",\n  ],\n  plugins: [\n    assert(),\n    expectTypeOf(),\n    fileSystem(),\n    apiClient({\n      baseURL: \"http://localhost:3333\",\n    }),\n  ],\n  reporters: {\n    activated: [\"spec\"],\n    list: [\"spec\"],\n  },\n});\n\nrun();\n```\n\n### Unit Testing\n\n#### Model Testing\n\n```typescript\n// tests/unit/models/user.spec.ts\nimport { test } from \"@japa/runner\";\nimport User from \"#models/user\";\nimport { UserFactory } from \"#factories/user_factory\";\n\ntest.group(\"User Model\", () => {\n  test(\"should hash password before saving\", async ({ assert }) => {\n    const user = new User();\n    user.email = \"test@example.com\";\n    user.password = \"plaintext\";\n    user.fullName = \"Test User\";\n\n    await user.save();\n\n    assert.notEqual(user.password, \"plaintext\");\n    assert.isTrue(await user.verifyPassword(\"plaintext\"));\n  });\n\n  test(\"should generate username from email if not provided\", async ({\n    assert,\n  }) => {\n    const user = await User.create({\n      email: \"john.doe@example.com\",\n      password: \"password123\",\n      fullName: \"John Doe\",\n    });\n\n    assert.equal(user.username, \"john.doe\");\n  });\n\n  test(\"should have posts relationship\", async ({ assert }) => {\n    const user = await UserFactory.create();\n    const posts = await user.related(\"posts\").query();\n\n    assert.isArray(posts);\n  });\n});\n```\n\n#### Service Testing\n\n```typescript\n// tests/unit/services/user_service.spec.ts\nimport { test } from \"@japa/runner\";\nimport UserService from \"#services/user_service\";\nimport { UserFactory } from \"#factories/user_factory\";\n\ntest.group(\"User Service\", () => {\n  test(\"should create user with valid data\", async ({ assert }) => {\n    const userService = new UserService();\n\n    const userData = {\n      email: \"test@example.com\",\n      password: \"password123\",\n      fullName: \"Test User\",\n    };\n\n    const user = await userService.createUser(userData);\n\n    assert.equal(user.email, userData.email);\n    assert.equal(user.fullName, userData.fullName);\n    assert.exists(user.id);\n  });\n\n  test(\"should update user\", async ({ assert }) => {\n    const userService = new UserService();\n    const user = await UserFactory.create();\n\n    const updatedUser = await userService.updateUser(user.id, {\n      fullName: \"Updated Name\",\n    });\n\n    assert.equal(updatedUser.fullName, \"Updated Name\");\n  });\n});\n```\n\n#### Validator Testing\n\n```typescript\n// tests/unit/validators/user_validator.spec.ts\nimport { test } from \"@japa/runner\";\nimport vine from \"@vinejs/vine\";\nimport { createUserValidator } from \"#validators/user_validator\";\n\ntest.group(\"User Validator\", () => {\n  test(\"should validate correct user data\", async ({ assert }) => {\n    const data = {\n      email: \"test@example.com\",\n      password: \"SecurePass123!\",\n      passwordConfirmation: \"SecurePass123!\",\n      fullName: \"John Doe\",\n    };\n\n    const result = await vine.validate({\n      schema: createUserValidator,\n      data,\n    });\n\n    assert.properties(result, [\"email\", \"password\", \"fullName\"]);\n  });\n\n  test(\"should fail with invalid email format\", async ({ assert }) => {\n    const data = {\n      email: \"invalid-email\",\n      password: \"SecurePass123!\",\n      passwordConfirmation: \"SecurePass123!\",\n      fullName: \"John Doe\",\n    };\n\n    await assert.rejects(\n      () => vine.validate({ schema: createUserValidator, data }),\n      (error) => error.code === \"E_VALIDATION_ERROR\",\n    );\n  });\n\n  test(\"should fail with mismatched password confirmation\", async ({\n    assert,\n  }) => {\n    const data = {\n      email: \"test@example.com\",\n      password: \"SecurePass123!\",\n      passwordConfirmation: \"DifferentPass456!\",\n      fullName: \"John Doe\",\n    };\n\n    await assert.rejects(() =>\n      vine.validate({ schema: createUserValidator, data }),\n    );\n  });\n});\n```\n\n### Functional Testing\n\n#### Authentication Tests\n\n```typescript\n// tests/functional/auth.spec.ts\nimport { test } from \"@japa/runner\";\nimport { UserFactory } from \"#factories/user_factory\";\n\ntest.group(\"Authentication\", () => {\n  test(\"should login with valid credentials\", async ({ client, assert }) => {\n    const user = await UserFactory.create({\n      email: \"test@example.com\",\n      password: \"password123\",\n    });\n\n    const response = await client.post(\"/auth/login\").json({\n      email: \"test@example.com\",\n      password: \"password123\",\n    });\n\n    response.assertStatus(200);\n    response.assertBodyContains({\n      message: \"Login successful\",\n    });\n  });\n\n  test(\"should reject invalid credentials\", async ({ client }) => {\n    const response = await client.post(\"/auth/login\").json({\n      email: \"nonexistent@example.com\",\n      password: \"wrongpassword\",\n    });\n\n    response.assertStatus(401);\n    response.assertBodyContains({\n      error: \"Invalid credentials\",\n    });\n  });\n\n  test(\"should register new user\", async ({ client }) => {\n    const response = await client.post(\"/auth/register\").json({\n      email: \"newuser@example.com\",\n      password: \"password123\",\n      passwordConfirmation: \"password123\",\n      fullName: \"New User\",\n      agreeToTerms: true,\n    });\n\n    response.assertStatus(201);\n    response.assertBodyContains({\n      message: \"Registration successful\",\n    });\n  });\n\n  test(\"should access protected route with token\", async ({ client }) => {\n    const user = await UserFactory.create();\n    const token = await User.accessTokens.create(user);\n\n    const response = await client\n      .get(\"/api/profile\")\n      .header(\"Authorization\", `Bearer ${token.value!.release()}`);\n\n    response.assertStatus(200);\n    response.assertBodyContains({\n      user: {\n        id: user.id,\n        email: user.email,\n      },\n    });\n  });\n});\n```\n\n#### API Tests\n\n```typescript\n// tests/functional/posts.spec.ts\nimport { test } from \"@japa/runner\";\nimport { UserFactory } from \"#factories/user_factory\";\nimport { PostFactory } from \"#factories/post_factory\";\n\ntest.group(\"Posts API\", () => {\n  test(\"should list all posts\", async ({ client }) => {\n    await PostFactory.createMany(3);\n\n    const response = await client.get(\"/api/posts\");\n\n    response.assertStatus(200);\n    response.assertBodyContains({\n      data: (posts: any[]) => posts.length === 3,\n    });\n  });\n\n  test(\"should create post when authenticated\", async ({ client }) => {\n    const user = await UserFactory.create();\n    const token = await User.accessTokens.create(user);\n\n    const postData = {\n      title: \"Test Post\",\n      content: \"This is a test post content\",\n    };\n\n    const response = await client\n      .post(\"/api/posts\")\n      .header(\"Authorization\", `Bearer ${token.value!.release()}`)\n      .json(postData);\n\n    response.assertStatus(201);\n    response.assertBodyContains({\n      data: {\n        title: postData.title,\n      },\n    });\n  });\n\n  test(\"should reject unauthenticated post creation\", async ({ client }) => {\n    const response = await client.post(\"/api/posts\").json({\n      title: \"Test Post\",\n      content: \"Content\",\n    });\n\n    response.assertStatus(401);\n  });\n\n  test(\"should update own post\", async ({ client }) => {\n    const user = await UserFactory.create();\n    const post = await PostFactory.merge({ userId: user.id }).create();\n    const token = await User.accessTokens.create(user);\n\n    const response = await client\n      .put(`/api/posts/${post.id}`)\n      .header(\"Authorization\", `Bearer ${token.value!.release()}`)\n      .json({\n        title: \"Updated Title\",\n      });\n\n    response.assertStatus(200);\n    response.assertBodyContains({\n      data: {\n        title: \"Updated Title\",\n      },\n    });\n  });\n});\n```\n\n### Database Testing\n\n```typescript\n// tests/integration/database.spec.ts\nimport { test } from \"@japa/runner\";\nimport Database from \"@adonisjs/lucid/services/db\";\nimport User from \"#models/user\";\n\ntest.group(\"Database Integration\", () => {\n  test(\"should handle database transactions\", async ({ assert }) => {\n    const trx = await Database.transaction();\n\n    try {\n      const user = await User.create(\n        {\n          email: \"transaction@example.com\",\n          password: \"password123\",\n          fullName: \"Transaction User\",\n        },\n        { client: trx },\n      );\n\n      assert.exists(user.id);\n      await trx.rollback();\n\n      // User should not exist after rollback\n      const foundUser = await User.findBy(\"email\", \"transaction@example.com\");\n      assert.isNull(foundUser);\n    } catch (error) {\n      await trx.rollback();\n      throw error;\n    }\n  });\n});\n```\n\n### Model Factories\n\n```typescript\n// database/factories/user_factory.ts\nimport User from \"#models/user\";\nimport { Factory } from \"@adonisjs/lucid/factories\";\n\nexport const UserFactory = Factory.define(User, async ({ faker }) => {\n  return {\n    email: faker.internet.email(),\n    password: \"password123\",\n    fullName: faker.person.fullName(),\n    role: \"user\",\n  };\n}).build();\n```\n\n```typescript\n// database/factories/post_factory.ts\nimport Post from \"#models/post\";\nimport { Factory } from \"@adonisjs/lucid/factories\";\nimport { UserFactory } from \"./user_factory.js\";\n\nexport const PostFactory = Factory.define(Post, async ({ faker }) => {\n  return {\n    title: faker.lorem.sentence(),\n    content: faker.lorem.paragraphs(3),\n    slug: faker.lorem.slug(),\n    published: faker.datatype.boolean(),\n  };\n})\n  .relation(\"author\", () => UserFactory)\n  .build();\n```\n\n### Testing Middleware\n\n```typescript\n// tests/unit/middleware/auth_middleware.spec.ts\nimport { test } from \"@japa/runner\";\nimport { HttpContextFactory } from \"@adonisjs/core/factories/http\";\nimport AuthMiddleware from \"#middleware/auth_middleware\";\n\ntest.group(\"Auth Middleware\", () => {\n  test(\"should allow authenticated requests\", async ({ assert }) => {\n    const ctx = new HttpContextFactory().create();\n    const middleware = new AuthMiddleware();\n\n    // Mock authentication\n    ctx.auth.check = async () => {};\n    ctx.auth.isAuthenticated = true;\n\n    let nextCalled = false;\n    const next = async () => {\n      nextCalled = true;\n      return \"success\";\n    };\n\n    const result = await middleware.handle(ctx, next);\n\n    assert.isTrue(nextCalled);\n    assert.equal(result, \"success\");\n  });\n\n  test(\"should reject unauthenticated requests\", async ({ assert }) => {\n    const ctx = new HttpContextFactory().create();\n    const middleware = new AuthMiddleware();\n\n    // Mock failed authentication\n    ctx.auth.check = async () => {\n      throw new Error(\"Unauthenticated\");\n    };\n    ctx.auth.isAuthenticated = false;\n\n    let nextCalled = false;\n    const next = async () => {\n      nextCalled = true;\n    };\n\n    await middleware.handle(ctx, next);\n\n    assert.isFalse(nextCalled);\n    assert.equal(ctx.response.getStatus(), 401);\n  });\n});\n```\n\n### Test Database Setup\n\n```typescript\n// tests/setup.ts\nimport { test } from \"@japa/runner\";\nimport Database from \"@adonisjs/lucid/services/db\";\n\ntest.group.setup(async () => {\n  // Run migrations before tests\n  const { default: Migrator } = await import(\"@adonisjs/lucid/migrator\");\n  const migrator = new Migrator(Database, Application, {\n    direction: \"up\",\n  });\n  await migrator.run();\n});\n\ntest.group.teardown(async () => {\n  await Database.manager.closeAll();\n});\n\n// Clean database before each test\ntest.setup(async () => {\n  await Database.beginGlobalTransaction();\n});\n\ntest.teardown(async () => {\n  await Database.rollbackGlobalTransaction();\n});\n```\n\n### Test Best Practices\n\n#### DO's\n\n```typescript\n// ✅ Use descriptive test names\ntest(\"should create user with valid email and hashed password\", async () => {});\n\n// ✅ Use factories for test data\nconst user = await UserFactory.create();\n\n// ✅ Test edge cases\ntest(\"should handle empty request body\", async () => {});\ntest(\"should handle malformed JSON\", async () => {});\n\n// ✅ Use proper assertions\nresponse.assertStatus(201);\nresponse.assertBodyContains({ success: true });\n\n// ✅ Test error conditions\nawait assert.rejects(() => service.method(), \"Expected error message\");\n\n// ✅ Clean test data\ntest.teardown(async () => {\n  await Database.truncate(\"users\");\n});\n```\n\n#### DON'Ts\n\n```typescript\n// ❌ Vague test names\ntest(\"user test\", async () => {});\n\n// ❌ Testing implementation details\nassert.equal(user.hashedPassword.length, 60); // Testing bcrypt hash length\n\n// ❌ Hardcoded test data\nconst user = { id: 1, email: \"test@test.com\" };\n\n// ❌ Not testing error cases\n// Only testing happy path\n\n// ❌ Interdependent tests\ntest(\"first test\", async () => {\n  global.userId = user.id; // Don't share state\n});\n```\n\n### Running Tests\n\n```bash\n# ✅ Run all tests\nnode ace test\n\n# ✅ Run specific test file\nnode ace test tests/unit/models/user.spec.ts\n\n# ✅ Run tests with coverage\nnode ace test --coverage\n\n# ✅ Run tests in watch mode\nnode ace test --watch\n\n# ✅ Run only unit tests\nnode ace test tests/unit/**/*.spec.ts\n\n# ✅ Run tests with specific reporter\nnode ace test --reporter=json\n```\n\n### Sources\n\n- [Testing Documentation](https://docs.adonisjs.com/guides/testing)\n- [Japa Testing Framework](https://japa.dev)\n- [Model Factories](https://docs.adonisjs.com/guides/database#model-factories)\n- [HTTP Testing](https://japa.dev/docs/plugins/api-client)\n"
    },
    {
      "parent": "adonisjs",
      "id": "validation",
      "name": "Validation",
      "description": "Guidelines for VineJS validation in AdonisJS 6",
      "type": "rule",
      "content": "## VineJS Validation\n\n### Validator Structure\n\nValidators MUST be placed in `app/validators/` and follow these patterns:\n\n#### Basic Validator Structure\n\n```typescript\n// app/validators/user_validator.ts\nimport vine from \"@vinejs/vine\";\n\n// ✅ Correct: Create user validation schema\nexport const createUserValidator = vine.compile(\n  vine.object({\n    email: vine.string().email().normalizeEmail(),\n    password: vine.string().minLength(8).maxLength(32).confirmed(),\n    fullName: vine.string().minLength(2).maxLength(100),\n    dateOfBirth: vine.date().beforeOrEqual(\"today\"),\n    role: vine.enum([\"user\", \"admin\", \"moderator\"]).optional(),\n  }),\n);\n\n// ✅ Correct: Update user validation schema\nexport const updateUserValidator = vine.compile(\n  vine.object({\n    email: vine.string().email().normalizeEmail().optional(),\n    fullName: vine.string().minLength(2).maxLength(100).optional(),\n    dateOfBirth: vine.date().beforeOrEqual(\"today\").optional(),\n    role: vine.enum([\"user\", \"admin\", \"moderator\"]).optional(),\n  }),\n);\n\n// ✅ Correct: Login validation schema\nexport const loginValidator = vine.compile(\n  vine.object({\n    email: vine.string().email().normalizeEmail(),\n    password: vine.string().minLength(1),\n    rememberMe: vine.boolean().optional(),\n  }),\n);\n```\n\n#### Post Validator Patterns\n\n```typescript\n// app/validators/post_validator.ts\nimport vine from \"@vinejs/vine\";\n\n// ✅ Correct: Basic post validation\nexport const createPostValidator = vine.compile(\n  vine.object({\n    title: vine.string().minLength(5).maxLength(200),\n    content: vine.string().minLength(10),\n    slug: vine.string().regex(/^[a-z0-9-]+$/),\n    categoryId: vine.number().positive(),\n    tags: vine.array(vine.string()).minLength(1).maxLength(5),\n    publishedAt: vine.date().optional(),\n    featuredImage: vine\n      .file({\n        size: \"2mb\",\n        extnames: [\"jpg\", \"jpeg\", \"png\"],\n      })\n      .optional(),\n  }),\n);\n\n// ✅ Correct: Update post validation\nexport const updatePostValidator = vine.compile(\n  vine.object({\n    title: vine.string().minLength(5).maxLength(200).optional(),\n    content: vine.string().minLength(10).optional(),\n    slug: vine\n      .string()\n      .regex(/^[a-z0-9-]+$/)\n      .optional(),\n    categoryId: vine.number().positive().optional(),\n    tags: vine.array(vine.string()).optional(),\n    status: vine.enum([\"draft\", \"published\"]).optional(),\n  }),\n);\n```\n\n### Using Validators in Controllers\n\n```typescript\n// app/controllers/users_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport {\n  createUserValidator,\n  updateUserValidator,\n} from \"#validators/user_validator\";\nimport User from \"#models/user\";\n\nexport default class UsersController {\n  // ✅ Correct: Validate request data\n  async store({ request, response }: HttpContext) {\n    try {\n      const data = await request.validateUsing(createUserValidator);\n      const user = await User.create(data);\n      return response.status(201).json({ data: user });\n    } catch (error) {\n      if (error.code === \"E_VALIDATION_ERROR\") {\n        return response.badRequest({\n          error: \"Validation failed\",\n          messages: error.messages,\n        });\n      }\n      throw error;\n    }\n  }\n\n  // ✅ Correct: Validate with existing data check\n  async update({ params, request, response }: HttpContext) {\n    const user = await User.findOrFail(params.id);\n    const data = await request.validateUsing(updateUserValidator);\n\n    await user.merge(data).save();\n    return response.json({ data: user });\n  }\n\n  // ✅ Correct: Manual validation\n  async manualValidation({ request, response }: HttpContext) {\n    try {\n      const data = await vine.validate({\n        schema: createUserValidator,\n        data: request.all(),\n      });\n\n      // Process validated data\n      const user = await User.create(data);\n      return response.json({ data: user });\n    } catch (error) {\n      return response.badRequest({\n        error: \"Validation failed\",\n        messages: error.messages,\n      });\n    }\n  }\n}\n```\n\n### Common Validation Rules\n\n```typescript\n// app/validators/example_validator.ts\nimport vine from \"@vinejs/vine\";\n\nexport const exampleValidator = vine.compile(\n  vine.object({\n    // ✅ String validations\n    email: vine.string().email().normalizeEmail(),\n    username: vine.string().minLength(3).maxLength(20),\n    url: vine.string().url(),\n\n    // ✅ Number validations\n    age: vine.number().range([18, 100]),\n    price: vine.number().positive(),\n    quantity: vine.number().positive(),\n\n    // ✅ Date validations\n    birthDate: vine.date().beforeOrEqual(\"today\"),\n    startDate: vine.date(),\n    endDate: vine.date().afterField(\"startDate\"),\n\n    // ✅ Boolean validations\n    isActive: vine.boolean(),\n    agreeToTerms: vine.boolean().isTrue(),\n\n    // ✅ Array validations\n    tags: vine.array(vine.string()).minLength(1).maxLength(5),\n    categoryIds: vine.array(vine.number().positive()),\n\n    // ✅ File validations\n    avatar: vine.file({\n      size: \"2mb\",\n      extnames: [\"jpg\", \"jpeg\", \"png\"],\n    }),\n\n    // ✅ Nested object validations\n    address: vine.object({\n      street: vine.string().minLength(5),\n      city: vine.string().minLength(2),\n      postalCode: vine.string(),\n    }),\n\n    // ✅ Enums\n    status: vine.enum([\"active\", \"inactive\"]).optional(),\n    theme: vine.enum([\"light\", \"dark\"]).optional(),\n  }),\n);\n```\n\n### Custom Validation Rules\n\n```typescript\n// app/validators/custom_rules.ts\nimport vine from \"@vinejs/vine\";\nimport User from \"#models/user\";\n\n// ✅ Correct: Custom unique validation\nconst uniqueEmail = vine.createRule(async (value, options, field) => {\n  if (typeof value !== \"string\") {\n    return;\n  }\n\n  const user = await User.findBy(\"email\", value);\n  if (user) {\n    field.report(\"The {{ field }} field is not unique\", \"unique\", field);\n  }\n});\n\n// ✅ Usage of custom rules\nexport const userRegistrationValidator = vine.compile(\n  vine.object({\n    email: vine.string().email().use(uniqueEmail()),\n    password: vine.string().minLength(8),\n    passwordConfirmation: vine.string(),\n  }),\n);\n```\n\n### Validation Error Handling\n\n```typescript\n// app/exceptions/validation_exception_handler.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport { Exception } from \"@adonisjs/core/exceptions\";\n\nexport default class ValidationExceptionHandler {\n  // ✅ Correct: Handle validation errors globally\n  async handle(error: any, ctx: HttpContext) {\n    if (error.code === \"E_VALIDATION_ERROR\") {\n      return ctx.response.status(422).json({\n        error: \"Validation failed\",\n        messages: error.messages,\n        fields: this.formatErrors(error.messages),\n      });\n    }\n\n    // Handle other exceptions\n    return ctx.response.status(500).json({\n      error: \"Internal server error\",\n    });\n  }\n\n  private formatErrors(messages: any[]) {\n    return messages.reduce((acc, message) => {\n      acc[message.field] = message.message;\n      return acc;\n    }, {});\n  }\n}\n```\n\n### Validation Middleware\n\n```typescript\n// app/middleware/validate_middleware.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport type { NextFn } from \"@adonisjs/core/types/http\";\nimport vine from \"@vinejs/vine\";\n\nexport default class ValidateMiddleware {\n  async handle(ctx: HttpContext, next: NextFn, options: { validator: any }) {\n    try {\n      const validatedData = await ctx.request.validateUsing(options.validator);\n      ctx.validatedData = validatedData;\n    } catch (error) {\n      return ctx.response.badRequest({\n        error: \"Validation failed\",\n        messages: error.messages,\n      });\n    }\n\n    return await next();\n  }\n}\n\n// Usage in routes\nrouter\n  .post(\"users\", \"#controllers/users_controller.store\")\n  .middleware([middleware.validate({ validator: createUserValidator })]);\n```\n\n### Testing Validators\n\n```typescript\n// tests/unit/validators/user_validator.spec.ts\nimport { test } from \"@japa/runner\";\nimport vine from \"@vinejs/vine\";\nimport { createUserValidator } from \"#validators/user_validator\";\n\ntest.group(\"User Validator\", () => {\n  test(\"should validate correct user data\", async ({ assert }) => {\n    const data = {\n      email: \"test@example.com\",\n      password: \"SecurePass123!\",\n      passwordConfirmation: \"SecurePass123!\",\n      fullName: \"John Doe\",\n      dateOfBirth: \"1990-01-01\",\n    };\n\n    const result = await vine.validate({\n      schema: createUserValidator,\n      data,\n    });\n\n    assert.properties(result, [\"email\", \"password\", \"fullName\", \"dateOfBirth\"]);\n    assert.equal(result.email, \"test@example.com\");\n  });\n\n  test(\"should fail with invalid email\", async ({ assert }) => {\n    const data = {\n      email: \"invalid-email\",\n      password: \"SecurePass123!\",\n      passwordConfirmation: \"SecurePass123!\",\n      fullName: \"John Doe\",\n    };\n\n    try {\n      await vine.validate({\n        schema: createUserValidator,\n        data,\n      });\n      assert.fail(\"Should have thrown validation error\");\n    } catch (error) {\n      assert.equal(error.code, \"E_VALIDATION_ERROR\");\n      assert.isTrue(\n        error.messages.some(\n          (msg: any) => msg.field === \"email\" && msg.rule === \"email\",\n        ),\n      );\n    }\n  });\n});\n```\n\n### Validation Best Practices\n\n#### DO's\n\n```typescript\n// ✅ Correct: Use descriptive validator names\nexport const createUserValidator = vine.compile(...)\nexport const updateUserValidator = vine.compile(...)\nexport const loginValidator = vine.compile(...)\n\n// ✅ Correct: Normalize data\nemail: vine.string().email().normalizeEmail(),\nurl: vine.string().url().normalizeUrl(),\n\n// ✅ Correct: Use appropriate rules\npassword: vine.string().minLength(8).maxLength(32).confirmed(),\nage: vine.number().range([18, 100]),\n\n// ✅ Correct: Handle file uploads\navatar: vine.file({\n  size: '2mb',\n  extnames: ['jpg', 'jpeg', 'png']\n})\n\n// ✅ Correct: Use conditional validation\ncompanyName: vine.string().requiredWhen('userType', '=', 'business')\n```\n\n#### DON'Ts\n\n```typescript\n// ❌ Incorrect: Generic validator names\nexport const validator1 = vine.compile(...)\nexport const userValidator = vine.compile(...) // Too generic\n\n// ❌ Incorrect: Not using appropriate rules\nemail: vine.string(), // Should use .email()\nage: vine.string(),   // Should use .number()\n\n// ❌ Incorrect: Not handling optional fields\nexport const updateValidator = vine.compile(\n  vine.object({\n    email: vine.string().email(), // Should be optional for updates\n    name: vine.string()           // Should be optional for updates\n  })\n)\n\n// ❌ Incorrect: Not validating file uploads\nfile: vine.string() // Should use vine.file()\n\n// ❌ Incorrect: Not using enum for fixed values\nstatus: vine.string() // Should use vine.enum(['active', 'inactive'])\n```\n\n### Common Validation Patterns\n\n```typescript\n// ✅ Pagination validation\nexport const paginationValidator = vine.compile(\n  vine.object({\n    page: vine.number().positive().optional(),\n    limit: vine.number().range([1, 100]).optional(),\n    sortBy: vine.string().optional(),\n    sortOrder: vine.enum([\"asc\", \"desc\"]).optional(),\n  }),\n);\n\n// ✅ Search validation\nexport const searchValidator = vine.compile(\n  vine.object({\n    query: vine.string().minLength(2).maxLength(100),\n    category: vine.string().optional(),\n  }),\n);\n\n// ✅ Bulk operations validation\nexport const bulkUpdateValidator = vine.compile(\n  vine.object({\n    ids: vine.array(vine.number().positive()).minLength(1).maxLength(100),\n    action: vine.enum([\"activate\", \"deactivate\", \"delete\"]),\n  }),\n);\n```\n\n### Sources\n\n- [VineJS Documentation](https://vinejs.dev)\n- [Validation Rules](https://vinejs.dev/docs/validation_rules)\n- [Custom Rules](https://vinejs.dev/docs/custom_rules)\n- [AdonisJS Validation](https://docs.adonisjs.com/guides/validation)\n"
    }
  ],
  "docs": [
    {
      "id": "controllers",
      "name": "Controllers",
      "description": "Guidelines for controllers and routing patterns in AdonisJS 6",
      "type": "examples",
      "content": "## Controllers and Routing\n\n### Controller Guidelines\n\nControllers MUST be placed in `app/controllers/` and follow these patterns:\n\n#### Controller Structure\n\n```typescript\n// app/controllers/users_controller.ts\nimport type { HttpContext } from \"@adonisjs/core/http\";\nimport User from \"#models/user\";\n\nexport default class UsersController {\n  // Resource methods following RESTful conventions\n  async index({ response }: HttpContext) {\n    const users = await User.all();\n    return response.json(users);\n  }\n\n  async show({ params, response }: HttpContext) {\n    const user = await User.findOrFail(params.id);\n    return response.json(user);\n  }\n\n  async store({ request, response }: HttpContext) {\n    const data = request.only([\"email\", \"name\", \"password\"]);\n    const user = await User.create(data);\n    return response.status(201).json(user);\n  }\n\n  async update({ params, request, response }: HttpContext) {\n    const user = await User.findOrFail(params.id);\n    const data = request.only([\"email\", \"name\"]);\n    await user.merge(data).save();\n    return response.json(user);\n  }\n\n  async destroy({ params, response }: HttpContext) {\n    const resource = await Resource.findOrFail(params.id);\n    await resource.delete();\n    return response.status(204).send(\"\");\n  }\n}\n```\n\n#### Controller Best Practices\n\n- ALWAYS use TypeScript and type the HttpContext destructured parameters\n- ALWAYS use dependency injection via `@inject()` decorator for services\n- NEVER put business logic directly in controllers - use services\n- ALWAYS return consistent response formats\n- RELY on AdonisJS global error handling - avoid unnecessary try-catch blocks\n- ALWAYS validate input data using validators\n- NEVER access request body directly without validation\n\n### Route Organization\n\nRoutes MUST be defined in `start/routes.ts` following these patterns:\n\n#### Basic Routing\n\n```typescript\n// start/routes.ts\nimport router from \"@adonisjs/core/services/router\";\nimport { middleware } from \"./kernel.js\";\n\n// ✅ Correct: Use magic strings for lazy loading\nrouter.get(\"users\", \"#controllers/users_controller.index\");\nrouter.post(\"users\", \"#controllers/users_controller.store\");\n\n// ✅ Alternative: Direct import (not lazy loaded)\nimport UsersController from \"#controllers/users_controller\";\nrouter.get(\"users\", [UsersController, \"index\"]);\n```\n\n#### Resource Routes\n\n```typescript\n// ✅ Correct: Full resource routes\nrouter.resource(\"users\", \"#controllers/users_controller\");\n\n// ✅ Correct: API-only resource routes (no create/edit forms)\nrouter.resource(\"users\", \"#controllers/users_controller\").apiOnly();\n\n// ✅ Correct: Specific resource methods only\nrouter\n  .resource(\"users\", \"#controllers/users_controller\")\n  .only([\"index\", \"show\", \"store\"]);\n\n// ✅ Correct: Nested resources\nrouter.resource(\"users.posts\", \"#controllers/posts_controller\");\n```\n\n#### Route Groups\n\n```typescript\n// ✅ Correct: API versioning with groups\nrouter\n  .group(() => {\n    router.resource(\"entities\", \"#controllers/entities_controller\").apiOnly();\n    router.resource(\"items\", \"#controllers/items_controller\").apiOnly();\n    router\n      .resource(\"categories\", \"#controllers/categories_controller\")\n      .apiOnly();\n  })\n  .prefix(\"api/v1\")\n  .middleware([middleware.auth()]);\n\n// ✅ Correct: Admin routes with multiple middleware\nrouter\n  .group(() => {\n    router.get(\"dashboard\", \"#controllers/admin/dashboard_controller.index\");\n    router.resource(\"entities\", \"#controllers/admin/entities_controller\");\n  })\n  .prefix(\"admin\")\n  .middleware([middleware.auth(), middleware.admin()]);\n\n// ✅ Correct: Public routes\nrouter\n  .group(() => {\n    router.post(\"login\", \"#controllers/auth_controller.login\");\n    router.post(\"register\", \"#controllers/auth_controller.register\");\n    router.post(\n      \"forgot-password\",\n      \"#controllers/auth_controller.forgotPassword\",\n    );\n  })\n  .prefix(\"auth\");\n```\n\n#### Route Parameters\n\n```typescript\n// ✅ Correct: Route parameters with validation\nrouter\n  .get(\"resources/:id\", \"#controllers/resources_controller.show\")\n  .where(\"id\", router.matchers.number());\n\n// ✅ Correct: Optional parameters\nrouter.get(\"items/:slug?\", \"#controllers/items_controller.show\");\n\n// ✅ Correct: Wildcard parameters\nrouter.get(\"files/*\", \"#controllers/files_controller.serve\");\n\n// ✅ Correct: Multiple parameters\nrouter\n  .get(\"entities/:entityId/items/:itemId\", \"#controllers/items_controller.show\")\n  .where(\"entityId\", router.matchers.number())\n  .where(\"itemId\", router.matchers.number());\n```\n\n#### Route Middleware\n\n```typescript\n// ✅ Correct: Global middleware on routes\nrouter\n  .get(\"profile\", \"#controllers/resources_controller.profile\")\n  .middleware([middleware.auth()]);\n\n// ✅ Correct: Multiple middleware with options\nrouter\n  .post(\"admin/resources\", \"#controllers/admin/resources_controller.store\")\n  .middleware([middleware.auth(), middleware.role([\"admin\", \"moderator\"])]);\n\n// ✅ Correct: Route-specific middleware\nrouter\n  .get(\"api/resources\", \"#controllers/api/resources_controller.index\")\n  .middleware([middleware.throttle({ max: 100, duration: \"1m\" })]);\n```\n\n### HttpContext Usage\n\nALWAYS destructure only the properties you need from HttpContext:\n\n```typescript\n// ✅ Correct: Destructure only needed properties\nasync store({ request, response, auth }: HttpContext) {\n  const entity = auth.getUserOrFail()\n  const data = request.only(['field1', 'field2'])\n  // ...\n}\n\n// ❌ Incorrect: Using entire context\nasync store(ctx: HttpContext) {\n  const entity = ctx.auth.getUserOrFail()\n  const data = ctx.request.only(['field1', 'field2'])\n  // ...\n}\n```\n\n### Response Patterns\n\nALWAYS return consistent response formats:\n\n```typescript\nexport default class ResourcesController {\n  // ✅ Correct: Consistent success responses\n  async index({ response }: HttpContext) {\n    const resources = await Resource.all();\n    return response.json({\n      data: resources,\n      meta: {\n        total: resources.length,\n      },\n    });\n  }\n\n  // ✅ Correct: Let AdonisJS handle errors globally\n  async show({ params, response }: HttpContext) {\n    const resource = await Resource.findOrFail(params.id); // Throws 404 automatically\n    return response.json({ data: resource });\n  }\n\n  // ✅ Correct: Status codes for different operations\n  async store({ request, response }: HttpContext) {\n    const resource = await Resource.create(request.only([\"field1\", \"field2\"]));\n    return response.status(201).json({ data: resource });\n  }\n\n  async destroy({ params, response }: HttpContext) {\n    const resource = await Resource.findOrFail(params.id);\n    await resource.delete();\n    return response.status(204).send(\"\");\n  }\n}\n```\n\n### Route Testing\n\n```typescript\n// tests/functional/resources.spec.ts\nimport { test } from \"@japa/runner\";\n\ntest.group(\"Resources Controller\", () => {\n  test(\"should list all resources\", async ({ client }) => {\n    const response = await client.get(\"/api/resources\");\n\n    response.assertStatus(200);\n    response.assertBodyContains({\n      data: [],\n    });\n  });\n\n  test(\"should create a new resource\", async ({ client }) => {\n    const resourceData = {\n      field1: \"value1\",\n      field2: \"value2\",\n    };\n\n    const response = await client.post(\"/api/resources\").json(resourceData);\n\n    response.assertStatus(201);\n    response.assertBodyContains({\n      data: {\n        field1: resourceData.field1,\n        field2: resourceData.field2,\n      },\n    });\n  });\n});\n```\n\n### Common Anti-Patterns\n\n```typescript\n// ❌ Incorrect: Business logic in controller\nasync store({ request, response }: HttpContext) {\n  const field1 = request.input('field1')\n\n  // ❌ Don't put validation logic here\n  if (!field1 || field1.length < 3) {\n    return response.status(400).json({ error: 'Invalid field1' })\n  }\n\n  // ❌ Don't put complex business logic here\n  const existingResource = await Resource.findBy('field1', field1)\n  if (existingResource) {\n    return response.status(409).json({ error: 'Resource exists' })\n  }\n\n  const resource = await Resource.create(request.all())\n  return response.json(resource)\n}\n\n// ✅ Correct: Delegate to service\nasync store({ request, response }: HttpContext) {\n  const data = await request.validateUsing(CreateResourceValidator)\n  const resource = await this.resourceService.createResource(data)\n  return response.status(201).json({ data: resource })\n}\n```\n\n### Sources\n\n- [Controllers Documentation](https://docs.adonisjs.com/guides/controllers)\n- [Routing Documentation](https://docs.adonisjs.com/guides/routing)\n- [HTTP Context](https://docs.adonisjs.com/guides/context)\n- [Resource Routes](https://docs.adonisjs.com/guides/routing#resource-routes)\n- [Route Groups](https://docs.adonisjs.com/guides/routing#route-groups)\n- [Route Middleware](https://docs.adonisjs.com/guides/routing#route-middleware)\n- [Dependency Injection](https://docs.adonisjs.com/guides/dependency-injection)\n"
    }
  ],
  "presets": {
    "recommended": [
      "adonisjs:structure",
      "adonisjs:controllers",
      "adonisjs:models",
      "adonisjs:middleware",
      "adonisjs:validation",
      "adonisjs:env",
      "adonisjs:security",
      "adonisjs:errors"
    ],
    "fullstack": [
      "adonisjs:structure",
      "adonisjs:controllers",
      "adonisjs:models",
      "adonisjs:middleware",
      "adonisjs:validation",
      "adonisjs:auth",
      "adonisjs:providers",
      "adonisjs:config",
      "adonisjs:env",
      "adonisjs:testing",
      "adonisjs:security",
      "adonisjs:performance",
      "adonisjs:errors",
      "adonisjs:websockets"
    ],
    "api": [
      "adonisjs:structure",
      "adonisjs:controllers",
      "adonisjs:models",
      "adonisjs:middleware",
      "adonisjs:validation",
      "adonisjs:auth",
      "adonisjs:config",
      "adonisjs:env",
      "adonisjs:testing",
      "adonisjs:security",
      "adonisjs:performance",
      "adonisjs:errors",
      "adonisjs:api"
    ],
    "development": [
      "adonisjs:commands",
      "adonisjs:packages",
      "adonisjs:testing",
      "adonisjs:deployment"
    ]
  }
}
